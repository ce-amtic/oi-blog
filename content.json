{"pages":[{"title":"友链","text":"神仙Langlangago’s BlogShuYuMo’s BlogSmilingKnight’s Blog Christopher’s BlogRefined_hearthzwer OJDYYZOJ CodeforcesLibre Online JudgeUniversal Online JudgeLuoguHDU OJPKU OJVirtual Judge","link":"/friends.html"},{"title":"关于","text":"关于 Blog创建于 2019 年 1 月 30 日的深夜。（实际已经到了 31 日 00:20，Orz）2019.2 ~ 2019.6 托管于 GitHub，曾部署于疼训云。 博客采用基于 hexo 框架的 Icarus 主题，并进行了一定程度的修改。博客源码以及自用主题配置均可以在 GitHub 仓库中找到。 关于我一只现役 OI 蒟蒻，技不如人，肝败吓疯。 寻找可怜蒟蒻Luogu: @big_newsCodeforces: @ce_amticGitHub: @ce-amticE-mail: fyh516@126.comQQ：2981191397 关于 LaTeX本博客中的数学公式使用 MathJax 渲染。您可以通过右键单击公式框来打开 MathJax 命令栏，然后通过下面的方式获取 LaTeX 源代码。 关于搜索站内搜索系统采用了静态的 Insight 搜索引擎，初次加载内容索引可能会花费一段时间。您可以用它来搜索本站的文章，分类，标签，甚至是 html 页面。 关于评论系统评论系统采用了 Valine，基于 LeanCloud 提供的云计算服务。由于系统方面的一些特性，当您的评论有回复时，您有一定概率会收到邮件提醒。","link":"/about/index.html"},{"title":"Log","text":"2019.1.30 Built 2019.2.1 Basic framework completed 2019.2.17 1W Words 2019.2.26 2W Words 2019.3.8 3W Words 2019.3.17 4W Words 2019.3.22 Theme Changed 2019.4.14 Theme Changed 2019.4.16 ICO Redesigned 2019.5.4 50 posts 2019.6.30 Domain parked 2019.7.24 Record put 2019.10.7 100 Posts, 14W Words 2020.8.9 Icarus 3 Updated 2020.12.27 Icarus 4 Updated 2021.1.4 Streamlined content, 47 posts retracted (141 to 94) 2021.6 Domain UnParked","link":"/about/maintenance-log.html"},{"title":"Record","text":"This page holds something unpublished. Notes 2020.11 2020.12 2021.1 2021.2 2021.3","link":"/record/index.html"},{"title":"Blocks","text":"html blocks used in Blog. 1 Related Posts123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;此页面存在相关页面。关于，请参见&lt;a href=&quot;/path&quot;&gt;「」&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt; 此页面存在相关页面。关于asdf，请参见「asdf」。 2 Ideas123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;条件反射：看到xx，就应该想到xx。&lt;/div&gt;&lt;/article&gt; 条件反射：看到xx，就应该想到xx。 3 Exmple1234{% raw %}&lt;article class=&quot;message is-primary&quot; style=&quot;font-size:inherit&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}examples[url](markdown){% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} examplesurl 4 Info123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-info-circle mr-2&quot;&gt;&lt;/i&gt;Info.&lt;/div&gt;&lt;/article&gt; Info. 5 Issue123456&lt;article class=&quot;message message-immersive is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;Issue.&lt;/div&gt;&lt;/article&gt; Issue. 6 Warning123456&lt;article class=&quot;message message-immersive is-danger&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;Warnings.&lt;/div&gt;&lt;/article&gt; Warnings. 7 ICOs123456&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-clock mr-2&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-info-circle mr-2&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;","link":"/port/blocks.html"},{"title":"Port","text":"This page is just for blogger. A dock or a port?","link":"/port/index.html"},{"title":"Templates","text":"1 Article123456789101112131415161718192021222324252627---title: 样板date: y-m-d h:mcategories: 分类priority: 0tags: - 标签toc: truedonates:share:widgets: - type: toc position: right - type: recent_posts position: rightsidebar: left: sticky: false right: sticky: true---引文......&lt;!-- more --&gt; 2 Sulotion123456789101112131415161718192021222324252627---title: 「题解」样板date: y-m-d h:mcategories: 题解priority: 0tags: - 标签toc: truedonates:share:widgets: - type: toc position: right - type: recent_posts position: rightsidebar: left: sticky: false right: sticky: true---引文......&lt;!-- more --&gt;","link":"/port/templates.html"},{"title":"Control Panel","text":"Leancloud Apps Comments Manege DNS Manage Server Control Panel Site Analytics Site Push","link":"/port/control_panel.html"}],"posts":[{"title":"01-Trie","text":"众所周知，01-Trie 是字符集为 $\\begin{Bmatrix}0,1\\end{Bmatrix}$ 的 Trie ，可用于维护若干数字的二进制位，处理点对异或最值、某种动态异或和问题。 与线性基不同，01-Trie 无法处理子集异或问题，但是可以通过前缀和转化来处理区间异或问题。 1 简介01-Trie 支持在 $O(\\log a_i)$ 的时间内完成如下操作： 查询全局异或和 数列全局加一，维护全局异或和 查询数列中某个数与指定数字异或的最大值 合并两棵 01-Trie 维护的信息 通过将其可持久化，还可以支持如下操作： 查询区间异或和 查询区间中某个数与指定数字异或的最大值 通过观察容易实现上述若干操作，则可以得到这样一份代码： 1234567891011121314151617181920212223/* 非可持久化 */class TRIE { public: int ch[CN * 30][2], d[CN * 30], w[CN * 30], idx, rt, MAXH; #define lc ch[u][0] #define rc ch[u][1] TRIE() {rt = idx = 0, MAXH = 30;} int make() {return ++idx;} void mt(int u){ d[u] = 0, w[u] = w[lc] + w[rc]; if(rc) d[u] ^= (d[rc] &lt;&lt; 1) | (w[rc] &amp; 1); if(lc) d[u] ^= d[lc] &lt;&lt; 1; w[u] &amp;= 1; } void ins(int &amp;u, int x, int dep){ // 插入一个数 if(!u) u = make(); if(dep == MAXH) return (void)(w[u] ^= 1); if(x &amp; 1) ins(rc, x &gt;&gt; 1, dep + 1); else ins(lc, x &gt;&gt; 1, dep + 1); mt(u); } void add(int u) {if(rc) add(rc); swap(lc, rc), mt(u);} // 全局加一 int sum() {return d[rt];} // 全局异或和} D; 注意，01-Trie 的可持久化看上去并不支持版本修改，因为无法使用树状数组维护子树交换信息。 2 一道栗题 「TJOI2017」异或和 给定一段数列，定义数列的“连续和”为数列的某个子串的所有数之和，求序列所有连续和的异或值。 考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。 考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\\to l-1$ 时贡献的变化，它应该是这个样子： $$\\begin{aligned} &amp; (s[n]-s[l])\\oplus (s[n-1]-s[l])\\oplus … \\oplus (s[l+1]-s[l]) \\newline \\to &amp;(s[n]-s[l]+a[l-1])\\oplus (s[n-1]-s[l]+a[l-1])\\oplus …\\oplus a[l-1] \\end{aligned}$$ 其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\\sum a_i)\\log a_i)$；由于 $\\sum a_i \\le 10^6$，所以可以通过。 代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5 + 5;int read() { /* 略 */ }class TRIE { /* 同上 */ } D;int n, a[CN];int main(){ n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); int ans = 0; for(int i = n - 1; i + 1; i--){ int s = a[i + 1]; while(s--) D.add( D.rt ); D.ins(D.rt, a[i + 1], 1); ans ^= D.sum(); } printf(&quot;%d&quot;, ans);} 3 又一道栗题 「TJOI2018」异或 现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下： 1 x z：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。 2 x y z：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。 容易想到树剖，则转化为序列上的查询操作。通过版本来区分区间，即将 01-Tire 可持久化，即可解决本题。 可持久化 01-Trie 一般用于处理静态区间异或最大值问题。 容易得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}class TRIE { public: int rt[CN], ch[CN * 30][2], w[CN * 30], MAXH, idx; #define lc ch[u][0] #define rc ch[u][1] TRIE() {idx = 0, MAXH = 31;} int make() {return ++idx;} void ins(int &amp;u, int v, int x, int dep){ if(!u) u = make(); if(dep &lt; 0) return (void)(w[u] = w[v] + 1); int b = (x &gt;&gt; dep) &amp; 1; ch[u][!b] = ch[v][!b]; ins(ch[u][b], ch[v][b], x, dep - 1); w[u] = w[lc] + w[rc]; } int qm(int u, int v, int k, int dep){ if(dep &lt; 0) return 0; int b = (k &gt;&gt; dep) &amp; 1; if(w[ ch[u][!b] ] &gt; w[ ch[v][!b] ]) return (1 &lt;&lt; dep) | qm(ch[u][!b], ch[v][!b], k, dep - 1); else return qm(ch[u][b], ch[v][b], k, dep - 1); }} D;int n, q, v[CN], oid[CN];int top[CN], id[CN], sz[CN], imp[CN], dep[CN], fa[CN], idx = 0;void dfs1(int u, int p) { dep[u] = dep[p] + 1, sz[u] = 1, fa[u] = p; int mx = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs1(v, u), sz[u] += sz[v], mx = sz[v] &gt; mx ? imp[u] = v, sz[v] : mx; }}void dfs2(int u, int t){ top[u] = t, id[u] = ++idx; if(imp[u]) dfs2(imp[u], t); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ imp[u] &amp;&amp; v ^ fa[u]) dfs2(v, v); }}int qu(int x, int y, int z){ int ans = 0; while(top[x] != top[y]){ if(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y); ans = max(ans, D.qm(D.rt[ id[x] ], D.rt[ id[ top[x] ] - 1 ], z, D.MAXH)); x = fa[ top[x] ]; } if(dep[x] &lt; dep[y]) swap(x, y); ans = max(ans ,D.qm(D.rt[ id[x] ], D.rt[ id[y] - 1 ], z, D.MAXH)); return ans;}bool cmp(int x, int y) {return id[x] &lt; id[y];}int main(){ n = read(), q = read(); for(int i = 1; i &lt;= n; i++) v[i] = read(), oid[i] = i; for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} dfs1(1, 0), dfs2(1, 1); sort(oid + 1, oid + n + 1, cmp); for(int i = 1; i &lt;= n; i++) D.ins(D.rt[i], D.rt[i - 1], v[ oid[i] ], D.MAXH); while(q--){ int o = read(), x = read(), y = read(), z; if(o == 1) printf(&quot;%d&quot;, D.qm(D.rt[ id[x] + sz[x] - 1 ], D.rt[ id[x] - 1 ], y, D.MAXH)), puts(&quot;&quot;); else z = read(), printf(&quot;%d&quot;, qu(x, y, z)), puts(&quot;&quot;); }} 4 双一道栗题 「联合省选 2020 A」树 给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\\dots,c_k$，定义 $x$ 的价值为：$$val(x)=(v_{c_1}+d(c_1,x)) \\oplus (v_{c_2}+d(c_2,x)) \\oplus \\cdots \\oplus (v_{c_k}+d(c_k, x))$$其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。$\\oplus$ 表示异或运算。请你求出 $\\sum\\limits_{i=1}^n val(i)$ 的结果。 对每个叶子建立一棵 01-Trie ，然后每次合起来再全局加一即可得到父亲的 01-Trie ，统计答案即可。 01-Trie 合并的序列意义是：把两段序列的所有数字插入同一个 01-Trie ，并维护异或和。 容易得到如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 6e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;}}E[CN &lt;&lt; 2];int hd[CN],ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}class trie{ // dep = 0,dep &gt; 20 public: int ch[CN * 30][2], w[CN * 30], val[CN * 30], rt[CN], tot; trie() {memset(rt, 0, sizeof(rt)); tot = 0;} #define lc ch[u][0] #define rc ch[u][1] int make() {int u = ++tot; lc = rc = w[u] = val[u] = 0; return tot;} void maintain(int u){ w[u] = val[u] = 0; if(lc) w[u] += w[lc], val[u] ^= val[lc] &lt;&lt; 1; if(rc) w[u] += w[rc], val[u] ^= (val[rc] &lt;&lt; 1) | w[rc]; w[u] &amp;= 1; } void ins(int &amp;u,int x,int dep){ if(!u) u = make(); if(dep &gt; 20) return (void)(w[u] ^= 1); ins(ch[u][x &amp; 1], x &gt;&gt; 1, dep + 1); maintain(u); } void addall(int u) {if(rc) addall(rc); swap(lc, rc); maintain(u);} int merge(int u,int k){ if(!k) return u; if(!u) return k; w[u] = (w[u] + w[k]) &amp; 1; val[u] ^= val[k]; lc = merge(lc, ch[k][0]); rc = merge(rc, ch[k][1]); return u; }}D;int n,v[CN],va[CN];void dfs(int u){ if(!hd[u]){ va[u] = v[u]; D.ins(D.rt[u], v[u], 0); return; } int k = hd[u], s1; for(; k; k = E[k].nxt) dfs(E[k].to); k = hd[u], s1 = E[k].to, k = E[k].nxt, D.rt[u] = D.rt[s1]; for(; k; k = E[k].nxt){ int v = E[k].to; D.merge(D.rt[u], D.rt[v]); } D.addall(D.rt[u]), D.ins(D.rt[u], v[u], 0); va[u] = D.val[ D.rt[u] ];}int main(){ n = read(); for(int i = 1;i &lt;= n;i++) v[i] = read(); for(int i = 2;i &lt;= n;i++) add(read(), i); dfs(1); long long ans = 0; for(int i = 1;i &lt;= n;i++) ans += 1ll * va[i]; printf(&quot;%lld&quot;, ans); }","link":"/2020/08/18/01-Trie/"},{"title":"2-SAT问题","text":"众所周知，2-SAT即二元适配性问题，用于解决一类布尔方程的求值问题…… 有 $n$ 个布尔变量 $x_1, x_2, …,x_n$，给定 $m$ 对冲突关系，形如 $x_i\\And x_j=0$，问一组可行解。$n\\le 10^5, m\\le 10^6$ 拆点建图，对每个变量 $x_i$ 拆成两个点 $i$ 和 $i’$，前者表示“$x_i$ 为真”，后者表示“$x_i$ 为假”。则可以将冲突关系 $(x_i,x_j)$ 转化为偏序关系 $(i,j’)$ 和 $(j,i’)$，依此得到一张有向图，然后就可以按照处理偏序关系的思路去做了。 容易发现，对于一个偏序环上的点，如果取一个值为真，那么剩下的点取值也必然为真；于是可以得到解的存在性定理：该布尔方程有解当且仅当 $\\forall i$，$i$ 和 $i’$ 不在同一个偏序环上。 如何求出一组可行解呢？贪心地想，对于 $i$ 和 $i’$，我们应该选择在新图中拓扑序大的那个将其设为真，因为这样可以最小化影响。注意到 tarjan 求出的 SCC 的编号即为新图拓扑序的反序，因此直接判断即可。 一道栗题 有 $n$ 个布尔变量 $x_1\\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true / false 或 $x_j$ 为 true / false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。试给每个变量赋值使得所有条件得到满足，无解输出 IMPOSSIBLE。$n, m\\le 10^6$ 容易发现一共有三种本质不同的条件形式： $x_i=0|x_j=1$，等价于 $x_i\\And \\neg x_j=0$，连边 $(i,j),(j’,i’)$； $x_i=0|x_j=0$，等价于 $x_i\\And x_j=0$，连边 $(i,j’),(j,i’)$； $x_i=1|x_j=1$，等价于 $\\neg x_i\\And \\neg x_j=0$，连边 $(i’,j),(j’,i)$。 然后套用上面的做法就好了，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 4e6 + 6;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]),hd[x] = ecnt;}int n, m, du[CN];int dfn[CN], low[CN], idx = 0, stk[CN], top = 0, bel[CN], bcnt = 0; bool ins[CN];void dfs(int u){ dfn[u] = low[u] = ++idx, stk[++top] = u, ins[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]) dfs(v), low[u] = min(low[u], low[v]); else if(ins[v]) low[u] = min(low[u], low[v]); } if(low[u] == dfn[u]){ bcnt++; int pos = 0; while(pos ^ u) pos = stk[top--], ins[pos] = false, bel[pos] = bcnt; }}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(); while(m--){ int i = read(), a = read(), j = read(), b = read(); if(a ^ b){ if(a &gt; b) swap(i, j), swap(a, b); add(i, j), add(j + n, i + n); } else{ if(!a) add(i, j + n), add(j, i + n); else add(i + n, j), add(j + n, i); } } for(int i = 1; i &lt;= (n &lt;&lt; 1); i++) if(!dfn[i]) dfs(i); bool flag = true; for(int i = 1; i &lt;= n &amp;&amp; flag; i++) flag &amp;= (bel[i] != bel[i + n]); if(!flag) puts(&quot;IMPOSSIBLE&quot;); else{ puts(&quot;POSSIBLE&quot;); for(int i = 1; i &lt;= n; i++) if(bel[i] &lt; bel[i + n]) printf(&quot;1 &quot;); else printf(&quot;0 &quot;); }}","link":"/2020/09/03/2-SAT%E9%97%AE%E9%A2%98/"},{"title":"A*与IDA*算法","text":"只要启发函数写得好，IDA*能当DP跑…… 注：上面那句话是假的。IDA*再快也跑不过DP的。 一 启发式搜索启发式搜索（Heuristically Search），顾名思义，它不像朴素DFS或BFS那样“盲目地”搜索（或称枚举所有状态），而是“有目的地”进行搜索。它通过启发函数$f(x)$来对每个状态（State）$x$进行估价，进而确定搜索的优先级。这样做的好处是能避免在一些与目的状态毫不相关的状态上浪费过多时间，但是难点也就在于启发函数的设计上。 二 A*算法1 引入A*（A-star）算法是一种启发式搜索算法，也称A*寻路算法。该算法的启发函数定义为$f(x)=g(x)+h(x)$。其中$g(x)$为距离函数，定义为从初始状态转移到当前状态所消耗的代价；$h(x)$为估价函数，定义为从当前状态转移到目标状态的理想代价。 A*算法每次从若干状态$x_1,x_2,…,x_n$中挑选一个$f(x)$值最小的状态进行转移，这也是它“启发式搜索”的根源。设$h’(x)$为从当前状态$x$转移到目标状态的实际代价，若有$\\forall x,h(x)\\leqslant h’(x)$，则A*算法可以找到代价最小的转移方法。当$h()$函数满足三角形不等式时，A*算法不会将重复遍历节点。 2 优势我们看这样一道题： 「LG-T35414」又梦回 如下图，有一个n*m的矩阵。您站在绿色点上，想要去到橙色点。您每次只能上下左右移动一个方格，且不能移动到黑色的方格上。请求出最小移动步数。 此题显然可以用BFS解。但是我们来看一下朴素BFS算法的搜索范围（深蓝色）。 不难发现，从绿色节点向左走的部分都是在做无用功，因为这永远不是最优。而启发式搜索A*就能避免遍历这些节点。 定义$h(x)$为当前节点$x$到目标节点的曼哈顿距离，因为这是理想状态下当前节点到终点所需要走的步数。定义$g(x)$为从起点走到当前节点$x$的步数。设$f(x)=g(x)+h(x)$为节点$x$的启发函数。 该算法的流程如下： 将初始节点加入队列： 1. 在队列中找到f(x)值最小的节点； 2. 遍历该节点四个方向上的节点，判断是(T)否(F)已经访问(最优性剪枝)；若F，则计算它们的启发函数，并将节点放入队列； 3. repeat 1. 直到到达目标节点； 那么答案就是目标节点的$g()$值。看起来是不是非常像BFS？其实可以把它看成改进版的BFS（Improved BFS,IMBFS）。 我们来看一下这种算法的搜索范围： 比BFS高到不知道哪里去了！但是！实际上，A*的应用范围非常有限。与之相比，下面讲的要IDA*更为实用。 3 代码上题的求解代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int CN=3010;const int dx[4]={0,0,1,-1}; //方位数组const int dy[4]={1,-1,0,0};class locat{ //坐标 public: int x,y; bool exm(int n,int m){ return (x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m); }};//v deifneint n,m,p;bool vis[CN][CN]; //标记位int abs(int a) {return a&gt;0 ? a:-a;}//A*int dist(locat a,locat b){ //返回曼哈顿距离 return abs(a.x-b.x)+abs(a.y-b.y);}class state{ //每个状态（节点） public: int g,h; //距离函数和估价函数 locat pos; //坐标 bool operator &lt; (const state &amp;a)const {return g+h &gt; a.g+a.h;} //为了用priority_queue}cur,fin; //当前状态和最终状态priority_queue&lt;state&gt; Q;int A_star(){ cur.h = dist(cur.pos, fin.pos); //计算估价 Q.push(cur); while(!Q.empty()){ cur = Q.top(); //取最小 Q.pop(); if(vis[cur.pos.x][cur.pos.y]) continue; vis[cur.pos.x][cur.pos.y] = true; if(!dist(cur.pos,fin.pos)) break; //到达终点 for(int k=0;k&lt;4;k++){ state nxt; //计算下一个状态 nxt.pos.x = cur.pos.x+dx[k]; nxt.pos.y = cur.pos.y+dy[k]; nxt.g = cur.g+1; //步数+1 nxt.h = dist(nxt.pos,fin.pos); //重新计算估价 if(nxt.pos.exm(n,m) &amp;&amp; !vis[nxt.pos.x][nxt.pos.y]) //最优性剪枝 Q.push(nxt); } } return cur.g;}int main(){ ... //scan A_star(); ... //print return 0;} 该代码的提交记录；朴素BFS的提交记录。 三 IDA*算法1 思想顾名思义，IDA*算法就是用迭代加深搜索（IDDFS）实现的A*算法。该算法更不容易被卡TLE，且空间消耗少，应用范围比A*更广。 实际上，IDDFS与IDA*算法的区别仅在于启发函数的有无。 2 例题 「LG-P1389」八数码难题 在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。目标布局如下： 1 2 38 0 47 6 5 解题思路分析数字的移动：可以看作数字与0调换位置。所以我们找到0的位置并进行搜索即可。 定义估价函数$h(x)$为“当前状态$x$与目标状态相比，不匹配的数字个数”。设当前深度为$d$，则启发函数$f(x) = d + h(x) -1$（有$i$个数字不匹配，最少需要$i-1$步使其全部匹配）。设深度限制为$mxd$，则当$f(x) &gt; mxd$时应剪枝。 最优性剪枝：走过的状态再走一遍肯定不优，故需要判断下一个状态是不是当前状态的上层状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* IDA* */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int dx[4] = {1,-1,0,0};const int dy[4] = {0,0,1,-1};class locat{ //坐标 public: int x,y; void init(int xx,int yy) {x=xx; y=yy;} bool exm() {return (x&lt;=3&amp;&amp;x&gt;=1&amp;&amp;y&lt;=3&amp;&amp;y&gt;=1);} //判断是否在棋盘内 bool operator !=(const locat &amp;a)const {return (a.x!=x||a.y!=y);} //判断坐标是否相同};//v defineint cur[4][4],fin[4][4],ans=0; //cur[][]: 当前状态 ; fin[][]: 最终状态locat find_loc(int v){ //找值为v的元素的坐标 for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) if(cur[i][j] == v) return (locat){i,j}; return (locat){0,0};}//IDDFSint mxd=1; //深度限制int h(){ //估价函数 int incor=0; //incorrect for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) if(cur[i][j] != fin[i][j]) incor++; return incor;}bool dfs(int d,locat u,locat prv){ if(d == mxd) return !h(); //到达深度限制，检查是否是最终状态 if(d+h()-1 &gt; mxd) return false; //A*剪枝 for(int k=0;k&lt;4;k++){ locat v; v.init(u.x+dx[k],u.y+dy[k]); //计算下一个0的位置 if(v.exm() &amp;&amp; prv!=v){ //最优性剪枝 swap(cur[v.x][v.y], cur[u.x][u.y]); //调换 if(dfs(d+1,v,u)) return true; //到达最终状态，继续返回true swap(cur[v.x][v.y], cur[u.x][u.y]); //回溯 } } return false; //未到达最终状态}int main(){ fin[1][1] = 1; fin[1][2] = 2; fin[1][3] = 3; fin[2][1] = 8; fin[2][2] = 0; fin[2][3] = 4; fin[3][1] = 7; fin[3][2] = 6; fin[3][3] = 5; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++){ char c; cin&gt;&gt;c; cur[i][j] = c-'0'; } if(h()){ while(!dfs(0,find_loc(0),(locat){0,0})) //迭代加深 mxd++; printf(&quot;%d&quot;,mxd); //输出深度限制 } else printf(&quot;0&quot;); return 0;}","link":"/2019/06/26/A-star%E4%B8%8EIDA-star%E7%AE%97%E6%B3%95/"},{"title":"Border的四种求法","text":"“我问你，border 有四种求法*，你知道么？” *Border 的四种求法：指毛估，哈希，KMP 和 runs，其中最后一种求法极其罕见。 Peroid &amp; Border （Border）我们定义串 $s$ 的一个非空严格前缀 $s[:k]$ 是 $s$ 的 border，当且仅当 $s[:k]=s[|s|-k+1:]$。注意这里 $k\\in[1,|s|)$。 Border 具有一个优良的性质：$s$ 的一个前缀在 $s$ 中的全部出现位置，即是其在 $s$ 的失配树上的子树中的所有节点。而实际上，失配树上一个节点的祖先，即是这个节点的最长 border 所代指的前缀。 这样我们可以利用这个性质解决一系列单模式匹配问题，唯一的需求是快速建立失配树的结构。 这可以用 KMP 算法来解决：维护当前匹配的最长 border $p$，考虑扩展出一个字符 $c$ 之后，只需要验证 $p$ 到根的这一段路径上，有没有一个节点的下一个字符是 $c$。我们暴力跳失配树，容易发现每条树边只会被经过 $O(1)$ 次，因此总复杂度是均摊 $O(n)$。 注意这里的 border 针对的是同一个串而言，当然我们也可以在不同串之间定义 border，这就出现了 AC 自动机（多模式匹配）和 KMP 自动机（可回撤匹配）等一系列结构。 Border 在扩展 KMP 算法中还体现了另一个应用，因为不是特别有启发性所以这里跳过。 （周期）我们定义一个整数 $r\\in [1,|s|]$ 是串 $s$ 的周期，当且仅当 $\\forall i\\in[1,|s|-r]$，满足 $s[i]=s[i+r]$。我们称一个串所有周期中最小的那个为 $s$ 的最小周期，记作 $per(s)$。 接下来证明一个结论：“$s[:k]$ 是 $s$ 的 border”等价于“$|s|-k$ 是 $s$ 的周期”。 考虑先证充分性，可以发现 $2k\\le |s|$ 的情况是 trivial 的。我们考虑 $2k &gt; |s|$，此时设 $s=XA$，其中 $|A|=k$ 是 $s$ 的 border，可以发现 $X$ 必然是 $A$ 的严格前缀，那么去掉 $X$ 之后，可以转化为同样的问题，最后只会剩下 $X$ 的一段前缀。于是充分性得证，不难发现必要性也同理。 这意味着，一个串的所有周期和它的所有 border 是等价的集合。 关于周期，我们知道一些重要的结论： （Weak Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q\\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。 （Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q-(p,q)\\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。 这意味这周期的出现是极其规律的。或者换个角度讲，border 的出现也是非常规律的！ 可以发现如下规律： 对于串 $a,b$，满足 $2|a|\\ge b$，则 $a$ 在 $b$ 中的匹配位置构成一个公差为 $per(a)$ 的等差数列。 对于串 $s$，$s$ 的所有长度大于等于 $\\frac{|s|}{2}$ 的 border 构成一个等差数列。 对于串 $s$，$s$ 的所有 border 排序后形成 $\\log |s|$ 段等差数列。 对于第一和第二个结论，可以通过 WPL 简单证明；而第三个结论只需再利用 “border 的 border 还是 border”这个性质即可证明。 Runs &amp; Lyndon Factorize我们考虑从另一个角度理解周期，引入 runs 的概念： （Runs）我们定义一个三元组 $(l,r,p)$ 是 $s$ 的一个 run，当且仅当 $per(s[l:r])=p$，且 $2p\\le r-l+1$，且 $s[l:r]$ 是极长的一段最小周期为 $p$ 的串。特别的，实数 $\\frac{r-l+1}{p}$ 称作一个 run 的指数。 可以发现这个东西和周期联系密切，它的本质即是对极长严格周期串（即满足 $2per(s)\\le |s|$）按照它们的最小周期分类。 （The Runs Theorem）记 $\\rho(n)$ 表示长为 $n$ 的串至多含有的 run 的数量，$\\sigma(n)$ 表示长为 $n$ 的串所有 run 的指数和的最大值，那么有 $\\rho(n)&lt;n,\\sigma(n)\\le 3n-3$。 这意味着我们可以求出一个串的所有 run，考虑怎么求。 （Lyndon 串）设 $&lt;_\\iota$ 是比较运算符，其中 $\\iota=0/1$，分别对应两种相反的比较，这里令 $&lt;_0\\Leftrightarrow&lt;,&lt;_1\\Leftrightarrow &gt;$。我们称 $s$ 是关于 $&lt;_\\iota$ 的 Lyndon 串，当且仅当 $\\forall i\\in [2,|s|]$，满足 $s&lt;_\\iota s[i:|s|]$。 （Lyndon 分解）称 $a_1a_2…a_n=s$ 是 $s$ 关于 $&lt;_\\iota$ 的 Lyndon 分解，当且仅当所有 $a_i$ 均是关于 $&lt;_\\iota$ 的 Lyndon 串，且 $a_i\\not&lt;_\\iota a_{i+1}$。可以证明，一个串的 Lyndon 分解存在且唯一。 （Lyndon Root）称 $\\lambda=s[l_\\lambda:r_\\lambda]$ 是一个 run $u=(l,r,p)$ 关于 $&lt;_\\iota$ 的 Lyndon Root，当且仅当 $[l_\\lambda:r_\\lambda]\\subseteq [l,r]$，且 $\\lambda$ 是一个 Lyndon 串。 考虑反过来求每个 Lyndon Root。 我们把串 Lyndon 分解，然后枚举一个 $i$，设 $ed[i]$ 是这一段 Lyndon 分解的边界，那么以 $i$ 开头的 Lyndon 子串的右端点不会超过 $ed[i]$，一段 Lyndon Root 也必然是 $s[i:ed[i]]$ 的子串。 我们从这里开始，二分哈希找到包含 $s[i:ed[i]]$ 的极长循环子串 $s[l:r]$。如果这段子串合法（满足 runs 的定义），那么就找到了一个 run。显然一个 $s[l:r]$ 可能被统计多次，我们应当取周期最小的那一次。 如果对 $\\iota=0/1$ 均做一遍这样的操作，我们就可以得到所有的 run。 我们发现依赖 runs 具有的优良性质，可以解决一系列周期相关的问题以及 border 相关的问题。这种方法比 SAM 等常见处理办法更加简洁，在时间和空间上可以获得进一步的优化。 但是这也是有局限的，因为 runs 无法表出非严格周期串，否则复杂度就错了。 一道栗题 给定一个仅包含小写拉丁字母的字符串 $s$。有 $q$ 次询问，每次询问形如 $(l,r)$，表示询问 $s[l:r]$ 这一段子串是否可以被表示成 $s[l:r]=X^kX’$ 的形式，其中 $X$ 是任意字符串，$X’$ 是 $X$ 的可空前缀，$k\\ge 2$。 对于每次询问，如果这样的 $X$ 存在，输出最短的 $X$ 的长度；否则，输出 $-1$。 全部数据满足 $|s|,q\\le 10^6$，TL = 2s(-O2) / ML = 128Mb。 显然求 $per(s[l:r])$ 等价于求 $s[l:r]$ 的最长 border，直接 KMP 即可 $O(q|s|)$。 求出 $s$ 的 runs，那么每次询问相当于矩形取 $\\min$，直接离线二维数点即可，复杂度 $O((|s|+q)\\log |s|)$。 需要特别说明的是，如果没有 $k\\ge 2$ 的限制，那么本题相当于「BJWC2018」Border 的四种求法，解法也不再这样简单。 参考 《The Runs Theorem and Lyndon Tree》杨骏昭、徐翊轩、陈孙立，WC2019 讲稿 相关题目： 暂无来源","link":"/2021/03/10/Border%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B1%82%E6%B3%95/"},{"title":"CSP2019 退役记","text":"没有摘要可以提供，因为摘要自闭去了…… d014:00p.m.+ arrived.然后颓了约 1h+ ，出去买了一瓶钟水回来切题。考前想练练码力，于是去做NOIP2017d1t2 时间复杂度，结果交了五遍才过…… 然后因为想用vscode编译，去搞环境变量，终于没出错，于是很满足的去恰饭…… 7:40p.m.+ 去试机，发现电脑并没有什么问题。试了试gdb也活着，然后大约还剩20min左右吧，就去打树剖的板子。结果等到试机结束，只剩下读入没写完….于是放弃。 回宿舍，想起来钟水喝完了，于是又去买了一瓶（total : 2）。宿舍里凳子不够，只好上床上肝题，一直肝到宿管都走了才睡觉，大约11:10p.m. d16:20a.m. get up.然后又睡了15min 7:30a.m. 去考场，在门口等了将近30min才进去。 8:30a.m. 准时开题。看了看t1觉得做法显然，然后去看t2，发现链的分数居然这么多。。。遂在草纸上写下：t2 链 O(n^2) 30pts + O(n) 25pts；暴力 O(n^2) 20 pts。觉得如果都能拿到也很可观。 去看t3，发现又是一道树上问题。。看来出题人是真的互相不知情。。。发现 25pts 是链，25pts 是菊花图，然后暴力分只有 10pts 。。。按照去年的经验，这种题特殊情况应该比较好想，所以觉得这题期望60pts。 然后去开t1，发现貌似会爆精度。不过不要紧，我可以特判啊，于是写了个类似于高精读入然后再转低精的东西，20min码完20min调完，时间用的貌似有点多。 开t2，发现并不会线性的做法。。。只会O(n^2)大力递推，然后想可能能用数据结构优化到O(nlogn)级别，不过没有思路。发现链的做法和树没有什么本质的区别，于是感觉要有25pts拿不到了。 开t3，发现两个特殊情况一个也不显然（真香）。。没救了，觉得可能t2更可做一点，于是打完10pts暴力去肝t2。 然而只剩下50min-。再看t2依然没有更优秀的想法，于是果断放弃去检查t1。发现t1写的处处是锅。。。然后发现貌似并不会爆精度，于是直接开unsigned long long大力搞。结果一些小细节一直在出锅，一直搞到11:55a.m.。 期间去看t2和t3，觉得我的t3绝不可能写挂，于是重点看t2有没有被卡精度，并没有发现明显的锅。 然后就这样了，最后看了看文件也没有出锅，就到12:00了。期望：100+50+10=160，考满也才到大众分。。。不过突然很怂t1写锅。 下午又去买钟水（total: 3）。 5:04p.m. t1过民间数据，看来思路没锅。不过最后5min改代码还是怂。。恰完晚饭又开始怂t2写锅。。 6:33p.m. t2自测居然80pts。。一定是数据太水。 d26:50a.m. get up.然后并不想恰早饭，喝了两碗粥散伙。 7:40a.m. 就憨憨的去了考场，然后等了半个小时。。。 8:25a.m. 拿到题目。t1居然是emiya。。emiya你为何如此nb。。然后发现我并不能把这个题看透，越看越像背包，但是并没有显然的想法，写了30min发现写不出来，于是去看t2。 开t2，一眼不可做。看数据更觉得这题绝不可做，直接考虑暴力，复杂度大概 O(玄学) ？看不透到底是有12pts还是24pts，于是告辞去看t3。 开t3，又是树。。ccf你一年考三道树上问题可还行。。发现暴力有40pts，反手一个O(n^2)大力枚举，单走一个样例，过掉，然后去写t2。 10min码出t2暴力，走前两个样例居然都过了，第三个样例太大肯定过不去，于是自己造了一个n=50的数据，发现跑的还挺快？++24pts。 10:00a.m. 重开t1。我剩两个小时写t1你能秒我？我两个小时t1你能把我秒了？结果活活推了1h毫无想法。只好去写暴力，测到第三个样例就炸掉了，估计只有32pts。 还剩大约40min，去看t3发现链的情况可做，因为链上的重心显然可以O(1)算出来。然后20min调试好代码，造了几个数据对拍都过掉了，于是觉得大概不会有什么锅，心想++15pts。 最后15min把三个源程序都重新看了一遍，没看出什么锅来，然后就告辞了。 回去的路上又去买了一瓶钟水（total : 4）。可能是退役之前的最后一瓶钟水了。。。 后来发现我t3链的情况写锅了。。。(Pi,Pi+1)活活看成(i,i+1)，当时还觉得没问题。。。于是成功–15pts。 估分：32+24+40=96，两天100+80+10+32+24+40=286封顶，预测会被锅到250~260左右，成功AFO。 然后回来的时候听说全国划线。。。目测省四稳了。 然后就没然后了。。技不如人，肝败下风。 退役了，虽然好像还有很多事没去完成。 cf一直想上蓝，结果直到最后都在Specialist的底部徘徊。。洛谷红了快两年了吧，停课之后打了几场月赛，排名居然升到了rk264，不过马上也就要掉下去了。。顺带一说昨天恰好499AC，差一道就到500题了。本来想在退役之前把差的题目刷上去，可惜觉得找不到适合充当这最后一道题目的题。。那就不刷了吧，有时候不完美也是一种完美。 2017.9~2019.11 Away From OI，虽然打的很菜，但至少我来过。 Upd on 2019.11.20 几天没上洛谷居然又上分了，rk181，xswl。Upd on 2019.11.25 洛谷居然又上分了……rk168… Upd on 2019.12.17 迟到好久的最终更新 最后 t2 的大力DP终究还是没能活下来，然后成功地100+50+10+32+24+40=256，省rk110+，原地升天爆炸退役。 然后就这样吧。因为太菜，所以只能选择退役。","link":"/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/"},{"title":"KMP学习笔记","text":"众所周知，对于一般的字符串题，存在如下规律：字符串算法 &lt; hash &lt; 暴力，其中 “&lt;” 代表“劣于”。 kmp 被用来解决下面的这样一个问题： 给定两个字符串 $S,T$ ，求 $S$ 在 $T$ 中匹配的数量和位置。$|T|,|S|\\le 10^6$ 直接 hash 和 kmp 都是 $O(|S|+|T|)$ 的复杂度，但是 kmp 的思想还是要理解的。kmp 的思想基于下面这两个东西。 border一个 border 定义为字符串的一段前缀，使其等于本串的一段后缀。用符号表示的话就是找到一个 $k$，使得 $s[1:k]=s[n-k+1:n]$。容易发现我们可以用这个 $k$ 去双射一个 border。众所周知，border 具有一个非常优美的性质，即你的 border 的 border 还是你的 border。 next[] 数组定义 $nxt[i]=md(s[1:i])$ 是串 $s$ 的 $nxt[]$ 数组，其中 $md(x)$ 代表串 $x$ 的最长 border 长度（不能是自身）。容易发现 $nxt[i], nxt[nxt[i]],…$ 构成了串 $s[1:i]$ 的所有 border。 kmp 每次确定一个最大的 $k$，使得 $S[1:k] = T[i - k + 1:i]$，然后尝试扩展 $k\\to k+1$，如果 $k=|S|$ 则发现了匹配位置。容易发现，这个尝试扩展的过程可以通过 border 来加速，即若 $S[k+1]\\neq T[i+1]$，则令 $k=nxt[k]$ 即可。 代码： 12345678910111213141516const int CN = 1e6 + 6;int n, m, nxt[CN]; char s[CN], t[CN];cin &gt;&gt; (t + 1) &gt;&gt; (s + 1); n = strlen(t + 1), m = strlen(s + 1);int k = 0; nxt[1] = 0, nxt[0] = -1; // k : 当前的最长 borderfor(int i = 2; i &lt;= m; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; // 去找次长 border nxt[i] = (k += 1); // 往下匹配一位}k = 0;for(int i = 1; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != t[i]) k = nxt[k]; // 同理 if((k += 1) == m) printf(&quot;%d&quot;, i - m + 1), puts(&quot;&quot;); // 已经匹配上} 一道栗题 给定字符串 $S$，求 $S$ 的所有前缀的不重叠的 border 数量。$|S|\\le 5\\times 10^7$ 直接在 kmp 上维护即可，注意一下 kmp 想要保证复杂度则必须避免反复横跳。时间复杂度 $O(n)$。 代码： 1234567891011121314151617181920const int CN = 1e7 + 7;const int P = 1e9 + 7;int t, n, nxt[CN], num[CN]; char s[CN];scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); int k = 0; nxt[0] = -1, nxt[1] = 0, num[1] = 1;for(int i = 2; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; k += 1, nxt[i] = k, num[i] = num[k] + 1;} int ans = 1; k = 0;for(int i = 2; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; while(k &gt; i / 2) k = nxt[k]; // 跑过了就挪回去 ans = 1ll * ans * (num[k] + 1) % P;}printf(&quot;%d&quot;, ans), puts(&quot;&quot;); 在字典树上的扩展考虑这样一个问题： 给定一个字符串 $T$，和一些字符串 $S_1,S_2,…S_n$，对每个 $S_i$ 求其在 $T$ 中匹配的数量。$|T|,\\sum|S_i|\\le 10^6$ 解决方法是对 $S_i$ 建立字典树，然后再在字典树上建立类似于 $nxt[]$ 指针的结构。注意到这种方法具有可扩展性，即广义后缀自动机也通过类似的思想构建。 于是这棵字典树变成了一个确定有限状态自动机（DFA），我们称其为 AC自动机（Aho-Corasick Automaton, ACAM）。 则可以得到这样一份构建代码： 123456789101112131415161718192021222324252627282930const int CN = 1e6 + 6;class ACAM { public: int son[CN][26], fail[CN], e[CN], idx; queue&lt;int&gt; Q; void ins(char *s){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } e[u]++; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push( son[0][i] ); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; } } int qu(char *s){ int u = 0, r = 0; for(int i = 0; s[i]; i++){ u = son[u][ s[i] - 'a' ]; for(int j = u; j &amp;&amp; e[j] ^ -1; j = fail[j]) r += e[j], e[j] = -1; } return r; }} D; 又一道栗题 给定一个字符串 $T$ 和一些字符串 $S_1,S_2,…S_n$，定义一个字符串是可爱的当且仅当它不包含任何 $S_i$ 作为子串。试删除最少的字符使得 $T$ 变得可爱。$|T|,\\sum|S_i|\\le 5000$ 考虑 DP，设 $f[l,u]$ 为考虑 $S[1:l]$，在AC自动机上走到了节点 $u$ 的最小代价。考虑 $S[l+1]$ 是否删除，则有转移：$$\\begin{aligned} &amp;f[l,u]+1\\to f[l + 1, u]\\newline &amp;f[l,u]\\to f[l+1,v] \\text{ }|\\text{ }son[u, S[l + 1]] = v\\end{aligned}$$ $v$ 点应当满足怎样的限制呢？首先它不应该是接受状态，并且 fail 树上它到根的路径上也不能存在接受状态，因为这些状态是后缀等价的。那么按照 bfs 序更新一下即可，时间复杂度 $O(|T|\\sum |S_i|)$。 代码： 1234567891011121314151617181920212223242526272829303132333435const int CN = 2020;class ACAM { public: int son[CN][26], fail[CN], w[CN], idx; queue&lt;int&gt; Q; void ins(char *s){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } w[u]++; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(son[0][i]); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; w[u] += w[ fail[u] ]; // mark } } int f[CN][CN]; int solve(char *s, int n){ memset(f, 0x3f, sizeof(f)), f[0][0] = 0; for(int l = 0; l &lt; n; l++) for(int i = 0; i &lt;= idx; i++){ f[l + 1][i] = min(f[l + 1][i], f[l][i] + 1); int v = son[i][ s[l] - 'a' ]; if(!w[v]) f[l + 1][v] = min(f[l + 1][v], f[l][i]); } int ans = 0x3f3f3f3f; for(int i = 0; i &lt;= idx; i++) ans = min(ans, f[n][i]); return ans; }} D; 双一道栗题 给定一些字符串 $S_1,S_2,…S_n$ 和字符集 $\\Sigma$，每个字符串 $S_i$ 有一个价值 $w_i$。定义一个字符串的价值为其所有子串的价值和（未定义则为 $0$），求一个长度为 $l$ 的串使得其价值最大。$|\\Sigma|\\le 26 ,\\sum|S_i|,l\\le 1000$ 考虑 DP，假设当前的字符串为 $s$，新增了一个字符 $c$ 得到 $sc$，则新增的子串应当是 $sc$ 的所有后缀，新增字符的价值为这些后缀的价值和。对 $S_i$ 建立AC自动机，则“这些后缀的价值和”体现为 fail 树上从根到 $sc$ 所在的节点的权值和，我们记其为 $w[u]$。 于是就可以 DP 了，设 $f[l,u]$ 表示当前拼出的串长度为 $l$，现在在AC自动机上的节点 $u$ 的最大价值，有转移：$$ f[l,u]+w[v]\\to f[l+1,v]\\text{ }|\\text{ }\\exists c, \\text{s.t.} son[u, c]=v$$ 时间复杂度 $O(l\\sum|S_i||\\Sigma|)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243const int CN = 2020;template &lt; class T &gt;class queue { // 惨痛经历 public: T a[CN], hd, tl; queue() {hd = tl = 0;} bool empty() {return hd ^ tl ? 0 : 1;} T front() {return a[hd];} void pop() {hd++;} void push(int x) {a[tl++] = x;}} ;class ACAM { public: int w[CN], son[CN][26], fail[CN], idx; queue&lt;int&gt; Q; void ins(char *s, int val){ int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][ s[i] - 'a' ]) son[u][ s[i] - 'a' ] = ++idx; u = son[u][ s[i] - 'a' ]; } w[u] += val; } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(son[0][i]); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++) if(son[u][i]) fail[ son[u][i] ] = son[ fail[u] ][i], Q.push(son[u][i]); else son[u][i] = son[ fail[u] ][i]; w[u] += w[ fail[u] ]; // mark } } int f[CN][CN]; int solve(int l){ memset(f, -0x3f, sizeof(f)), f[0][0] = 0; for(int i = 0; i &lt; l; i++) for(int u = 0; u &lt;= idx; u++) for(int c = 0; c &lt; 26; c++) f[i + 1][ son[u][c] ] = max(f[i + 1][ son[u][c] ], f[i][u] + w[ son[u][c] ]); int ans = -0x3f3f3f3f; for(int u = 0; u &lt;= idx; u++) ans = max(ans, f[l][u]); return ans; }} D; 相关题目 「NOI2014」动物园 暂无来源 暂无来源 暂无来源","link":"/2020/08/31/KMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Splay","text":"没有摘要可以提供，因为摘要还在rotate…… 此页面存在相关页面。关于使用vector替代平衡树，请参见「利用vector重现set」。 Splay - OI Wiki.pdfLGp3316 普通平衡树 模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}class Splay{ public: int ch[CN][2],fa[CN],val[CN],sz[CN],cnt[CN],tot,rt; Splay() {memset(ch, 0, sizeof(ch)); memset(fa, 0, sizeof(fa)); tot = rt = 0;} #define lc ch[u][0] #define rc ch[u][1] bool get(int u) {return u == ch[ fa[u] ][1];} void maintain(int u) {sz[u] = sz[lc] + sz[rc] + cnt[u];} void clear(int u) {lc = rc = sz[u] = val[u] = fa[u] = cnt[u] = 0;} void make(int f,int k) {int u = ++tot; sz[u] = cnt[u] = 1, val[u] = k, fa[u] = f; if(f) ch[f][val[f] &lt; k] = u;} void rotate(int u){ int f = fa[u], gf = fa[ fa[u] ], chk = get(u); ch[f][chk] = ch[u][chk ^ 1], fa[ ch[u][chk ^ 1] ] = f; ch[u][chk ^ 1] = f, fa[f] = u; fa[u] = gf; if(gf) ch[gf][f == ch[gf][1]] = u; maintain(f), maintain(u); } void splay(int u){ for(int f = fa[u]; f = fa[u]; rotate(u)) if(fa[f]) rotate(get(f) == get(u) ? f : u); rt = u; } void _ins(int u,int f,int k){ if(!u) {make(f, k); rt = tot; maintain(f); return;} if(val[u] == k) {cnt[rt = u]++,sz[u]++; maintain(f); return;} _ins(val[u] &gt; k ? lc : rc, u, k); } void ins(int k) {_ins(rt, 0, k); splay(rt);} // // int _rank(int u,int k) {return val[u] == k ? rt = u, sz[lc] + 1 : (val[u] &gt; k ? _rank(lc, k) : sz[lc] + cnt[u] + _rank(rc, k));} int rank(int k) {int r = _rank(rt, k); splay(rt); return r;} // // int _kth(int u,int k) {return sz[lc] &gt;= k ? _kth(lc, k) : (sz[lc] + cnt[u] &gt;= k ? val[rt = u] : _kth(rc, k - sz[lc] - cnt[u]));} int kth(int k) {int r = _kth(rt, k); splay(rt); return r;} // // int pre() {int u = ch[rt][0]; while(rc) u = rc; return u;} int nxt() {int u = ch[rt][1]; while(lc) u = lc; return u;} void del(int k){ rank(k); int u = rt; if(cnt[u] &gt; 1) {sz[u]--,cnt[u]--; return;} if(!lc &amp;&amp; !rc) {rt = 0, clear(u); return;} if(!lc) {rt = rc, fa[rc] = 0; clear(u); return;} if(!rc) {rt = lc, fa[lc] = 0; clear(u); return;} int x = pre(); splay(x); ch[x][1] = rc,fa[rc] = x; clear(u); maintain(x); }}t;int n;int main(){ n = read(); while(n--){ int tp = read(),x = read(); if(tp == 1) t.ins(x); if(tp == 2) t.del(x); if(tp == 3) printf(&quot;%d&quot;, t.rank(x)); if(tp == 4) printf(&quot;%d&quot;, t.kth(x)); if(tp == 5) t.ins(x), printf(&quot;%d&quot;, t.val[ t.pre() ]), t.del(x); if(tp == 6) t.ins(x), printf(&quot;%d&quot;, t.val[ t.nxt() ]), t.del(x); if(tp &gt; 2) puts(&quot;&quot;); }}","link":"/2020/06/26/Splay/"},{"title":"hexo主题Icarus浅度修改教程","text":"此页面最近更新时间：2019.8.14，其中可能存在过时内容。 难得放假两天（还是因为来台风），结果so又没得颓，实在是闲的没事干，随便写写博吧，说不定还能当备忘录使…… Icarus实在是hexo的一款非常优秀的主题。它具有极高的自由度和兼容性，并且功能也很齐全。不过还是有一些美中不足的地方，其中一部分被我摸索（瞎蒙）着解决了（蒙中了）。 2021.1.6 注：由于 Icarus 3.0 及以上版本的修改，现在侧边栏小部件的相关代码需要到 \\hexo\\node_modules\\hexo-component-inferno\\lib\\view\\widget\\ 这个文件夹下去找，语言也从 EJS 变成了 JS，但是方法还是大同小异的。 侧边栏侧边栏“最新文章”栏这个东西啊，个人感觉真的没什么实用性。可以把它改成类似于优秀文章推广之类的，就比较好了。 打开\\icarus\\layout\\widget\\recent_posts.ejs，找到： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('date', -1).limit(5).each(post =&gt; { %&gt; 一行，改成： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('priority', -1).limit(5).each(post =&gt; { %&gt; 然后只需要在每篇文章上面的配置里加上priority: xxx，其中xxx是你自由确定的优先级（1,2,3之类的数字），就可以自由更改显示在那里的文章了。当然也可以调整显示在那里的文章数量，像这样： \\icarus\\layout\\widget\\recent_posts.ejs1&lt;% site.posts.sort('priority', -1).limit(10).each(post =&gt; { %&gt; 就是显示10篇文章。10也可以改成其它数字。 然后更改栏目名称。打开\\icarus\\languages\\zh-CN.yml ，找到： \\icarus\\languages\\zh-CN.yml1recents: '最新文章' 一句，把“最新文章”替换成“阅读推荐”就好了。 侧边栏“目录”栏自动编号目录本人一般会手动编号，所以这个自动编号功能对我来说并不友好。所以加个开关好了。 打开\\icarus\\layout\\widget\\toc.ejs，把整个文件复制一遍然后粘贴到最后面。然后会有两行像这样的语句： \\icarus\\layout\\widget\\toc.ejs1&lt;% if (get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 把第一句改成： \\icarus\\layout\\widget\\toc.ejs1&lt;% if (get_config('toc_auto_num') === false &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 第二句改成： \\icarus\\layout\\widget\\toc.ejs1&lt;% if ((get_config('toc_auto_num') === true || !has_config('toc_auto_num')) &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 然后找到第一个if语段中如下的位置： \\icarus\\layout\\widget\\toc.ejs1&lt;span class=&quot;has-mr-6&quot;&gt;${toc.index}&lt;/span&gt; 把它注释掉： \\icarus\\layout\\widget\\toc.ejs1&lt;!--span class=&quot;has-mr-6&quot;&gt;${toc.index}&lt;/span--&gt; 然后就可以通过文章前面的toc_auto_num: true/false来控制是不是开启自动编号。 侧边栏“资料”栏关注按钮这个东西对我来说也没什么用处。把它链接到关于页面之后，在\\icarus\\languages\\zh-CN.yml 里，找到： \\icarus\\languages\\zh-CN.yml1follow: '关注' 一句，改成： \\icarus\\languages\\zh-CN.yml1follow: '关于' 然后更改页面打开方式为同一页面跳转，具体做法是打开\\icarus\\layout\\widget\\profile.ejs，找到： \\icarus\\layout\\widget\\profile.ejs123&lt;a class=&quot;level-item button is-link is-rounded&quot; href=&quot;&lt;%= url_for(widget.follow_link) %&gt;&quot; target=&quot;_blank&quot;&gt; &lt;%= __('widget.follow') %&gt;&lt;/a&gt; 把target=&quot;_blank&quot;属性删掉就好了。 站底站底备案号及链接这个Icarus貌似并没有预留接口……只能自己写了。 打开\\icarus\\layout\\common\\footer.ejs，找到： \\icarus\\layout\\common\\footer.ejs12345 &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; &lt;%- _p('plugin.visitor', '&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;0&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 一段，在后面添加： \\icarus\\layout\\common\\footer.ejs12&lt;br&gt; &lt;a class=&quot;has-link-black-ter-2 -link&quot; href=&quot;http://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt;省份ICP备xxx号-x&lt;/a&gt; 然后更改样式文件。打开\\icarus\\source\\css\\style.styl，找到这样的两段： \\icarus\\source\\css\\style.styl1234.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl12.has-link-black-ter color: hsl(0, 0%, 14%) !important 把这两段分别扩充成： \\icarus\\source\\css\\style.styl12345678.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important.has-link-black-ter-2 transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl1234.has-link-black-ter color: hsl(0, 0%, 14%) !important .has-link-black-ter-2 color: hsl(0, 0%, 30%) !important 就好了。 站底字数统计这个主题是没有集成的，所以首先安插件： 1$ npm i --save hexo-wordcount 然后打开\\icarus\\layout\\common\\footer.ejs，找到： \\icarus\\layout\\common\\footer.ejs12345 &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; &lt;%- _p('plugin.visitor', '&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;0&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 一段，在后面添加： \\icarus\\layout\\common\\footer.ejs12&lt;br&gt;&lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; Words in Total 当然，如果想和备案号放在一块，可以这样添加： \\icarus\\layout\\common\\footer.ejs123&lt;br&gt;&lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; Words in Total | &lt;a class=&quot;has-link-black-ter-2 -link&quot; href=&quot;http://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt;省份ICP备xxx号-x&lt;/a&gt; 站点推送Sitemap生成这个的方法对与所有hexo博客来说都是一样的吧…装个插件就好了： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 百度自动推送这个貌似并没有什么用处…但是有总比没有好。 需要从baidu上搞到的推送代码，这个代码可能跟下面这份一样或相似： \\icarus\\layout\\common\\scripts.ejs1234567891011121314&lt;script&gt;(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https'){ bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else{ bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);})();&lt;/script&gt; 然后打开\\icarus\\layout\\common\\scripts.ejs，在顶部添加上面的代码就好了。 其他markdown行间代码样式emm，我还真不知道这个叫什么，其实就是abcde这个东西。这个默认的是红色字体，个人感觉不好看。其实可以改。 打开\\icarus\\source\\css\\style.styl，找到： \\icarus\\source\\css\\style.styl1234code color: hsl(348, 100%, 61%) background: transparent padding: 0一段。这段就是控制行间代码样式的。其中`color`控制字体颜色，`background`控制背景颜色，`padding`控制代码块的边距大小。这里提供一种配色方案： \\icarus\\source\\css\\style.styl1234code color: #5E81AC background: #ECEFF4 padding: 0 其实就是本博客现在呈现的行间代码样式。 Sharthis分享插件emm，这个毕竟是国外的东西，在国内不怎么实用。但是它好看啊…想在站底插入这样一个分享按钮，得先注册一个Sharethis账号，然后获得一个javascript代码的url。这个是免费的。 然后主题里大概集成了这个，但是貌似存在BUG导致hexo无法渲染。于是还得自己加。 打开\\icarus\\layout\\common\\article.ejs，找到： \\icarus\\layout\\common\\article.ejs1234567&lt;div class=&quot;level is-mobile&quot;&gt; &lt;div class=&quot;level-start&quot;&gt; &lt;div class=&quot;level-item&quot;&gt; &lt;a class=&quot;button is-size-7 is-light&quot; href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= __('article.more') %&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一段，在下面添加： \\icarus\\layout\\common\\article.ejs1234567891011&lt;% if (!index &amp;&amp; post.path !== &quot;friends.html&quot; &amp;&amp; post.path !== &quot;about\\index.html&quot; &amp;&amp; post.path !== &quot;(你不想添加代码的页面的路径)&quot; (......)) { %&gt; &lt;hr&gt; &lt;h3 class=&quot;menu-label has-text-centered&quot;&gt;(你想要的标题)&lt;/h3&gt; &lt;div class=&quot;sharethis-inline-share-buttons&quot;&gt;&lt;/div&gt; &lt;script type='text/javascript' src='(你的js的url)' async='async'&gt;&lt;/script&gt;&lt;% } %&gt; 隐藏首页文章打开\\icarus\\layout\\index.ejs ，把它改成这样： \\icarus\\layout\\index.ejs12345678&lt;% page.posts.each(function(post){ %&gt; &lt;% if (post.unshown !== true) { %&gt; &lt;%- partial('common/article', { post, index: true }) %&gt; &lt;% } %&gt;&lt;% }); %&gt;&lt;% if (page.total &gt; 1) { %&gt; &lt;%- partial('common/paginator') %&gt;&lt;% } %&gt; 然后通过文章表头的unshown: true/false控制就好了。 在搜索中隐藏文章Icarus的insight搜索基于一个本地生成的content.json。所以只要让页面不出现在这个里面就好了。 打开\\icarus\\includes\\generators\\insight.js，找到这样一段： \\icarus\\includes\\generators\\insight.js1234567function postMapper(post) { return { title: post.title, text: minify(post.content), link: url_for(post.path) }} 在前面加上一段： \\icarus\\includes\\generators\\insight.js12345678910function postMapper(post) { if (url_for(post.path) == &quot;(你想隐藏的页面的路径)&quot;){ return {} } return { title: post.title, text: minify(post.content), link: url_for(post.path) }}","link":"/2019/08/12/hexo%E4%B8%BB%E9%A2%98Icarus%E6%B5%85%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/"},{"title":"min-max容斥学习笔记","text":"众所周知，min-max 容斥简称容斥原理，或称简单容斥，或称二项式反演，是一类可以在 $O(2^n)$ 的时间内求出大小为 $n$ 的集合的元素最小值的优秀算法…… 公式min-max 容斥即是这个柿子： $$\\begin{align} k\\text{-th}\\min S&amp;= \\sum\\limits_{T\\subseteq S, T\\neq \\emptyset} (-1)^{|T|-k}\\dbinom{|T|-1}{k-1} \\max T \\tag 1\\newline k\\text{-th}\\max S&amp;= \\sum\\limits_{T\\subseteq S, T\\neq \\emptyset} (-1)^{|T|-k}\\dbinom{|T|-1}{k-1} \\min T \\tag 2\\end{align}$$ 证明如下。 假设存在一个系数函数 $f(x)$，使得： $$k\\text{-th}\\min S= \\sum\\limits_{T\\subseteq S, T\\neq \\emptyset} f(|T|) \\max T$$ 那么集合中第 $x$ 小值在求和中的系数是 $\\sum\\limits_{i=0}^{x-1} \\dbinom{x-1}{i}f(i+1)$，比较系数得： $$ [n+1=k] = \\sum\\limits_{i=0}^n\\dbinom{n}{i}f(i+1)$$ 二项式反演得： $$\\begin{aligned} f(n+1)&amp;=\\sum\\limits_{i=0}^n(-1)^{n-i}\\dbinom{n}{i}[i+1=k]\\newline &amp;= (-1)^{n+1-k}\\dbinom{n}{k-1}\\end{aligned} $$ 从而有 $f(x)=(-1)^{x-k}\\dbinom{x-1}{k-1}$，它对任意合法的 $k$ 取值均有定义，于是 $(1)$ 式得证。 $(2)$ 式也可以通过类似的方法证明，此处省略。 在 $(1),(2)$ 中取 $k=1$，还可以得到： $$\\begin{align}\\min S&amp;=\\sum\\limits_{T\\subseteq S,T\\neq \\emptyset} (-1)^{|T|-1} \\tag 3\\max T\\newline \\max S&amp;=\\sum\\limits_{T\\subseteq S, T\\neq \\emptyset} (-1)^{|T|-1}\\min T \\tag 4\\end{align}$$ 一道栗题 设数列 $f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2](i&gt;1)$ 是斐波那契数列。给定由若干正整数构成的集合 $S$，试求 $\\text{lcm}_{x\\in S} f[x]$，对 $10^9+7$ 取模。$|S|\\le 50000, x\\le 10^6$ 考虑 $\\text{lcm } a,b=\\prod\\limits_i p_i^{\\max e_i,e’_i}$，其中 $p_i$ 是素数，$e_i$ 和 $e’_i$ 分别是 $a,b$ 标准分解的指数。根据 $(f[a],f[b])=f[(a,b)]$，对指数 min-max 容斥得到： $$\\begin{align} \\text{lcm}_{i\\in S} f[i]&amp;=\\prod\\limits_{T\\subseteq S,T\\neq \\emptyset} \\text{gcd}_{i\\in T}f[i]^{(-1)^{|T|-1}} \\newline &amp;=\\prod\\limits_{T\\subseteq S,T\\neq \\emptyset} f[\\text{gcd}_{i\\in T}i]^{(-1)^{|T|-1}}\\end{align}$$ 设 $f[n]=\\prod\\limits_{d|n} g[d]$，简记 $\\text{gcd}_{i\\in T}i=\\text{gcd}T$，那么有： $$\\begin{align} \\text{lcm}_{i\\in S} f[i]&amp;=\\prod\\limits_{T\\subseteq S,T\\neq \\emptyset}\\prod\\limits_{d|\\text{gcd}T}g[d]^{(-1)^{|T|-1}}\\newline &amp;=\\prod\\limits_dg[d]^{\\sum_{T\\subseteq S,T\\neq\\emptyset}[d|\\text{gcd}T](-1)^{|T|-1}} \\end{align}$$ 设 $t=\\sum\\limits_{x\\in S}[d|x]$，考虑指数那一部分，当 $t=0$ 时它必然为 $0$，否则它可以改写成： $$\\begin{align}\\sum\\limits_{i=1}^t \\dbinom{t}{i}(-1)^{i-1} &amp;=\\dbinom{t}{0}-\\sum\\limits_{i=0}^t (-1)^i\\dbinom{t}{i}\\newline &amp;=1-\\sum\\limits_{i=0}^t\\dbinom{i-t-1}{i}\\newline &amp;=1-\\dbinom{t+1-t-1}{t}=1 \\end{align}$$ 那么 $\\sum\\limits_{i=1}^t\\dbinom{t}{i}(-1)^{i-1}=[t&gt; 0]$，从而答案是 $\\prod\\limits_{\\exists x\\in S,d|x}g[d]$，剩下只需要求出 $g$，由定义： $$\\begin{align} &amp;f[n]=\\prod\\limits_{d|n} g[d]\\newline \\Leftrightarrow \\text{ }&amp; \\ln f[n]=\\sum\\limits_{d|n}\\ln g[d]\\newline \\Leftrightarrow \\text{ }&amp;\\ln g[n]=\\sum\\limits_{d|n}\\mu(n/d)\\ln f[d]\\newline \\Leftrightarrow \\text{ }&amp;g[n]=\\prod\\limits_{d|n}f[d]^{\\mu(n/d)} \\end{align}$$ 即是莫比乌斯反演，那么直接做就是 $O(n(\\ln n+\\log P)+d(n)|S|)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_backconst int CN = 1e6 + 10;const int P = 1e9 + 7;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int mul(int x, int y) {return 1ll * x * y % P;}int qp(int a, int b){ int r = 1; for(; b; a = mul(a, a), b &gt;&gt;= 1) if(b &amp; 1) r = mul(r, a); return r;}int invx(int x) {return qp(x, P - 2);}int n, f[CN], fi[CN], g[CN], p[CN], mu[CN], md[CN], d[20], alp[20], ans = 1;bool np[CN], vis[CN];void sieve(int n){ np[1] = 1, md[1] = 0, mu[1] = 1; for(int i = 2; i &lt;= n; i++){ if(!np[i]) p[++p[0]] = i, md[i] = i, mu[i] = -1; for(int j = 1; i * p[j] &lt;= n &amp;&amp; j &lt;= p[0]; j++){ int x = i * p[j]; np[x] = 1, md[x] = p[j]; if(i % p[j]) mu[x] = -mu[i]; else break; } } f[1] = 1; for(int i = 2; i &lt;= n; i++) f[i] = add(f[i - 1], f[i - 2]); for(int i = 1; i &lt;= n; i++) fi[i] = invx(f[i]); for(int i = 1; i &lt;= n; i++) g[i] = 1; for(int i = 1; i &lt;= n; i++) for(int j = i; j &lt;= n; j += i){ if(!mu[j / i]) continue; g[j] = mul(g[j], mu[j / i] ^ -1 ? f[i] : fi[i]); }}void dfs(int i, int fac){ vis[fac] = 1; if(i &gt; d[0]) return; for(int j = 0, k = 1; j &lt;= alp[i]; k *= d[i], j++) dfs(i + 1, fac * k);}void work(int x){ d[0] = 0; int t = x; for(; md[t]; t /= md[t]) md[t] ^ d[d[0]] ? d[++d[0]] = md[t], alp[d[0]] = 1 : alp[d[0]]++; dfs(1, 1);}int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); sieve(1000000), n = read(); for(int i = 1; i &lt;= n; i++) work(read()); for(int i = 1; i &lt;= 1000000; i++) if(vis[i]) ans = mul(ans, g[i]); printf(&quot;%d\\n&quot;, ans); return 0;} 又一道栗题 刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $x\\in[0,2^n-1]$，与你手上的数字进行按位或操作，其中选择数字 $i$ 的概率是 $p_i$。问期望多少秒后，你手上的数字变成 $2^n-1$。$n\\le 20$ 期望同样可以进行 min-max 容斥，即 $\\max$ 代表满足所有限制的操作步数期望，$\\min$ 表示满足任意限制的操作步数期望。 那么只需要求给出一个数 $T$，满足 $T$ 中任意一位被覆盖到的期望操作次数。 有一个众所周知的结论：如果重复实验直到成功，并且每次实验成功的概率相同，那么试验次数的期望是每次成功的概率的倒数。证明很简单，设 $x$ 是期望次数，$p$ 是成功概率，由 $x=1+(1-p)x$ 可以解得 $x=1/p$。 那么只需要求出一次成功的概率，即是： $$\\sum\\limits_{i\\cup T\\neq \\emptyset}p[i]=1-\\sum\\limits_{i\\subseteq \\complement_T}p[i]$$ 即是高维前缀和，那么直接做就是 $O(n2^n)$。 代码： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define DB doubleconst DB EPS = 1e-10;int n, B; DB p[1 &lt;&lt; 20], e[1 &lt;&lt; 20], ans;int bits(int x) {int r = 0; while(x) r++, x -= x &amp; (-x); return r;}void work(){ for(int j = 0; j &lt; n; j++) for(int i = 0; i &lt;= B; i++) if((i &gt;&gt; j) &amp; 1) p[i] += p[i ^ (1 &lt;&lt; j)]; for(int i = 0; i &lt;= B; i++) e[i] = 1 - p[B ^ i]; for(int i = 1; i &lt;= B; i++){ if(e[i] &lt; EPS) return (void)(puts(&quot;INF&quot;)); e[i] = 1 / e[i]; } for(int i = 1; i &lt;= B; i++) ans += bits(i) &amp; 1 ? e[i] : -e[i]; printf(&quot;%.10lf\\n&quot;, ans);}int main(){ scanf(&quot;%d&quot;, &amp;n), B = (1 &lt;&lt; n) - 1; for(int i = 0; i &lt;= B; i++) scanf(&quot;%lf&quot;, &amp;p[i]); return work(), 0;} 双一道栗题 给定一棵 $n$ 个结点的树，你从点 $x$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。有 $q$ 次询问，每次询问给定一个集合 $S$，求如果从 $x$ 出发一直随机游走，直到点集 $S$ 中所有点都至少经过一次的话，期望游走几步。起点视为一开始就被经过了一次，对 $998244353 $ 取模。$n\\le 18, \\sum|S|\\le 10^7$ min-max 容斥一下，就是求从根出发，到 $T$ 中任意一点的期望步数。设 $f[u]$ 表示从 $u$ 出发的期望步数，显然有： $$ f[u]=1+\\dfrac{1}{deg[u]}(f[fa[u]]+\\sum\\limits_{v:son[u]}f[v]) $$ 特别的，有 $f[u]=0,u\\in S$。接下来就套上树上高消那一套，即设 $f[u]=k[u]f[fa[u]]+b[u]$，有： $$\\begin{align} deg[u]f[u]&amp;=deg[u]+f[fa[u]]+f[u]\\sum\\limits_v{k[v]}+\\sum\\limits_v{b[v]} \\newline \\Leftrightarrow f[u]&amp;=\\dfrac{1}{deg[u]-\\sum k[v]}f[fa[u]]+\\dfrac{deg[u]+\\sum b[v]}{deg[u]-\\sum k[v]}\\end{align}$$ 也就是 $k[u]=\\dfrac{1}{deg[u]-\\sum k[v]},b[u]=\\dfrac{deg[u]+\\sum b[v]}{deg[u]-\\sum k[v]}$，我们只保留 $E(S)=f[x]$ 即可，这部分是 $O(n2^n)$。 考虑答案即是 $\\sum\\limits_{T\\subseteq S} (-1)^{|T|-1}E(T)$，即是高维前缀和，那么直接做就是 $O(n2^n)-O(1)$，因此总复杂度 $O(n2^n+\\sum|S|)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_backconst int P = 998244353;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;} int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int qp(int a, int b){ int r = 1; while(b){ if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P, b &gt;&gt;= 1; } return r;}int invx(int x) {return qp(x, P - 2);}bool in(int x, int y) {return y &amp; (1 &lt;&lt; (x - 1));}int bits(int x) {int r = 0; while(x) r++, x -= x &amp; (-x); return r;}int n, q, rt; vector&lt;int&gt; G[20];int k[20], b[20], f[1 &lt;&lt; 18];void dfs(int u, int p, int S){ if(in(u, S)) return; int deg = G[u].size(), sb = 0, sk = 0, M; for(int i = 0; i &lt; deg; i++){ int v = G[u][i]; if(v == p) continue; dfs(v, u, S), sb = add(sb, b[v]), sk = add(sk, k[v]); } M = add(deg, P - sk), k[u] = invx(M), b[u] = 1ll * k[u] * add(deg, sb) % P;}int cal(int S){ memset(k, 0, sizeof(k)), memset(b, 0, sizeof(b)); return dfs(rt, 0, S), b[rt];}int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), q = read(), rt = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(); G[u].pb(v), G[v].pb(u); } for(int S = 1; S &lt; (1 &lt;&lt; n); S++){ f[S] = cal(S); f[S] = bits(S) &amp; 1 ? f[S] : add(0, P - f[S]); } for(int j = 0; j &lt; n; j++) for(int S = 0; S &lt; (1 &lt;&lt; n); S++) if(S &amp; (1 &lt;&lt; j)) f[S] = add(f[S], f[S ^ (1 &lt;&lt; j)]); while(q--){ int m = read(), u, S = 0; while(m--) u = read() - 1, S |= 1 &lt;&lt; u; printf(&quot;%d\\n&quot;, f[S]); } return 0;} 叒一道栗题 有 $n$ 种原料，每个单位时间会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\\frac{p_i}{m}$，其中 $m=\\sum p_i$。问收集到任意 $k$ 种原料的期望时间，对 $998244353$ 取模。$k\\le n\\le 1000, n-k\\le 10, m\\le 10^4$ 考虑满足任意 $k$ 条限制即是 $k\\text{-th}\\min$，把它转化成 $(n-k+1)\\text{-th}\\max$ 来求就可以仿照上例了。以下认为 $k$ 是 $n-k+1$ 来进行推导。 即是求收集到某个集合中，任意一种原料的期望时间。显然这个概率是 $\\sum\\limits_{i\\in T} \\dfrac{p_i}{m}$，期望是$\\sum\\limits_{i\\in T} \\dfrac{m}{p_i}$，那么答案就是： $$\\sum\\limits_{T\\neq \\emptyset} (-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\sum\\limits_{i\\in T}\\dfrac{m}{p_i}$$ 直接做是不行的，考虑对 $k$ 和 $\\sum p_i$ 分类，即设 $f[i,j,k]$ 表示考虑前 $i$ 个数，当前 $\\sum p_i=j$，对 $k$ 求上式得到的和。 考虑转移，如果不选择 $i$，那么 $f[i,j,k]\\gets f[i-1,j,k]$。如果选择 $i$，考虑 $j,k$ 同时变化，把组合数拆开，贡献应当是 $-(f[i-1,j-p[i],k]-f[i-1,j-p[i],k-1])$。那么递推式是: $$ f[i,j,k]=f[i-1,j,k]+f[i-1,j-p[i],k-1]-f[i-1,j-p[i],k] $$ 边界是 $f[i,0,0]=1$，那么这样 DP 的复杂度就是 $O(nm(n-k))$。 代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int CN = 1e4 + 10;const int P = 998244353;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int n, K, m, f[CN][20], p[CN], inv[CN];int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = 1e4, inv[1] = 1; for(int i = 2; i &lt;= n; i++) inv[i] = 1ll * inv[P % i] * (P - P / i) % P; n = read(), K = n - read() + 1, m = read(); for(int i = 1; i &lt;= n; i++) p[i] = read(); f[0][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = m; j &gt;= p[i]; j--) for(int k = K; k; k--) f[j][k] = add(f[j][k], add(f[j - p[i]][k - 1], P - f[j - p[i]][k])); } int ans = 0; for(int j = 1; j &lt;= m; j++) ans = add(ans, 1ll * m * inv[j] % P * f[j][K] % P); printf(&quot;%d\\n&quot;, ans); return 0; } 相关题目 「SDJX2017」第三题 「HAOI2015」按位或 「PKUWC2018」随机游走 「LG-P4707」重返现世","link":"/2021/01/04/min-max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"「维护日志」2019-3-22 改版","text":"经过三个晚上的不懈努力与若干次调试，新的主题被打磨得终于能看得过去了。于是bn’s Blog得以以船新面貌面世，不过依然留下了一大堆不可优化的BUG…… 1 界面更新采用了GodBMW设计的主题Art Design。界面样式如封面图。 去除了动态背景。 独立了“友链”页面。 2 功能更新去除了字数统计。去除了阅读数统计。 添加了运行时间统计。 原Links内容移至底栏。保留了Valine评论系统。 3 文章格式主题采用了新的文章格式，模板如下： 123456789101112131415161718192021222324252627---title: 样板date: y-m-d h:mcategories: 分类tags: - 标签cover: &quot;https://text.com/demo.png&quot;mathjax: truedonates:share:widgets: - type: toc position: right - type: recent_posts position: rightsidebar: left: sticky: false right: sticky: true--- # head引文...... &lt;!-- more --&gt; # begin$$ ---- \\mathcal{End} ---- $$ # end`最近更新： y-m-d upds。` # upd 支持引文和封面图。 支持文章分类。 4 访问速度问题与原先采用的NexT相比，在一定程度上提升了访问速度。 5 已知BUG站内搜索基于Google实现，目前无法正常使用（我看以后也悬）。解决办法请参见站内公告。 6 Updates2019.3.29用了三天的时间尝试移植原先NexT主题的静态搜索。结果资源文件配置好了，语法转义也完成了，就是不知道怎么加上一个调用链接（大雾）。然后发现完全不懂Javascript……虽然搞了三天有点理解语法了，但还是看不懂。于是发现不可改，放弃，日后再说。 把原先链接到搜索框的搜索键直接链接到了search.xml资源文件，方便使用页面查找实现（实现？？）站内搜索。 2019.3.30把valine换成了gitalk。 好了，这样新主题的打磨基本就完成了，以后只debug（真香警告）。","link":"/2019/03/22/%E3%80%8C%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%E3%80%8D2019-3-22%20%E6%94%B9%E7%89%88/"},{"title":"「解题报告」 Codeforces Round 599 (Div. 2)","text":"解题报告貌似鸽了好几天了，毕竟是晚上爆肝打的比赛，第二天早上起来还要 % 拟 ……其实之前还有场 Div. 3 ，不过打的太烂就不写解题报告了…… 先是掉分经过：开场 15min 切 A,B1 签到不多说，然后去看 B2 ，觉得它不显然；就去看 C 题，然后觉得这个东西貌似可以分解质因数然后搞一搞，结果后来代码一直锅掉，调了将近一个小时才过……期间去看 D 题，也没有什么本质的想法，然后就睡觉去了，大概在 0:20 a.m. 左右，目测掉分预定。第二天早上起来发现 C 题居然没锅，然后就神奇的 rating +19 ，不过依然是 $\\text{Specialist}$ 。 A. Maximum SquareSource 签到题。当时切了 C 题去 room 里砍人，居然发现这题有人写二分……无言以对。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e3+3;int read(){/* omitted */}int q,n,a[CN];int main(){ q = read(); while(q--){ n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=n;i;i--){ int cnt = 0; for(int j=1;j&lt;=n;j++) if(a[j] &gt;= i) cnt++; if(cnt &gt;= i) {printf(&quot;%d\\n&quot;,i); break;} } } return 0;} B1. Character Swap (Easy Version)Source 依然签到。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e4+4;int read(){/* omitted */}int k,n; char s[CN],t[CN];int main(){ k = read(); while(k--){ n = read(); cin&gt;&gt;s&gt;&gt;t; int cnt = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) cnt++; if(cnt != 2) printf(&quot;No\\n&quot;); else{ int p[20],q = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) p[q++] = i; swap(s[ p[0] ], t[ p[1] ]); cnt = 0; for(int i=0;i&lt;n;i++) if(s[i] != t[i]) cnt++; if(!cnt) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } } return 0;} B2 不会，skip 。 C. Tile PaintingSource 考虑有哪些格子的颜色相同，不难发现这个东西跟它的质因子有关系。从一个点出发，我们应该筛掉从该点出发，以 n 的任一质因子为“距离”能到达的所有点，这些点的颜色相同；然后下一次我们应该再去找一个没有被筛过的点重复上述过程。问题的本质在于“没有被筛过的点”我们能找到几个。 不难发现如果一个数字只有一个质因子 p ，那么这样的点我们有 p 个，即 1~p ；若其存在两个或更多的质因子，那么看起来从第一个点开始就能筛掉所有点，于是答案是 1 . 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longLL n,p[101];void div(LL x){ for(LL k=2;k*k&lt;=x;k++){ if(!(x % k)) p[ ++p[0] ] = k; while(!(x % k)) x /= k; } if(x &gt; 1) p[ ++p[0] ] = x;}int main(){ scanf(&quot;%I64d&quot;,&amp;n); if(n == 1){ printf(&quot;1&quot;); return 0; } div(n); if(p[0] == 1) printf(&quot;%I64d&quot;,p[1]); else printf(&quot;1&quot;); return 0;} D. 0-1 MSTSource 显然连 0 边更优，也就是说我们只在迫不得已的情况下去连 1 边。考虑在图上只保留 0 边，那么显然一个联通块里面我们是不需要连 1 边的。把每个联通块整体考虑，则需要连 1 边的数量为联通块数 -1 。 上述过程大力搜索实现显然是不行的，考虑用并查集维护联通性。我们怎么判定一个点属于一个联通块？假设某一联通块的大小为 sz ，那么一个点向它连的 1 边的数量（记作 ct ）是可以统计的，而该点和此联通块一共有 sz 条边相连；当 sz &gt; ct 时，即可推出该点与联通块之间有 0 边。 可是上述过程大力去做还是 O(n^2) 的，考虑到一个联通块只需要被合并一次，于是对于所有找到的联通块，只记录其中一个点进行合并就好了，也就是把该联通块在并查集中的根记下来。因为原图上 0 边很多，也就是说联通块个数很少，所以这个想法就会跑得很快。 最后的答案是并查集中根的个数 -1，其中根的个数即为联通块数。考虑到我们此前维护的根可能被合并，也就是说有些根 gg 掉了，所以最后还得再统计一下根的数量。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int CN = 1e5+5;class dsu{ public: int fa[CN],sz[CN]; vector&lt;int&gt; rt; dsu() {for(int i=1;i&lt;CN;i++) fa[i]=i,sz[i]=1;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {x = find(x); y = find(y); sz[y] += sz[x]; fa[x] = y;}}co;class fs{ public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}}E[CN * 21];int hd[CN],ecnt = 0;void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n,m;int ve[CN];int ct(){ co.rt.push_back(1); for(int i=2;i&lt;=n;i++){ memset(ve, 0, sizeof(ve)); for(int k=hd[i];k;k=E[k].nxt){ int v = E[k].to; if(v &lt; i) ve[ co.find(v) ]++; } int cn = co.rt.size(); for(int j=0;j&lt;cn;j++){ int r = co.rt[j]; r = co.find(r); if(co.sz[r] &gt; ve[r] &amp;&amp; co.exm(i, r)) co.merge(i, r); } if(co.find(i) == i) co.rt.push_back(i); } int cnt = 0; for(int i=1;i&lt;=n;i++) if(co.find(i) == i) cnt++; return cnt;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add(u, v); add(v, u); } printf(&quot;%d&quot;,ct() - 1); return 0;}","link":"/2019/11/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%20Codeforces%20Round%20599%20(Div.%202)/"},{"title":"「解题报告」AtCoder Beginner Contest 178","text":"人生 AK 第一场，不过我还是这么的菜…… 比赛链接 A. Not考察输入输出。 123#include&lt;iostream&gt;using namespace std;int main() {int x; cin &gt;&gt; x; x ^= 1; cout &lt;&lt; x;} B. Product Max对四个值取个 $\\max$ 即可。 12345678910#include&lt;iostream&gt;using namespace std;#define LL long longLL a, b, c, d, x, y;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; x = max(a * c, a * d), y = max(b * c, b * d); cout &lt;&lt; max(x, y);} C. Ubiquity简单容斥一下即可。 123456789101112#include&lt;iostream&gt;using namespace std;const int P = 1e9 + 7;int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int n;int main(){ cin &gt;&gt; n; int ans = qp(10, n), k = 2ll * qp(9, n) % P; ans = (ans - k + P) % P, k = qp(8, n), ans = (ans + k) % P; cout &lt;&lt; ans;} D. Redistribution枚举数列的长度，然后简单插板即可。 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;const int P = 1e9 + 7;using namespace std;const int CN = 2e3 + 100;int C[CN][CN];void pcal(int n){ C[0][0] = 1; for(int i = 1; i &lt;= n; i++){ C[i][0] = 1; for(int j = 1; j &lt;= i; j++) C[i][j] = ( C[i - 1][j] +0ll+ C[i - 1][j - 1] ) % P; }}int n, ans = 0; int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n, pcal(n); int ans = 0; for(int l = 1; l * 3 &lt;= n; l++) ans = (ans + C[n - l * 2 - 1][l - 1]) % P; cout &lt;&lt; ans &lt;&lt; endl;} E. Dist Max求平面曼哈顿距离的最大值，有一个经典的技巧是把曼哈顿距离的绝对值拆成四个值的 $\\max$，即有：$$|x-x’|+|y-y’|=\\max x-x’+y-y’, x-x’+y’-y, x’-x+y-y’, x’-x+y’-y$$ 于是维护一下 $x+y$ 和 $x-y$ 的最大最小值更新答案即可。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;#define int long longconst int CN = 2e5 + 5;const int INF = 0x3f3f3f3f3f3f3f3f;int n, x[CN], y[CN], mx = -INF, mn = INF, ans = -INF;signed main(){ ios :: sync_with_stdio(false); freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i]; for(int i = 1; i &lt;= n; i++) mx = max(mx, x[i] + y[i]), mn = min(mn, x[i] + y[i]); ans = max(ans, mx - mn); mx = -INF, mn = INF; for(int i = 1; i &lt;= n; i++) mx = max(mx, x[i] - y[i]), mn = min(mn, x[i] - y[i]); ans = max(ans, mx - mn); cout &lt;&lt; ans;} F. Contrast大概拿set维护一下就好，但是我的做法好像假了，不过考场上瞎搞过去了……做法先咕着吧。 先贴一份假代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;const int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, a[CN], b[CN]; int cnt[CN]; set&lt;int, greater&lt;int&gt; &gt; S;int main(){ n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) b[i] = read(), S.insert(b[i]), cnt[ b[i] ]++; memset(b, 0, sizeof(b)); bool flag = true; for(int i = 1; i &lt;= n &amp;&amp; flag; i++){ bool has = false; for(set&lt;int&gt; :: iterator it = S.begin(); it != S.end(); it++){ int val = *it; if(val ^ a[i]){ b[i] = val, has = true, cnt[val]--; if(!cnt[val]) S.erase(it); break; } } flag &amp;= has; } if(!flag) puts(&quot;No&quot;); else{ puts(&quot;Yes&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]); }}","link":"/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/"},{"title":"「维护日志」2019-4-14 改版","text":"不得不说，好主题还是真香啊。刚打磨了三个多星期的主题又被抛弃了…… 1 主题采用了ICARUS。 2 功能功能被大部分保留。 运行时间统计被删除。 评论系统又换回Valine。因为Gitalk出了玄学错误… 3 文章格式更新的文章格式如下： 1234567891011121314151617181920212223242526272829---title: 样板date: y-m-d h:mcategories: 分类tags: - 标签cover: &quot;https://text.com/demo.png&quot;toc: truetoc_auto_num: falsemathjax: truedonates:share:widgets: - type: toc position: right - type: recent_posts position: rightsidebar: left: sticky: false right: sticky: true---引文......&lt;!-- more --&gt;$$ ---- \\mathcal{End} ---- $$`最近更新： y-m-d upds。` 4 访问速度它已经够快了！ 5 已知BUG暂无。","link":"/2019/04/14/%E3%80%8C%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%E3%80%8D2019-4-14%20%E6%94%B9%E7%89%88/"},{"title":"「解题报告」Codeforces Round 594 (Div. 2)","text":"可怜的小cj被卡死在C题…… A. PolandBall and HypothesisSource 不难发现只有形如y=x+b1和y=-x+b2的函数会有交点。联立x+b1 = -x+b2,有x = (b2-b1)/2。这个东西为整数，当且仅当b2-b1为偶数。也就是说现在我们要统计∀i∈[1,n],j∈[1,m] , (bj-bi) ≡ 0 (mod 2)的数量。我们发现我们关注的只是bj-bi的奇偶性，而并不是这个式子具体的值。考虑什么情况下两数相减会出现偶数：偶-偶 或 奇-奇 。考虑用乘法解决这个问题，那我们设c1表示bi(i∈[1,n])$中奇数的数量，c2表示bj(j∈[1,m])中奇数的数量，那么答案显然就是c1×c2 + (n-c1)×(m-c2)。于是做完了。 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define LL long longconst int CN = 1e5+5;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}LL t,n,m;int main(){ //freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); t = read(); while(t--){ LL cnt1 = 0,cnt2 = 0,ans; n = read(); for(int i=1;i&lt;=n;i++) {int pi = read(); if(pi % 2) cnt1++;} m = read(); for(int i=1;i&lt;=m;i++) {int qi = read(); if(qi % 2) cnt2++;} ans = cnt1 * cnt2 + (n-cnt1) * (m-cnt2); printf(&quot;%I64d\\n&quot;,ans); } return 0;} B. Grow The TreeSource 不能有连续的两段就是让你把这些边分成大小分别为⌊n/2⌋，⌈n/2⌉的两组。一个并不显然但是是正确的的贪心思路：小的分一组，大的分一组。然后就做完了。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std; #define LL long long const int CN = 1e5+5; LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;} int n; LL a[CN],sum[CN]; LL Pow(LL u) {return u*u;} int main(){ //freopen(&quot;b.in&quot;,&quot;r&quot;,stdin); n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) sum[i] = sum[i-1]+a[i]; LL ans = Pow(sum[_n]) + Pow(sum[n]-sum[_n]); int _n = n/2; if(_n * 2 != n) ans = max(ans, Pow(sum[_n+1])+Pow(sum[n]-sum[_n+1])); printf(&quot;%I64d&quot;,ans); return 0;} C. Ivan the Fool and the Probability TheorySource 考虑第一行。固定第一个格子的颜色，那么方案数是一个fibonacci数列。推广到整个矩阵： 当第一行不存在相邻元素时，也就是说它长这样：10101… 这个时候仅需要相邻三行互不相同。把每一行理解成一个元素，实际上又回到了上面的那个问题，这个方案数又是一个fibonacci数列。因此此时答案是 1×f[m] 。 当第一行存在相邻元素时，那么下面的整个矩阵实际上已经确定了，因为下面的每一行都只能是上面一行把每位都取反的结果。此时答案为 (f[n]-1)×1 。 因此答案总数为 1×f[m] + (f[n]-1)×1 = f[n]+f[m]-1 。考虑第一个格子有两种情况，因此答案是 2×(f[n]+f[m]-1) 。 代码： 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int CN = 1e5+5;const int R = 1e9+7;int n,m,f[CN];int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); f[0] = 2,f[1] = 2; for(int i=2;i&lt;=max(n,m);i++) f[i] = (f[i-1]+f[i-2]) % R; printf(&quot;%d&quot;, (f[n]+f[m]-2) % R); return 0;} D1. The World Is Just a Programming Task (Easy Version)Source 显然是枚举方案，剩下的问题是怎么找“循环匹配”个数。设’(‘代表 1 ，’)’代表 -1 ，于是我们得到一串数列。有一个结论是说“循环匹配”个数恰好等于这个数列的前缀和最小值的数量，感性理解一下，这个东西很有道理，然后就做完了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 550;int abs(int x) {return x &gt; 0 ? x : -x;}int n; char ch[CN];int ans = 0,ansi = 1,ansj = 1;int GetAns(){ int cnt = 0,sum = 0,mn = 0; for(int i=0;i&lt;n;i++){ if(ch[i] == '(') cnt++; else cnt--; mn = min(mn, cnt); } for(int i=0;i&lt;n;i++){ if(ch[i] == '(') cnt++; else cnt--; if(cnt == mn) sum++; } return sum;}bool checker(){ int a = 0,b = 0; for(int i=0;i&lt;n;i++) if(ch[i] == '(') a++; else b++; return a == b;}int main(){ scanf(&quot;%d&quot;,&amp;n); cin&gt;&gt;ch; if(!checker()) printf(&quot;0\\n1 1&quot;); else{ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++){ swap(ch[i],ch[j]); if(GetAns() &gt; ans) {ans = GetAns(); ansi = i+1; ansj = j+1;} swap(ch[j],ch[i]); } printf(&quot;%d\\n%d %d&quot;,ans,ansi,ansj); } return 0;}","link":"/2019/10/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20594%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 597 (Div. 2)","text":"真香警告.jpg…… A. Good ol’ Numbers ColoringSource 看完样例就很显然了，切掉就好了。 代码： 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c == '-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s = (s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s * ne;}int t,a,b;int gcd(int a,int b){return !b ? a : gcd(b, a % b);}int main(){ t = read(); while(t--){ a = read(); b = read(); if(gcd(a,b) == 1) printf(&quot;Finite\\n&quot;); else printf(&quot;Infinite\\n&quot;); } return 0;} B. Restricted RPSSource 每步贪心，能干就干。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;int read(){ int s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c == '-') ne = -1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s = (s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s * ne;}int t,n,s0,s1,s2,opt[CN],ans[CN]; bool bt[CN];int main(){ t = read(); while(t--){ n = read(); s1 = read(); s0 = read(); s2 = read(); for(int i=1;i&lt;=n;i++){ char c; cin&gt;&gt;c; if(c == 'P') opt[i] = 0; if(c == 'R') opt[i] = 1; if(c == 'S') opt[i] = 2; } memset(bt,0,sizeof(bt)); int cnt = 0; for(int i=1;i&lt;=n;i++){ if(!opt[i] &amp;&amp; s2) bt[i] = true,s2--; if(opt[i] == 1 &amp;&amp; s0) bt[i] = true,s0--; if(opt[i] == 2 &amp;&amp; s1) bt[i] = true,s1--; } for(int i=1;i&lt;=n;i++){ if(bt[i]) ans[i] = (opt[i] + 2) % 3,cnt++; else{ if(s0) ans[i] = 0,s0--; else if(s1) ans[i] = 1,s1--; else if(s2) ans[i] = 2,s2--; } } int vs = n / 2; if(n % 2) vs += 1; if(cnt &gt;= vs){ printf(&quot;Yes\\n&quot;); for(int i=1;i&lt;=n;i++){ if(!ans[i]) cout&lt;&lt;'P'; if(ans[i] == 1) cout&lt;&lt;'R'; if(ans[i] == 2) cout&lt;&lt;'S'; } printf(&quot;\\n&quot;); } else printf(&quot;No\\n&quot;); } return 0;} C. Constanze’s MachineSource 这题看上去还是比较有感觉的，只不过式子错了，这就很dl了（真香）。 首先显然可以把每个连续字段的方案数算出来然后再乘法原理，剩下的问题是求一个“连续字段”的方案数。 关于“连续字段”的方案，这个问题可以抽象成给你一段序列类似于“uuuuuu”这个样子，让你在其中划若干条长度为 2 的线，两两线不能相交，求方案数。那么显然这个东西可以设个状态写写方程，于是设 f[i] 表示考虑长度为 i 的序列的方案数。考虑新加入的这个元素，我们可以把它和元素 i-1 划成一段，方案数 f[i-2] ；也可以不划到任何一段，方案数 f[i-1] 。于是 f[i]=f[i-1]+f[i-2] ，又是 fibonacci 数列…然后做完了。 比赛的时候方程推成了 f[i]=f[i-1]+i-2 ，因为实际上我只考虑了划两段的情况…然后pretest9一直WA，自闭了，看来还是不够熟练… 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; #define LL long long const int CN = 2e5+5;const LL R = 1e9+7; char ch[CN]; int n;LL f[CN],ans = 1; int main(){ cin&gt;&gt;ch; n = strlen(ch); f[1] = 1; f[2] = 2; for(LL i=3;i&lt;=n;i++) f[i] = (f[i-1] + f[i-2]) % R; bool flag = true; for(int i=0;i&lt;n;i++) if(ch[i] == 'm' || ch[i] == 'w') flag = false; if(!flag) printf(&quot;0&quot;); else{ for(int i=0;i&lt;n;i++){ if(ch[i] != 'n' &amp;&amp; ch[i] != 'u') continue; int p = i,l = 1; while(p &lt; n &amp;&amp; ch[p] == ch[p+1]) p++,l++; (ans *= f[l]) %= R; i = p; } printf(&quot;%I64d&quot;,ans); } return 0;} D. Shichikuji and Power GridSource 第一眼没什么感觉，看了 tutorial 发现就是个 mst … 建一个虚点向每个点连边，表示建电站就好了，看来还是不够熟练… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std; #define LL long long const int CN = 2010; class fs{ public: int fr,to; LL di; void init(int f,int t,LL d) {fr=f;to=t;di=d;} bool operator &lt; (const fs&amp; a)const {return di &lt; a.di;}}E[CN * CN];int ecnt = 0;void add(int x,int y,LL z) {E[++ecnt].init(x,y,z);}class ufs{ public: int fa[CN]; ufs() {for(int i=1;i&lt;CN;i++) fa[i] = i;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {fa[find(x)] = find(y);} }ck; int n,px[CN],py[CN],pc[CN],pk[CN];int abs(int x) {return x&lt;0 ? -x : x;}int dist(int a,int b) {return abs(px[a] - px[b]) + abs(py[a] - py[b]);} bool sel[CN * CN]; LL si = 0;void MST(){ memset(sel,false,sizeof(sel)); sort(E+1,E+ecnt+1); int cnt = 0; for(int i=1;i&lt;=ecnt;i++){ if(!ck.exm(E[i].fr, E[i].to)) continue; ck.merge(E[i].fr, E[i].to); cnt++; si += E[i].di; sel[i] = true; if(cnt == n - 1) break; }} int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;px[i],&amp;py[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pc[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pk[i]); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) add(i,j,1ll*(pk[i]+pk[j])*dist(i,j)); for(int i=1;i&lt;=n;i++) add(i,n+1,pc[i]); n += 1; MST(); printf(&quot;%I64d\\n&quot;,si); int cnt = 0; for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to == n) cnt++; printf(&quot;%d\\n&quot;,cnt); for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to == n) printf(&quot;%d &quot;,E[i].fr); printf(&quot;\\n&quot;); cnt = n - 1 - cnt; printf(&quot;%d\\n&quot;,cnt); for(int i=1;i&lt;=ecnt;i++) if(sel[i] &amp;&amp; E[i].to != n) printf(&quot;%d %d\\n&quot;,E[i].fr,E[i].to); return 0;}","link":"/2019/11/03/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20597%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 596 (Div. 2)","text":"又被C题的一些小细节卡死…… A. Forgetting ThingsSource 不难发现只有 a+1 = b 或 a = b 时才有解。前一种直接输出 ‘a b’ ，后一种输出 ‘a0 b1’ 。然后还有一个坑点是 a = 9,b = 1 的情况，此时是有解的，应输出 ‘9 10’。 代码： 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int a,b;int main(){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a == b) printf(&quot;%d0 %d1&quot;,a,b); else if(a + 1 == b) printf(&quot;%d %d&quot;,a,b); else if(a == 9 &amp;&amp; b == 1) printf(&quot;9 10&quot;); else printf(&quot;-1&quot;); return 0;} B. TV SubscriptionsSource (Easy Version)Source (Hard Version) 区间的长度是固定的，那么只需要开一个桶，维护一下在某段区间内有那些元素。考虑从一个区间滑动到另一个区间，那么这时候区间内元素个数是可以 O(1) 维护的，然后切了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e6+6;const int INF = 0x3f3f3f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int t,n,k,d,a[CN];int tot[CN];int main(){ t = read(); while(t--){ memset(tot,0,sizeof(tot)); n = read(); k = read(); d = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); int ans = INF,cnt = 0; for(int i=1;i&lt;d;i++) {if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++;} for(int i=d;i&lt;=n;i++){ if(!tot[ a[i] ]) cnt++; tot[ a[i] ]++; tot[ a[i-d] ]--; if(!tot[ a[i-d] ]) cnt--; ans = min(ans, cnt); } printf(&quot;%d\\n&quot;,ans); } return 0;} C. p-binarySource 简化一下题意：给定 $p,s$ ，试求得一个最小的 $n$ ，使得存在一组 $\\begin{Bmatrix} k_1,k_2,…,k_n \\end{Bmatrix}$ ，满足 $\\sum\\limits_{i=1}^n 2^{k_i} + np = s$ 。 把 $np$ 移到右边去，变形成 $\\sum\\limits_{i=1}^n 2^{k_i} = s-np$ 。枚举 $n$ 之后， $s-np$ 就变成了一个定值，于是很自然的联想到可以把 $s-np$ 这个数表示成二进制下的和的形式，也就是 $s-np=\\sum\\limits_{(s-np) \\And 2^i} 2^i$ 。那么这实际上就是一种可行的拆分方案，我们只需要 check 一下 $(s-np) \\And 2^i$ 成立的数量是否恰好等于 $n$ 即可，也就是判断 $s-np$ 在二进制下 $1$ 的数量是否恰好等于 $n$ ，这是 $O(\\log)$ 的。 但是这并不能涵盖所有的方案。事实上，对于一个正整数 $k$，总有 $2^k=2\\times(2^{k-1})=2^{k-1} + 2^{k-1}$ ，也就是说有一些项我们依然可以继续拆分。考虑 $2^k$ 能拆出的项数的范围：最少只有它自己，也就是一项；最多呢？考虑把上面拆分的过程看作一棵二叉树，不难发先我们总可以拆出两项，三项，…，直到 $k$ 项。那么对于任意的 $2^k$ ，它总可以被拆分一项，两项，…， $k$ 项，也就是说它“能拆出的项数的范围”是 $[1,k]$ 。 考虑 $s-np=\\sum\\limits_{(s-np) \\And 2^i} 2^i$ 中，后面那些部分能变成多少项。显然，任意 $2^i$ 能拆出的项数的范围是 $[1,i]$ ，那么设 $s-np = 2^{i_1}+2^{i_2}+…+2^{i_k} $ ，其中后面那一部分共有 $k$ 项，即可推出 $s-np$ 能拆出的项数的范围就是 $[k,i_1+i_2+…+i_k]$ 。 于是我们要做的就变成了 check 一下 $n\\in [k,i_1+i_2+…+i_k]$ 是否成立，若成立则我们找到了一个可行解。这个判断还是 $O(\\log)$ 的，那么只需要在 $10^6$ 内枚举 $n$ 就好了。 然后还有一些小细节，比赛的时候把我卡死了。。。具体看代码。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int N = 1e6; // 枚举的边界，实际上还可以更小LL n,p,ans = -1;bool checker(LL u,int k){ if(!u) return false; // 特判 u 为 0 时一定无解 int lb = 0,rb = 1,i = 0; // rb 一定要初始化为 1, 因为至少有一项 while(u){ if(u &amp; 1) lb++,rb += i; u &gt;&gt;= 1,i++; } return lb &lt;= k &amp;&amp; k &lt;= rb;} int main(){ scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;p); for(int k=1;k&lt;=N;k++){ LL c = n - 1ll * k * p; if(c &lt; 0) break; if(checker(c,k)){ ans = 1ll * k; break; } } printf(&quot;%I64d&quot;,ans);}","link":"/2019/10/27/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20596%20(Div.%202)/"},{"title":"「解题报告」Codeforces Round 667 (Div. 3)","text":"最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分…… 比赛链接 A. Yet Another Two Integers Problem签到傻题。 123456int t, a, b;t = read(); while(t--){ a = read(), b = read(); int k = abs(a - b), b = k / 10; if(b * 10 == k) printf(&quot;%d&quot;, b); else printf(&quot;%d&quot;, b + 1); puts(&quot;&quot;);} B. Minimum Product设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\\max(0,y-b+n)$ 或 $a-x$，代入检验即可。 代码： 12345678910111213141516#define int long longconst int INF = 0x3f3f3f3f3f3f3f3f;int t, a, b, x, y, n;t = read(); while(t--){ a = read(), b = read(), x = read(), y = read(), n = read(); int ans = INF, c, d; if(a + b - x - y &lt;= n) ans = x * y; else{ c = min(n, a - x), d = min(b - y, n - c); ans = min(ans, (a - c) * (b - d)); c = min(n, max(0ll, y - b + n)), d = min(b - y, n - c); ans = min(ans, (a - c) * (b - d)); } printf(&quot;%I64d&quot;, ans); puts(&quot;&quot;);}} C. Yet Another Array Restoration傻题，模拟即可。 123456789101112131415161718192021222324const int CN = 202;int t, n, x, y, d, a[CN], ans[CN];int mx(int a[]){ int mx = 0; for(int i = 1; i &lt;= n; i++) mx = max(mx, a[i]); return mx;}t = read(); while(t--){ n = read(), x = read(), y = read(); int mn = INT_MAX; for(d = 1; d &lt;= y; d++){ if((y - x) % d) continue; int l = (y - x) / d + 1, u = x; if(l &gt; n) continue; for(int i = 1; i &lt;= l; i++) a[i] = u, u += d; if(l &lt; n){ int sum = n - l; u = x - d; while(u &gt; 0 &amp;&amp; sum) sum--, a[++l] = u, u -= d; u = y + d; while(sum) sum--, a[++l] = u, u += d; } int cur = mx(a); if(cur &lt; y) continue; if(cur &lt; mn) mn = cur, memcpy(ans, a, sizeof(a)); } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;);} D. Decrease the Sum of Digits容易发现代价是固定的，那么模拟即可。 123456789101112131415#define int long longint t, n, s, bit[101], p10[101], cur;p10[0] = 1; for(int i = 1; i &lt;= 70; i++) p10[i] = p10[i - 1] * 10;t = read(); while(t--){ cur = 0, n = read(), s = read(); int lg = 0; while(n) bit[++lg] = n % 10, n /= 10, cur += bit[lg]; int ans = 0; for(int i = 1; i &lt;= lg &amp;&amp; cur &gt; s; i++){ if(!bit[i]) continue; ans += (10 - bit[i]) * p10[i - 1]; bit[i + 1]++, cur -= bit[i] - 1; } printf(&quot;%I64d&quot;, ans), puts(&quot;&quot;);} E. Two Platforms离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 6e5 + 5;int t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}signed main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); t = read(); while(t--){ n = read(), d = read(), val[0] = 0; for(int i = 1; i &lt;= n; i++) X[i] = read(), val[ ++val[0] ] = X[i], val[ ++val[0] ] = X[i] + d, val[ ++val[0] ] = X[i] - d; for(int i = 1; i &lt;= n; i++) read(); sort(val + 1, val + val[0] + 1); int cnt = 1; for(int i = 2; i &lt;= val[0]; i++) if(val[i] ^ val[i - 1]) val[++cnt] = val[i]; val[0] = cnt; for(int i = 0; i &lt;= val[0] + 100; i++) pre[i] = suf[i] = sum[i] = 0; for(int i = 1; i &lt;= n; i++) sum[ id(X[i]) ]++; for(int i = 1; i &lt;= val[0]; i++) sum[i] += sum[i - 1]; for(int i = 1; i &lt;= n; i++){ int p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d); pre[p] = sum[p] - sum[l - 1], suf[p] = sum[r] - sum[p - 1]; } for(int i = 1; i &lt;= val[0]; i++) pre[i] = max(pre[i], pre[i - 1]); for(int i = val[0]; i; i--) suf[i] = max(suf[i], suf[i + 1]); int ans = 0; for(int i = 1; i &lt;= val[0]; i++) ans = max(ans, pre[i] + suf[i + 1]); printf(&quot;%lld&quot;, ans), puts(&quot;&quot;);}} F. Subsequences of Length Two显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。 具体来讲，考虑 $i\\to i+1$，我们有两种选择： 什么都不做，转移到 $f[i+1,c+0/1,k]$； 把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$ 把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$ 最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 210;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, d, f[CN][CN][CN], ans; char s[CN], c1, c2;void DP1(){ memset(f, -0x3f, sizeof(f)), f[0][0][0] = 0; int c = 0; for(int i = 1; i &lt;= n; i++){ f[i][c + (s[i] == c1)][0] = f[i - 1][c][0]; c += (s[i] == c1); if(s[i] == c2) f[i][c][0] += c; } for(int k = 0; k &lt;= d; k++) for(int c = 0; c &lt;= n; c++) for(int i = 0; i &lt;= n; i++){ if(s[i + 1] == c2) f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k] + c); else if(s[i + 1] == c1) f[i + 1][c + 1][k] = max(f[i + 1][c + 1][k], f[i][c][k]); else f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k]); if(s[i + 1] != c1) f[i + 1][c + 1][k + 1] = max(f[i + 1][c + 1][k + 1], f[i][c][k]); if(s[i + 1] != c2) f[i + 1][c][k + 1] = max(f[i + 1][c][k + 1], f[i][c][k] + c); }}void DP2(){ memset(f, -0x3f, sizeof(f)), f[0][0][0] = 0; int c = 0; for(int i = 1; i &lt;= n; i++){ f[i][c + (s[i] == c1)][0] = f[i - 1][c][0]; if(s[i] == c1) c++, f[i][c][0] += c - 1; } for(int k = 0; k &lt;= d; k++) for(int c = 0; c &lt;= n; c++) for(int i = 0; i &lt;= n; i++){ if(s[i + 1] == c1) f[i + 1][c + 1][k] = max(f[i + 1][c + 1][k], f[i][c][k] + c); else f[i + 1][c][k] = max(f[i + 1][c][k], f[i][c][k]); if(s[i + 1] != c1) f[i + 1][c + 1][k + 1] = max(f[i + 1][c + 1][k + 1], f[i][c][k] + c); }}signed main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), d = read(), cin &gt;&gt; (s + 1) &gt;&gt; c1 &gt;&gt; c2; if(c1 != c2) DP1(); else DP2(); for(int x = 0; x &lt;= n; x++) for(int k = 0; k &lt;= d; k++) ans = max(ans, f[n][x][k]); printf(&quot;%lld&quot;, ans);}","link":"/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"},{"title":"「解题报告」Codeforces Round 668 (Div. 2)","text":"两场 Div.2 爆肝上蓝系列…… 比赛链接 A. Permutation Forgery这题是精心构造样例给选手降智啊….卡了我半小时 /kk实际上反过来输出就好了啊… 1234const int CN = 110;int a[CN], n = read();for(int i = 1; i &lt;= n; i++) a[i] = read();for(int i = n; i &gt;= 1; i--) printf(&quot;%d &quot;, a[i]); puts(&quot;&quot;); B. Array Cancellation容易发现答案就是后缀和的最大值…证明显然啊，就算了吧… 123456#define int long longconst int CN = 1e5 + 5;int n, a[CN];n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read();int ans = max(0ll, a[n]); for(int i = n - 1; i; i--) a[i] += a[i + 1], ans = max(ans, a[i]);printf(&quot;%lld&quot;, ans), puts(&quot;&quot;); C. Balanced Bitstring容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。 123456789101112131415161718const int CN = 1e6 + 10;int T, n, k; char a[CN], s[CN];ios :: sync_with_stdio(false);cin &gt;&gt; n &gt;&gt; k &gt;&gt; a; for(int i = 0; i &lt; k; i++) s[i] = '?'; bool flag = true;for(int i = 0; i &lt; n &amp;&amp; flag; i++) if(a[i] != '?') { if(s[i % k] == '?') s[i % k] = a[i]; else if(s[i % k] != a[i]) flag = false; } int cnt0 = 0, cnt1 = 0;for(int i = 0; i &lt; k; i++) cnt1 += (s[i] == '1'), cnt0 += (s[i] == '0');if(cnt0 &gt; (k / 2) || cnt1 &gt; (k / 2)) flag = false;flag ? puts(&quot;YES&quot;) : puts(&quot;NO&quot;); D. Tree Tag容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int CN = 1e5 + 5;int T, n, a, b, da, db;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}void hinit() {for(int i = 0; i &lt;= n; i++) hd[i] = 0;}int d[CN], dm;void dinit() {for(int i = 0; i &lt;= n; i++) d[i] = 0;}void dfs(int u, int p){ for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) d[v] = d[u] + 1, dfs(v, u);}}int fa[CN][21], dep[CN];void finit(){ for(int i = 0; i &lt;= 20; i++) for(int j = 0; j &lt;= n; j++) fa[j][i] = 0; for(int i = 0; i &lt;= n; i++) dep[i] = 0;}void pc(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) pc(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v) {for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0];} return u;}int dis(int u, int v) {return dep[u] + dep[v] - 2 * dep[lca(u, v)];}int main() { T = read(); while(T--){ hinit(), ecnt = 0; n = read(), a = read(), b = read(), da = read(), db = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} finit(), pc(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; if(dis(a, b) &lt;= da) {puts(&quot;Alice&quot;); continue;} dinit(), dfs(1, 0); int mx = 0, p; for(int i = 1; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx; dinit(), dfs(p, 0), dm = 0; for(int i = 1; i &lt;= n; i++) dm = max(dm, d[i]); if(2 * da &gt;= dm) puts(&quot;Alice&quot;); else if(db &gt;= 2 * da + 1) puts(&quot;Bob&quot;); else puts(&quot;Alice&quot;);}} E. Fixed Point Removal容易发现一个点能否被消除仅与询问的左边界 $l$ 有关，设 $p_i$ 为可以令 $a_i$ 消除的最大的 $l$，则答案是 $\\sum\\limits_{i=l}^r[p_i\\ge l]$，这是一个愉快的二维数点。考虑 $p_i$ 如何求出，容易观察到如下性质： 若 $a_i &gt; i$，则可以定义 $p_i = 0$； 若 $a_i = i$，显然 $p_i=i$； 若 $a_i &lt; i$，则 $p_i=\\max m, \\text{s.t.} \\left( \\sum\\limits_{j=m}^{i-1}[p_j\\ge m]\\right) \\ge i - a_i$ 前两条都好处理，最后一条二分即可，套一个静态主席树解决二维数点，时间复杂度 $O(n\\log^2 n+q\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int CN = 3e5 + 5;class SGT { public: int d[CN * 50], ch[CN * 50][2], rt[CN], idx; SGT(){idx = 0;} #define lc ch[u][0] #define rc ch[u][1] void md(int &amp;u, int v, int l, int r, int p){ if(!u) u = ++idx; if(l == r) return (void)(d[u] = d[v] + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) rc = ch[v][1], md(lc, ch[v][0], l, m, p); else lc = ch[v][0], md(rc, ch[v][1], m + 1, r, p); d[u] = d[lc] + d[rc]; } int qu(int u, int v, int l, int r, int p){ if(l == r) return d[u] - d[v]; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) return d[rc] - d[ch[v][1]] + qu(lc, ch[v][0], l, m, p); else return qu(rc, ch[v][1], m + 1, r, p); }} D;int n, q, p[CN];int main(){ n = read(), q = read(); for(int i = 1; i &lt;= n; i++){ int ai = read(); if(ai &gt; i) p[i] = 0; else if(ai == i) p[i] = i; else{ int l = 0, r = i - 1, m, minus = i - ai; while(l &lt; r){ m = (l + r + 1) &gt;&gt; 1; int cur = D.qu(D.rt[i - 1], D.rt[m - 1], 0, n, m); if(cur &gt;= minus) l = m; else r = m - 1; } p[i] = l; } D.md(D.rt[i], D.rt[i - 1], 0, n, p[i]); } while(q--){ int l = read(), r = read(); l++, r = n - r; printf(&quot;%d&quot;, D.qu(D.rt[r], D.rt[l - 1], 0, n, l)), puts(&quot;&quot;); }}","link":"/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"},{"title":"「解题报告」NIKKEI Prog. Contest 2019-2","text":"又是签到走人的一天…… A. Sum of Two IntegersSource 签到题。 12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); if(n % 2) n += 1; n /= 2; printf(&quot;%d&quot;,n - 1); return 0;} B. Counting of TreesSource 签到题。考虑每一层的方案数，直接乘法原理就好了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define LL long longconst int CN = 1e5+5;const LL R = 998244353;int n,fir; LL s[CN];LL qpow(LL a,LL b){ LL rec = 1; while(b){ if(b &amp; 1) (rec *= a) %= R; (a *= a) %= R; b &gt;&gt;= 1; } return rec;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;fir); for(int i=2;i&lt;=n;i++){ int x; scanf(&quot;%d&quot;,&amp;x); if(!x) {fir = 1; break;} s[x]++; } for(int i=1;i&lt;=n;i++) if(s[i]) s[0] = i; for(int i=1;i&lt;=s[0];i++) if(!s[i]) fir = 1; if(fir) printf(&quot;0&quot;); else{ LL ans = 1; for(int i=2;i&lt;=s[0];i++) (ans *= qpow(s[i-1], s[i])) %= R; printf(&quot;%lld&quot;,ans); } return 0;} C 不会，skip 。 D. Shortest Path on a LineSource 这题把我卡了一个多小时还没想出来，当时一直在想建个线段树搞线段覆盖…… 实际上一段区间里面任意两点间有等距的有向边，这个东西等价于把这段区间连成一个简单环：节点顺序连边，然后仅有一条边有边权为 ci ，其余为 0 。那么如果我们逆着这个环的方向去求最短路，就能得到这个长度总是 ci ，因为没法直接到达，就总要经过那条边权为 ci 的边。 一张图解： 剩下的问题跑 DJ 就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CN = 1e5+5;const LL INF = 0x3f3f3f3f3f3f3f2f;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int to,nxt; LL di; void init(int t,int n,LL d) {to=t;nxt=n;di=d;}}E[CN * 51];int hd[CN],ecnt = 0;void add(int x,int y,LL z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n,m;/* DJ */class DJ{ public: int id; LL v; bool operator &lt; (const DJ&amp; a)const {return v &gt; a.v;}};priority_queue&lt;DJ&gt; Q; LL d[CN]; bool vis[CN];LL SP(int st,int ed){ memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); Q.push((DJ){st, d[st] = 0}); while(!Q.empty()){ int u = Q.top().id; Q.pop(); if(vis[u]) continue; vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(d[v] &gt; d[u] + E[k].di){ d[v] = d[u] + E[k].di; Q.push((DJ){v, d[v]}); } } } return d[ed] &lt; INF ? d[ed] : -1;}int main(){ n = read(); m = read(); while(m--){ int u = read(),v = read(); LL c = read(); add(u, v, c); } for(int i=1;i&lt;n;i++) add(i + 1, i, 0); printf(&quot;%lld&quot;, SP(1, n)); return 0;}","link":"/2019/11/10/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DNIKKEI%20Prog%20Contest%202019-2/"},{"title":"「解题报告」洛谷九月月赛","text":"今天怎么有一页阿克爷啊…..怎么我还是啥都不会啊…… A 子弦容易发现答案是出现次数最多的字母的出现次数。证明很简单：再扩展一位字符出去限制性也不会变弱。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;const int CN = 1e7 + 7; char ch[CN]; int tot[300], mx = 0;int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; ch; for(int i = 0; ch[i]; i++) tot[ ch[i] ]++; for(int i = 'a'; i &lt;= 'z'; i++) mx = max(mx, tot[i]); printf(&quot;%d&quot;, mx);} B 雷雨跑三遍 Dijkstra，枚举一个中间点拼起来就好了，复杂度 $O(nm(\\log n + \\log m))$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CN = 1e3 + 3;const int dx[4] = {0, 1, 0, -1};const int dy[4] = {1, 0, -1, 0};const LL INF = 0x3f3f3f3f3f3f3f3f;class DJ {public: int x, y; LL v; bool operator &lt; (const DJ &amp; a) const {return v &gt; a.v;}};DJ mk(int a, int b, LL c) {DJ d; d.x = a, d.y = b, d.v = c; return d;}priority_queue&lt;DJ&gt; Q;bool vis[CN][CN];void SP(int n, int m,int sx, int sy, LL d[][CN], LL dis[][CN]){ memset(vis, 0, sizeof(vis)); Q.push( mk(sx, sy, dis[sx][sy] = d[sx][sy]) ); while(!Q.empty()){ int x = Q.top().x, y = Q.top().y; Q.pop(); if(vis[x][y]) continue; vis[x][y] = true; for(int k = 0; k &lt; 4; k++){ int vx = x + dx[k], vy = y + dy[k]; if(!vx || !vy || vx &gt; n || vy &gt; m || vis[vx][vy]) continue; if(dis[vx][vy] &gt; dis[x][y] + d[vx][vy]){ dis[vx][vy] = dis[x][y] + d[vx][vy]; Q.push( mk(vx, vy, dis[vx][vy]) ); } } }}int n, m, a, b, c; LL d[CN][CN], da[CN][CN], db[CN][CN], dc[CN][CN];int main(){ n = read(), m = read(), a = read(), b = read(), c = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) d[i][j] = read(); memset(da, 0x3f, sizeof(da)), SP(n, m, 1, a, d, da); memset(db, 0x3f, sizeof(db)), SP(n, m, n, b, d, db); memset(dc, 0x3f, sizeof(dc)), SP(n, m, n, c, d, dc); LL ans = INF; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans = min(ans, da[i][j] + db[i][j] + dc[i][j] - 2ll * d[i][j]); printf(&quot;%lld&quot;, ans); return 0;} C 梦原考虑如果给出一颗形态固定的树，我们应该怎样算答案？我们只需要把 $w[u]$ 变成 $w[ fa[u] ]-w[u]$（就是树上差分），然后把所有 $w[u]&gt;0$ 的 $w[u]$ 加起来就可以了。也就是我们只考虑把多出来的那部分算到费用里面，容易发现这样一定是最优的。 然后考虑 $i$ 的父亲大概有 $\\min i - 1,k$ 种可能，根据期望的线性性，只需对这些可能求个概率加权和就好了。设 $m=\\min i-1, k$，得到答案是：$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=i-m}^{i-1}\\frac{1}{m}[a_j&lt;a_i](a_i-a_j)$$ 实际上就是个二维数点，由于区间是定长，因此直接拿个树状数组维护即可，复杂度 $O(n\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e6 + 6;const int P = 998244353;int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int n, m, a[CN], val[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}class BIT { public: int d[CN], cnt[CN], n; int lb(int x) {return x &amp; (-x);} void add(int p, int x) {while(p &lt;= n) d[p] = (d[p] + x) % P, cnt[p]++, p += lb(p);} void minus(int p, int x) {while(p &lt;= n) d[p] = (d[p] - x + P) % P, cnt[p]--, p += lb(p);} int qu(int p) {int r = 0; while(p) r = (r + d[p]) % P, p -= lb(p); return r;} int quc(int p) {int r = 0; while(p) r += cnt[p], p -= lb(p); return r;}} D;int main(){ D.n = n = read(), m = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), val[ ++val[0] ] = a[i]; sort(val + 1, val + val[0] + 1); int tmp = 1; for(int i = 2; i &lt;= val[0]; i++) if(val[i] ^ val[i - 1]) val[++tmp] = val[i]; val[0] = tmp; int ans = a[1]; D.add(id(a[1]), a[1]); for(int i = 2; i &lt;= n; i++){ int k = qp(min(i - 1, m), P - 2), si = D.qu( id(a[i]) ), cnt = D.quc( id(a[i]) ); si = (1ll * cnt * a[i] % P - si + P) % P; ans = (1ll * k * si % P + ans) % P; D.add( id(a[i]) , a[i]); if(i &gt;= m + 1) D.minus( id(a[i - m]), a[i - m] ); } printf(&quot;%d&quot;, ans);} D 线形生物看上去今天只有我一个人不会这题的样子……Subtask1, 10pts 交个cout&lt;&lt;(n&lt;&lt;1)上去就好了，因为对每一位都有 $E_i=\\frac{1}{2}E_i+1$，解得 $E_i=2$，因此答案是 $2n$。Subtask4, 40pts 看上去用高斯消元解方程就好了，考场上遇到了些哲学问题没调出来…Subtask5…这就不会了啊。事实上赛后红太阳 SSX 告诉我合并方程就完事了…太草了就不写了…感性理解下吧…","link":"/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/"},{"title":"「解题报告」Codeforces Round 669 (Div. 2)","text":"蒟蒻下分场…… 比赛链接 A. Ahahahahahahahaha注意到 01 串一定有 $\\ge n/2$ 个 0 或者 1，依此构造即可。 1234567891011121314151617181920212223242526int c = 0; memset(a, 0, sizeof(a));n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), c += (a[i] == 0);n /= 2;if(n &amp; 1){ if(c &gt;= n){ printf(&quot;%d&quot;, n), puts(&quot;&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;0 &quot;);puts(&quot;&quot;); } else if(!c){ printf(&quot;%d&quot;, n &lt;&lt; 1), puts(&quot;&quot;); for(int i = 1; i &lt;= n * 2; i++) printf(&quot;1 &quot;); puts(&quot;&quot;); } else{ printf(&quot;%d&quot;, n + 1), puts(&quot;&quot;); for(int i = 1; i &lt;= n + 1; i++) printf(&quot;1 &quot;); puts(&quot;&quot;); } continue;}if(c &gt;= n){ printf(&quot;%d&quot;, n), puts(&quot;&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;0 &quot;);}else{ printf(&quot;%d&quot;, n), puts(&quot;&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;1 &quot;);} B. Big Vova$O(n^2)$ 贪心即可。 1234567891011121314for(int i = 1; i &lt;= n; i++) usd[i] = 0;n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read();int lst = 0;for(int i = 1; i &lt;= n; i++) { int mx = 0; for(int j = 1; j &lt;= n; j++){ if(usd[j]) continue; if(mx == 0) mx = j; if(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j; } usd[mx] = 1, b[i] = a[mx]; lst = gcd(lst, a[mx]);}for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]); puts(&quot;&quot;); C. Chocolate Bunny连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\\max(a,b)=\\min(p_x,p_y)$，依此模拟即可。 12345678910111213n = read(); int lst = 1;for(int i = 2; i &lt;= n; i++){ int x, y, z; printf(&quot;? %d %d\\n&quot;, lst, i); fflush(stdout); x = read(); printf(&quot;? %d %d\\n&quot;, i, lst); fflush(stdout); y = read(), z = max(x, y); if(x &lt; y) a[i] = z ; else a[lst] = z, lst = i;}for(int i = 1; i &lt;= n; i++) vis[ a[i] ]++;for(int i = 1; i &lt;= n; i++) if(!vis[i]) {a[lst] = i; break;}printf(&quot;! &quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); fflush(stdout); D. Discrete Centrifugal Jumps理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。 12345678910111213141516171819202122232425n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); memset(f, 0x3f, sizeof(f)), f[1] = 0;stk1[++top1] = 1, stk2[++top2] = 1;for(int i = 2; i &lt;= n; i++){ while(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i]){ f[i] = min(f[i], f[ stk1[top1] ]); while(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - 1] ]) top1--; if(top1) top1--; } if(top1) f[i] = min(f[i], f[ stk1[top1] ]); stk1[++top1] = i; while(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i]){ f[i] = min(f[i], f[ stk2[top2] ]); while(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - 1] ]) top2--; if(top2) top2--; } if(top2) f[i] = min(f[i], f[ stk2[top2] ]); stk2[++top2] = i; f[i]++;}printf(&quot;%lld&quot;, f[n]); E. Egor in the Republic of Dagestan算是比较裸的一道 E 题了……设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\\gets v$，应当有 $f[u,c]\\gets \\max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\\gets v$ 的颜色。注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 1e6 + 6;const int INF = 0x3f3f3f3f;class fs {public: int to,nxt,tp; void init(int t,int n,int p) {to = t, nxt = n, tp = p;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m;class DJ {public: int v, id; bool operator &lt; (const DJ &amp;a) const {return v &gt; a.v;}} ;DJ mk(int a, int b) {DJ d; d.v = a, d.id = b; return d;}int d[CN][2]; bool vis[CN]; priority_queue&lt;DJ&gt; Q;void SP(int u){ memset(d, 0x3f, sizeof(d)), Q.push( mk(d[u][0] = d[u][1] = 0, u) ); while(!Q.empty()){ u = Q.top().id, Q.pop(); if(vis[u]) continue; vis[u] = true; int dis = max(d[u][0], d[u][1]); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to, c = E[k].tp, cur; if(vis[v]) continue; if(d[v][c] &gt; dis + 1){ d[v][c] = dis + 1, cur = max(d[v][0], d[v][1]); if(cur &lt; INF) Q.push( mk(cur, v) ); } } }}int main(){ n = read(), m = read(); for(int i = 1; i &lt;= m; i++) {int u = read(), v = read(), t = read(); add(v, u, t);} SP(n); if(max(d[1][0], d[1][1]) &lt; INF) printf(&quot;%d&quot;, max(d[1][0], d[1][1])), puts(&quot;&quot;); else puts(&quot;-1&quot;); for(int i = 1; i &lt;= n; i++) putchar(d[i][0] &gt; d[i][1] ? '0' : '1');}","link":"/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"},{"title":"「解题报告」洛谷十月月赛 II","text":"又是垫底的一天啊，凉心出题人再次让我感受到了没技术的弱小，不过还是水个题解吧…… A 梦中梦与不再有梦签到结论题。首先 $n=1$ 时答案为 0，$n=2$ 时答案为 1，然后考虑 $n\\ge 3$： 当 $n$ 是奇数时，由于图上不存在奇点，那么必然有欧拉回路，答案为 $\\dbinom{n}{2}$ 当 $n$ 是偶数时，因 $n\\ge 3$，则图上存在多于两个奇点。我们只能保留其中两个，那么删掉 $n/2-1$ 个奇点，答案是 $\\dbinom{n}{2}-n/2+1$ 代码： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint read(){ int s = 0, ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') {if(c == '-') ne = -1; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int T, n;int work(){ if(n == 1) return puts(&quot;0&quot;), 0; if(n == 2) return puts(&quot;1&quot;), 0; if(n &amp; 1) return printf(&quot;%lld\\n&quot;, n * (n - 1) / 2), 0; return printf(&quot;%lld\\n&quot;, (n * (n - 1) / 2) - (n / 2) + 1), 0;}signed main() {T = read(); while(T--){n = read(), work();}} B 深海少女与胖头鱼设 $f(n,m)$ 为当前场面剩余 $n$ 个带盾的和 $m$ 个不带盾的时，剩余操作次数的期望。显然有：$$ \\begin{align} f(n,0) &amp;=2+\\dfrac{1}{n}f(n-1,0)+\\dfrac{n-1}{n}f(n-1,1)\\tag 1 \\newline f(n,1)&amp;=1+\\dfrac{n}{n+1}f(n,1)+\\dfrac{1}{n+1}f(n,0)\\tag 2 \\newline f(n,m)&amp;=1+\\dfrac{m}{n+m}f(n,m-1)+\\dfrac{n}{n+m}f(n+m-1,1)\\tag 3 | m&gt;1 \\end{align} $$ 我们令 $(2)$ 代 $(1)$ 得：$$ \\begin{aligned} f(n,0)&amp;=n+1+f(n-1,0) \\newline f(n,1)&amp;=n+1+f(n,0) \\end{aligned} $$ 归纳可得：$$ f(n,0)=\\dfrac{n(n+3)}{2},f(n,1)=n+1+\\dfrac{n(n+3)}{2} $$ 于是 $m\\le 1$ 的情况做完了，对于 $m&gt;1$ 的情况，根据 $(3)$ 式，容易发现此时分成了 $f(·,m-1)$ 和 $f(·,1)$ 两部分，然后就可以愉快的 $O(m)$ 递推了。 代码，常数不小： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int P = 998244353;const int i2 = 499122177;const int CN = 1e6 + 60;int read(){ int s = 0, ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') {if(c == '-') ne = -1; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int qp(int a, int b){ int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int add(int a, int b) {return a + b &gt;= P ? a + b - P : a + b;}int n, nn, nN, m, f[CN];signed main() { n = read() % P, m = read(), nn = 1ll * n * i2 % P, nN = add(n, 1); f[0] = 1ll * nn * (n + 3) % P; for(int i = 1; i &lt;= m; i++){ int M = add(n, i), t; t = add(add(M, 1), P - (2ll * qp(M, P - 2) % P)); t = 1ll * t * nn % P; f[i] = add(t, nN); t = 1ll * i * qp(add(n, i), P - 2) % P; t = 1ll * t * f[i - 1] % P; f[i] = add(f[i], t); } printf(&quot;%d&quot;, f[m]);} C 蝴蝶与花不会/kk D 象棋与马首先考虑 $p(a,b)$ 什么时候能等于 1。 显然有一个必要条件是 $(a,b)=1$，但是样例就已经说明了这不是充分的；这时候打个表就会发现第二个条件是 $|a-b| \\text{ mod } 2 = 1$。 于是就变成了求 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n [(i,j)=1][|i-j|\\text{ mod }2=1]$，显然原式等于 $2\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^i [(i,j)=1][|i-j|\\text{ mod }2=1]$，我们考虑求后面这个和式。 考虑对于偶数 $i$，因为偶数不可能和偶数互质，那么其贡献应当是 $\\varphi(i)$。对于奇数 $i$，因为与其互质的数有一半是奇数，一半是偶数，所以其贡献应当是 $\\dfrac{\\varphi(i)}{2}$。所以我们在求：$$ \\sum\\limits_{i=1}^n [i\\text{ mod }2=0]\\varphi(i)+\\sum\\limits_{i=1}^n [i\\text{ mod }2=1]\\dfrac{\\varphi(i)}{2} $$ 考虑有等式： $$\\sum\\limits_{i=1}^n \\varphi(i)[i\\bmod 2=0]=\\sum\\limits_{i=1}^{\\lfloor n/2\\rfloor}\\varphi(i)[i\\bmod 2=1] + 2\\sum\\limits_{i=1}^{\\lfloor n/2\\rfloor}\\varphi(i)[i\\bmod 2=0]$$ 即是考虑新增一个因子 $2$ 的贡献，那么直接杜教筛即可 $O(n^{2/3})$。 大常数辣鸡代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define ULL unsigned long longconst int CN = 1e7 + 10;ULL read(){ ULL s = 0; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()); for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s;}int T, pr[CN], mu[CN]; ULL p, p0, p1, phi[CN], phi0[CN], phi1[CN]; bool np[CN];class PAIR {public: ULL p, p0, p1;};PAIR mp(ULL a, ULL b, ULL c) {PAIR o; o.p = a, o.p0 = b, o.p1 = c; return o;}class MAP{ public: static const int P = 191011109, CN = 5e6 + 10; class fs {public: ULL key; int nxt; PAIR val;} E[CN]; int ecnt, hd[CN]; PAIR&amp; operator [] (const ULL &amp;o){ ULL A = o &gt;&gt; 25, B = o &amp; ((1 &lt;&lt; 25) - 1), u = (A ^ B ^ P) % CN; for(int k = hd[u]; k; k = E[k].nxt) if(E[k].key == o) return E[k].val; E[++ecnt].key = o, E[ecnt].nxt = hd[u], hd[u] = ecnt; return E[ecnt].val; } bool count(const ULL &amp;o){ ULL A = o &gt;&gt; 25, B = o &amp; ((1 &lt;&lt; 25) - 1), u = (A ^ B ^ P) % CN; for(int k = hd[u]; k; k = E[k].nxt) if(E[k].key == o) return 1; return 0; }} vis;void solve(ULL n, ULL &amp;p, ULL &amp;p0, ULL &amp;p1){ if(n &lt;= int(1e7)) return (void)(p = phi[n], p0 = phi0[n], p1 = phi1[n]); if(vis.count(n)) return (void)(p = vis[n].p, p0 = vis[n].p0, p1 = vis[n].p1); p = n &amp; 1 ? ((n + 1) / 2) * n : (n / 2) * (n + 1), p0 = p1 = 0; ULL P, P0, P1; for(ULL l = 2; l &lt;= n; l++){ ULL r = n / (n / l); solve(n / l, P, P0, P1); if(l == 2) p0 = (P0 &lt;&lt; 1) + P1; p -= (r - l + 1) * P, l = r; } p1 = p - p0, vis[n] = mp(p, p0, p1);}int main(){ int n = 1e7; np[1] = phi[1] = mu[1] = 1; for(int i = 2; i &lt;= n; i++){ if(!np[i]) pr[++pr[0]] = i, mu[i] = -1, phi[i] = i - 1; for(int j = 1; j &lt;= pr[0] &amp;&amp; i * pr[j] &lt;= n; j++){ int x = i * pr[j]; np[x] = 1; if(i % pr[j]) mu[x] = -mu[i], phi[x] = phi[i] * (pr[j] - 1); else {phi[x] = phi[i] * pr[j]; break;} } } for(int i = 2; i &lt;= n; i++) i &amp; 1 ? phi1[i] = phi[i] : phi0[i] = phi[i]; for(int i = 1; i &lt;= n; i++) mu[i] += mu[i - 1], phi[i] += phi[i - 1], phi1[i] += phi1[i - 1], phi0[i] += phi0[i - 1]; T = read(); while(T--) solve(read(), p, p0, p1), printf(&quot;%llu\\n&quot;, (p0 &lt;&lt; 1) + p1); return 0;}","link":"/2020/10/18/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B%20II/"},{"title":"「解题报告」牛客小白月赛 27","text":"又是签到走人的一天…… 比赛链接 A 巨木之森签到题，对每个点维护一个到叶子的最长距离，随便怎么搞搞就行了。本人脑子笨，写了个线段树，复杂度 $O(n\\log n)$，实际上有严格 $O(n)$ 解法。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt,d; void init(int t,int n,int dd) {to = t, nxt = n, d = dd;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}class SGT { public: int d[CN &lt;&lt; 2], tag[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void pd(int l, int r, int k){ d[lc] += tag[k], d[rc] += tag[k], tag[lc] += tag[k], tag[rc] += tag[k], tag[k] = 0; } void md(int l, int r, int k, int s, int t, int x){ if(s &lt;= l &amp;&amp; r &lt;= t) return (void)(tag[k] += x, d[k] += x); int m = (l + r) &gt;&gt; 1; if(tag[k]) pd(l, r, k); if(s &lt;= m) md(l, m, lc, s, t, x); if(m &lt; t) md(m + 1, r, rc, s, t, x); d[k] = max(d[lc], d[rc]); } void upd(int l, int r, int k){ if(l == r) return; int m = (l + r) &gt;&gt; 1; if(tag[k]) pd(l, r, k); upd(l, m, lc), upd(m + 1, r, rc); d[k] = max(d[lc], d[rc]); } int qu() {return d[1];}} D;int n, m, sum = 0, d[CN], id[CN], sz[CN], idx = 0, mxd[CN];void bd(int u, int p){ id[u] = ++idx, sz[u] = 1; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) d[v] = d[u] + E[k].d, bd(v, u), sz[u] += sz[v]; }}void dfs(int u, int p){ mxd[u] = D.qu(); for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p){ D.md(1, n, 1, 1, n, E[k].d), D.md(1, n, 1, id[v], id[v] + sz[v] - 1, -2ll * E[k].d); dfs(v, u); D.md(1, n, 1, 1, n, -E[k].d), D.md(1, n, 1, id[v], id[v] + sz[v] - 1, 2ll * E[k].d); } }}signed main(){ n = read(), m = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w), sum += w; } sum = 2ll * sum; bd(1, 0); for(int i = 1; i &lt;= n; i++) D.md(1, n, 1, id[i], id[i], d[i]); dfs(1, 0); for(int i = 1; i &lt;= n; i++) mxd[i] = sum - mxd[i]; sort(mxd + 1, mxd + n + 1); int ans = 0, sum = 0, p = 1; while(p &lt;= n &amp;&amp; sum + mxd[p] &lt;= m) sum += mxd[p++], ans++; printf(&quot;%lld&quot;, ans);} B 乐团派对考察快速排序以及输入输出。代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, a[CN];bool cmp(int a, int b) {return a &gt; b;}int main(){ n = read(); for(int i = 1; i &lt;= n; i++) {a[i] = read(); if(a[i] &gt; n) return puts(&quot;-1&quot;), 0;} sort(a + 1, a + n + 1, cmp); int p = 1, ans = 0; while(p &lt;= n) {if(p + a[p] &lt;= n + 1) ans++, p += a[p]; else p++;} printf(&quot;%d&quot;, ans);} D 巅峰对决线段树板子题。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}class SGT { public: int d[CN &lt;&lt; 2], mx[CN &lt;&lt; 2], mn[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void bd(int l, int r, int k, int *a){ if(l == r) return (void)(mx[k] = mn[k] = d[k] = a[l]); int m = (l + r) &gt;&gt; 1; bd(l, m, lc, a), bd(m + 1, r, rc, a); d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]); } void md(int l, int r, int k, int p, int x){ if(l == r) return (void)(mx[k] = mn[k] = d[k] = x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(l, m, lc, p, x); else md(m + 1, r, rc, p, x); d[k] = gcd(d[lc], d[rc]), mx[k] = max(mx[lc], mx[rc]), mn[k] = min(mn[lc], mn[rc]); } int qu(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return d[k]; int m = (l + r) &gt;&gt; 1, ans = 0; if(s &lt;= m) ans = gcd(qu(l, m, lc, s, t), ans); if(m &lt; t) ans = gcd(qu(m + 1, r, rc, s, t), ans); return ans; } int qum(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return mx[k]; int m = (l + r) &gt;&gt; 1, ans = 0; if(s &lt;= m) ans = max(qum(l, m, lc, s, t), ans); if(m &lt; t) ans = max(qum(m + 1, r, rc, s, t), ans); return ans; } int qun(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return mn[k]; int m = (l + r) &gt;&gt; 1, ans = INF; if(s &lt;= m) ans = min(qun(l, m, lc, s, t), ans); if(m &lt; t) ans = min(qun(m + 1, r, rc, s, t), ans); return ans; }} D;int n, q, a[CN];bool ck(int s, int t){ if(s == t) return true; int MX = D.qum(1, n, 1, s, t), MN = D.qun(1, n, 1, s, t); if((MX - MN) ^ (t - s)) return false; int G = D.qu(1, n, 1, s, t); return G ^ 1 ? 0 : 1;}int main(){ n = read(), q = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); D.bd(1, n, 1, a); while(q--){ int op = read(), x = read(), y = read(); if(op == 1) D.md(1, n, 1, x, y); else ck(x, y) ? puts(&quot;YES&quot;) : puts(&quot;NO&quot;); }} F 核弹剑仙傻题。代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CN = 1e5 + 5;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, f[CN]; bool vis[CN];void dfs(int u){ vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!vis[v]) dfs(v); }}int cnt(int u){ memset(vis, 0, sizeof(vis)); dfs(u); int ans = 0; for(int i = 1; i &lt;= n; i++) if(vis[i]) ans++; return ans - 1;}int main(){ n = read(), m = read(); for(int i = 1; i &lt;= m; i++){ int u = read(), v = read(); add(v, u); } for(int i = 1; i &lt;= n; i++) printf(&quot;%d&quot;, cnt(i)), puts(&quot;&quot;);}","link":"/2020/08/22/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B%2027/"},{"title":"「解题报告」牛客练习赛68","text":"牛客的题还是比较板啊，像我这样的菜鸡都能打到 rk30？？？/jk A 牛牛的mex主席树模板题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT { public: int d[CN * 50], rt[CN], ch[CN * 50][2], idx; SGT() {idx = 0;} #define lc ch[u][0] #define rc ch[u][1] int make() {return ++idx;} void ins(int &amp;u, int v, int l, int r, int p){ if(!u) u = make(); if(l == r) return (void)(d[u] = d[v] + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) rc = ch[v][1], ins(lc, ch[v][0], l, m, p); else lc = ch[v][0], ins(rc, ch[v][1], m + 1, r, p); d[u] = d[lc] + d[rc]; } int qu(int u, int v, int l, int r){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = d[lc] - d[ ch[v][0] ]; if(s &lt; m - l + 1) return qu(lc, ch[v][0], l, m); else return qu(rc, ch[v][1], m + 1, r); }} D;int n, q, ai;int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), q = read(); for(int i = 1; i &lt;= n; i++) ai = read(), D.ins(D.rt[i], D.rt[i - 1], 1, n, ai + 1); int x, y; while(q--) x = read(), y = read(), printf(&quot;%d&quot;, y - x + 1 &lt; n ? D.qu(D.rt[y], D.rt[x - 1], 1, n) - 1 : n), puts(&quot;&quot;);} B 牛牛的算术傻题，随便推一推柿子，特判下就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5 + 5;const int P = 199999;int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}#define i2 qp(2, P - 2)int t, f[CN], p[CN];char ch[CN];int cal(int x) { int squ = 1ll * x * x % P; squ = 1ll * squ * (x + 1) % P; return squ;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); std::ios::sync_with_stdio(false); for(int i = 1; i &lt; P; i++) f[i] = (f[i - 1] + cal(i)) % P; p[0] = 1; for(int i = 1; i &lt; P; i++) p[i] = 1ll * p[i - 1] * i % P, p[i] = 1ll * p[i] * f[i] % P, p[i] = 1ll * p[i] * i2 % P; cin &gt;&gt; t; while(t--){ cin &gt;&gt; ch; int l = strlen(ch); if(l &gt;= 6) {puts(&quot;0&quot;); continue;} int n = 0; for(int i = 0; i &lt; l; i++) n = n * 10 + (ch[i] - '0'); if(n &gt;= P) puts(&quot;0&quot;); else printf(&quot;%d&quot;, p[n]), puts(&quot;&quot;); }} C 牛牛的无向图容易想到把边和询问都按权值排序，然后依次加边，能加就加，然后对于每个连通块就可以 $O(1)$ 算答案了。维护一个并查集就解决了，时间复杂度 $O(m\\log m + (m + q)\\alpha(n))$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int CN = 5e5 + 5;class DSU { public: int fa[CN]; DSU() {for(int i = 1; i &lt;= 100000; i++) fa[i] = i;} int fd(int x) {return fa[x] ^ x ? fa[x] = fd(fa[x]) : x;}} C;int n, m, q, LIM, X[CN], Y[CN], W[CN], id[CN], pos = 1, L[CN], sz[CN]; LL ans[CN];bool cmp(int i, int j) {return W[i] &lt; W[j];}LL cal(int x) {return 1ll * x * (x - 1) / 2ll;}unsigned int SA, SB, SC; unsigned int rng61(){ SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; unsigned int t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC;}void gen(){ scanf(&quot;%d%d%d%u%u%u%d&quot;, &amp;n, &amp;m, &amp;q, &amp;SA, &amp;SB, &amp;SC, &amp;LIM); for(int i = 1; i &lt;= m; i++){ X[i] = rng61() % n + 1; Y[i] = rng61() % n + 1; W[i] = rng61() % LIM; id[i] = i; } for(int i = 1; i &lt;= q; i++){ L[i] = rng61() % LIM; }}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); gen(); sort(L + 1, L + q + 1), sort(id + 1, id + m + 1, cmp); for(int i = 1; i &lt;= n; i++) sz[i] = 1; for(int i = 1; i &lt;= q; i++){ LL cur = ans[i - 1]; while(W[ id[pos] ] &lt;= L[i] &amp;&amp; pos &lt;= m){ int u = X[ id[pos] ], v = Y[ id[pos] ], fu = C.fd(u), fv = C.fd(v); if(fu ^ fv) cur += 1ll * sz[fu] * sz[fv], C.fa[fv] = fu, sz[fu] += sz[fv]; pos++; } ans[i] = cur; } for(int i = 1; i &lt;= q; i++) ans[0] ^= ans[i]; printf(&quot;%lld&quot;, ans[0]);} D 牛牛的粉丝显然是个矩乘优化 DP 转移，设 $f[k,i]$ 表示 $k$ 轮后点 $i$ 的答案这样，直接做复杂度 $O(n^3\\log k)$，好像不太行。然后就没有想法了…… upd：转移矩阵是循环的啊……既然是循环的就没必要 $O(n^3)$ 算了……存下第一行来矩乘就变卷积了……于是做到 $O(n^2\\log k)$……甚至还可以 $O(n\\log n\\log k)$ /jk…… E 牛牛的字符串回文不会处理啊……看上去我只会 $O(n^3)$ 的辣鸡 DP，也许可以通过一些字符串算法优化到 $O(n^2)$？不可做不可做。 upd：并没有什么神仙算法……所以说还是要观察性质……","link":"/2020/08/28/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B68/"},{"title":"「题解」CME","text":"爆炸oj.png…… 一 题目 Source DescriptionsLet’s denote correct match equation (we will denote it as CME) an equation a+b=c there all integers a, b and c are greater than zero.For example, equations 2+2=4 (||+||=||||) and 1+2=3 (|+||=|||) are CME but equations 1+2=4 (|+||=||||), 2+2=3 (||+||=|||), and 0+1=1 (+|=|) are not. Now, you have n matches. You want to assemble a CME using all your matches. Unfortunately, it is possible that you can’t assemble the CME using all matches. But you can buy some extra matches and then assemble CME!For example, if n=2, you can buy two matches and assemble |+|=||, and if n=5 you can buy one match and assemble ||+|=|||. Calculate the minimum number of matches which you have to buy for assembling CME.Note, that you have to answer q independent queries. InputThe first line contains one integer q (1≤q≤100) — the number of queries.The only line of each query contains one integer n (2≤n≤109) — the number of matches. OutputFor each test case print one integer in single line — the minimum number of matches which you have to buy for assembling CME. 二 题解简化一下题面：给定 n ，设 a+b+c = n+r。求得最小的 r ，使得 a+b = c。用 c 代式一里面的 a+b ，则 2c = n+r。即 2c-r = n，n 是已知的，于是这个东西看起来很像exgcd。 实际上不需要exgcd，这个不定方程总有特解：c = 0, r = -n。根据一堆奇奇怪怪的东西我们得到：c在对(-1/gcd(2,-1))取模意义下定义，b在对(2/gcd(2,-1))取模意义下定义。即c ≡ 0 (mod 1), r ≡ -n (mod -2)。 然后再回想一下 c 和 r 实际上是有取值范围的，因为 a,b ⩾ 1，所以 c ⩾ 2，并且有 r ⩾ 0。 然后不动脑子你就可以写出这样一个 while ： 1234int c = 0,r = -n,cnt;while(c&lt;2 || r&lt;0){ c += 1; r += 2;} 然后输出 r 就好了，但是可惜它跑得不够快。 然后动一动脑子你就会发现上面那个 while 可以直接作除法来解决，就是这样： 1234567891011int c = 0,r = -n,cnt;if(!(n % 2)){ cnt = n/2; r = 0;}else{ cnt = (n/2) + 1; r = 1;}if(c+cnt &lt; 2){ int k = 2 - c - cnt; r += 2*k;} 然后就做完了。 代码: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; int q,n; int main(){ scanf(&quot;%d&quot;,&amp;q); while(q--){ scanf(&quot;%d&quot;,&amp;n); int c = 0,r = -n,cnt; /* while(c&lt;2 || r&lt;0){ c += 1; r += 2; } */ if(!(n % 2)){ cnt = n/2; r = 0; } else{ cnt = (n/2) + 1; r = 1; } if(c+cnt &lt; 2){ int k = 2 - c - cnt; r += 2*k; } printf(&quot;%d\\n&quot;,r); } return 0;}","link":"/2019/10/07/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DCME/"},{"title":"「题解」AC自动机（简单版）","text":"虽然说这题是AC自动机吧…但是后缀数组也能解。在这里提供一个清新的后缀数组解法。 后缀数组后缀数组是个好东西啊，通过这个工具可以解决许多类型的字符串问题，这里简单介绍一下： 形式化地，对于一个长度为 $n$ 的字符串 $s$，它的形如 $s[i:n]$ 的子串被称作 $s$ 的后缀。 容易发现 $s$ 一共有 $n$ 个后缀，不妨记 $s[i:n]$ 为后缀 $i$，将所有的后缀排序后，顺序写下后缀的编号，就得到了后缀数组 (Suffix Array)。 举个例子，对 $s=ababa$，其后缀有 $a,ba,aba,baba,ababa$，排序后得到 $a,aba,ababa,ba,baba$，依次写下其编号，得到后缀数组为 $5,3,1,2,4$。 朴素求后缀数组是 $O(n^2 \\log n)$ 的，这显然是不太好的。通过倍增法去求，容易发现倍增的过程是某种双关键字排序，那么对其进行基数排序，可做到 $O(n \\log n)$。具体的实现超出了本篇题解的范畴，请移步 后缀排序。 回到本题容易发现，一个串 $s$ 若能与 $t$ 匹配，那么它必然是 $t$ 的 某个后缀的前缀。我们可以快速把所有后缀都排序，这样后缀就是有序的了，可以通过二分来找 $s$ 是否与 $t$ 匹配。 具体实现上，因为后缀的长度和是 $O(n^2)$ 级别的，所以不能把他们全部搞出来（会MLE）。实际上只需要写一个 cmp() 函数来比较字符串大小就好了，实现起来比较清新易懂。 复杂度因为每次要二分，所以整体多了一个 $\\log$，不过均摊下来跑的非常快，常数比AC自动机大了不到一半。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* fake-acam.cpp */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 1e6 + 6;char t[CN], s[CN];string mem[CN];int sa[CN], rk[CN &lt;&lt; 1], prk[CN &lt;&lt; 1], id[CN], px[CN], cnt[CN];void SA(int n){ int m = max(n, 300); for(int i = 1;i &lt;= n;i++) rk[i] = t[i - 1]; for(int i = 1;i &lt;= n;i++) cnt[ rk[i] ] ++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i; for(int w = 1; w &lt; n; w &lt;&lt;= 1){ memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] + w ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memset(cnt, 0, sizeof(cnt)); for(int i = 1;i &lt;= n;i++) id[i] = sa[i]; for(int i = 1;i &lt;= n;i++) cnt[ px[i] = rk[ id[i] ] ]++; for(int i = 1;i &lt;= m;i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memcpy(prk, rk, sizeof(rk)); m = 0; for(int i = 1;i &lt;= n;i++) if(prk[ sa[i] ] == prk[ sa[i - 1] ] &amp;&amp; prk[ sa[i] + w ] == prk[ sa[i - 1] + w ]) rk[ sa[i] ] = m; else rk[ sa[i] ] = ++m; if(m == n) break; }}int n, lt;// 判断 a[] &lt; b[]inline int le(char *a, char *b, int la,int lb){ int p = 0; while(a[p] == b[p] &amp;&amp; p &lt; min(la, lb)) p++; if(p == lb) return -1; if(p == la) return true; return a[p] &lt; b[p];}int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for(int i = 1;i &lt;= n;i++) cin &gt;&gt; mem[i]; cin &gt;&gt; t; lt = strlen(t); SA(lt); int cnt = 0; for(int i = 1;i &lt;= n;i++){ int ls = mem[i].size(); s[ls] = '\\0'; for(int j = 0;j &lt; ls;j++) s[j] = mem[i][j]; int l = 1, r = lt, m; bool found = false; while(l &lt; r){ m = (l + r) &gt;&gt; 1; int leq = le(t + sa[m] - 1, s, lt - sa[m] + 1,ls); if(leq == -1) {found = true; break;} else if(leq) l = m + 1; else r = m; } cnt += found ? 1 : 0; } printf(&quot;%d&quot;, cnt);}","link":"/2020/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"},{"title":"「题解」Complete Tripartite","text":"“完全”的三分图的存在性判定问题…… 一 题目 Source DescriptionsYou have a simple undirected graph consisting of n vertices and m edges. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. Let’s make a definition.Let v1 and v2 be two some nonempty subsets of vertices that do not intersect. Let f(v1,v2) be true if and only if all the conditions are satisfied:There are no edges with both endpoints in vertex set v1.There are no edges with both endpoints in vertex set v2.For every two vertices x and y such that x is in v1 and y is in v2, there is an edge between x and y. Create three vertex sets (v1, v2, v3) which satisfy the conditions below;All vertex sets should not be empty.Each vertex should be assigned to only one vertex set.f(v1,v2), f(v2,v3), f(v3,v1) are all true.Is it possible to create such three vertex sets? If it’s possible, print matching vertex set for each vertex. InputThe first line contains two integers n and m (3≤n≤105, 0≤m≤min(3⋅105,n(n−1)2)) — the number of vertices and edges in the graph.The i-th of the next m lines contains two integers ai and bi (1≤ai&lt;bi≤n) — it means there is an edge between ai and bi. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. OutputIf the answer exists, print n integers. i-th integer means the vertex set number (from 1 to 3) of i-th vertex. Otherwise, print −1.If there are multiple answers, print any. 二 题解就是给你一张图，让你判定能不能把这张图上找出三个互异点集，使它们的并是总点集，且有任意两点集中的点总有边相连。实际上可以看成一个”完全“（任意两点间都有边相连）的三分图。 显然，若图不连通，则必定无解。 然后在保证图联通的情况下，对于一个可行的极大的点集，其中的每个点能到达的 所有点 组成的点集总是一样的。换句话说，能到达的点集相同的点总属于同一个可行的极大的点集。那么只需要把这些点拎出来就好了，最后形成的点集个数如果为 3 就表明恰好有解，再给每个点集编号就好了。 也可以推广到完全 k 分图的判定 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 5e5+5;class edge{ public: int id; vector&lt;int&gt; to; // to : 每个点能到达的点集}E[CN];class ufs{ // 判联通 public: int fa[CN]; ufs() {for(int i=1;i&lt;=300001;i++) fa[i] = i;} int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} bool exm(int x,int y) {return find(x) != find(y);} void merge(int x,int y) {fa[find(x)] = find(y);} }S;/* v define */int n,m;int bel[CN];/* */bool CheCon(){ // 判联通 for(int i=1;i&lt;=n;i++) S.find(i); int R = S.fa[1]; for(int i=2;i&lt;=n;i++) if(S.fa[i] != R) return false; return true;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); E[x].to.push_back(y); E[y].to.push_back(x); if(S.exm(x, y)) S.merge(x,y); } if(CheCon()){ for(int i=1;i&lt;=n;i++) sort(E[i].to.begin(), E[i].to.end()); // 排序，方便下面判等 for(int i=1;i&lt;=n;i++){ // 相当于一个离散化的过程 if(!bel[i]){ bel[i] = ++bel[0]; for(int j=1;j&lt;=n;j++) if(E[i].to == E[j].to) bel[j] = bel[0]; } } if(bel[0] == 3){ for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,bel[i]); } else printf(&quot;-1&quot;); } else printf(&quot;-1&quot;); return 0;}","link":"/2019/10/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DComplete%20Tripartite/"},{"title":"「题解」Duck and Dove","text":"二维线段树（线段树套线段树）…… 注：此处题目应为“Luck and Love” 一 题目 原题链接 描述世界上上最远的距离不是相隔天涯海角而是我在你面前可你却不知道我爱你 ―― 张小娴 前段日子，枫冰叶子给Wiskey做了个征婚启事，聘礼达到500万哦，天哪，可是天文数字了啊，不知多少MM蜂拥而至，顿时万人空巷，连扫地的大妈都来凑热闹来了。―_―|||由于人数太多，Wiskey实在忙不过来，就把统计的事情全交给了枫冰叶子，自己跑回家休息去了。这可够枫冰叶子忙的了，他要处理的有两类事情，一是得接受MM的报名，二是要帮Wiskey查找符合要求的MM中缘分最高值。 输入本题有多个测试数据，第一个数字M，表示接下来有连续的M个操作，当M＝0时处理中止。接下来是一个操作符C。当操作符为‘I’时，表示有一个MM报名，后面接着一个整数，H表示身高，两个浮点数，A表示活泼度，L表示缘分值。 （100&lt;=H&lt;=200， 0.0&lt;=A，L&lt;=100.0）当操作符为‘Q’时，后面接着四个浮点数，H1，H2表示身高区间，A1，A2表示活泼度区间，输出符合身高和活泼度要求的MM中的缘分最高值。 （100&lt;=H1，H2&lt;=200， 0.0&lt;=A1，A2&lt;=100.0）所有输入的浮点数，均只有一位小数。 输出对于每一次询问操作，在一行里面输出缘分最高值，保留一位小数。对查找不到的询问，输出-1。 二 题解二维线段树模板。在一棵线段树的每个节点上，再维护一棵线段树。细节见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define DB doubleconst int CN = 110;const DB EPS = 1e-7;int Q;/*h的范围是100~200，也就是说这段区间有101个整点*//*a的范围是0.0~100.0，先x10，就变成了1001个整点*/int H = 101,A = 1001; //线段树范围: [1,H] x [1,A]//(sugment tree)^2DB d[4*CN][4*CN*10]; //维护节点的值，要开四倍空间void build(){ for(int i=1;i&lt;=4*H;i++) for(int j=1;j&lt;=4*A;j++) d[i][j] = -1; //初始化}void sub_modify(int sl,int sr,int sk,int fk,int sa,DB sL){ //第二维修改 if(sl == sr) return (void)(d[fk][sk] = max(d[fk][sk], sL)); int sm = (sl+sr)&gt;&gt;1; if(sa &lt;= sm) sub_modify(sl,sm,sk&lt;&lt;1,fk,sa,sL); if(sm &lt; sa) sub_modify(sm+1,sr,sk&lt;&lt;1|1,fk,sa,sL); d[fk][sk] = max(d[fk][sk&lt;&lt;1], d[fk][sk&lt;&lt;1|1]);}void modify(int l,int r,int k,int h,int a,DB L){ //第一维修改 sub_modify(1,A,1,k,a,L); //注意走过的每个节点都要对第二维进行更新 //向下递归 if(l == r) return; int m = (l+r)&gt;&gt;1; if(h &lt;= m) modify(l,m,k&lt;&lt;1,h,a,L); if(m &lt; h) modify(m+1,r,k&lt;&lt;1|1,h,a,L);}DB sub_query(int sl,int sr,int sk,int fk,int sas,int sat){ //第二维查询 if(sas&lt;=sl &amp;&amp; sr&lt;=sat) return d[fk][sk]; int sm = (sl+sr)&gt;&gt;1; DB srec = -1; if(sas &lt;= sm) srec = max(srec, sub_query(sl,sm,sk&lt;&lt;1,fk,sas,sat)); if(sm &lt; sat) srec = max(srec, sub_query(sm+1,sr,sk&lt;&lt;1|1,fk,sas,sat)); return srec;} DB query(int l,int r,int k,int hs,int ht,int as,int at){ //第一维查询 if(hs&lt;=l &amp;&amp; r&lt;=ht) return sub_query(1,A,1,k,as,at); //确定了第一维中的区间，再去第二维查询 int m = (l+r)&gt;&gt;1; DB rec = -1; if(hs &lt;= m) rec = max(rec, query(l,m,k&lt;&lt;1,hs,ht,as,at)); if(m &lt; ht) rec = max(rec, query(m+1,r,k&lt;&lt;1|1,hs,ht,as,at)); return rec; }int main(){ scanf(&quot;%d&quot;,&amp;Q); while(Q){ build(); while(Q--){ char c; cin&gt;&gt;c; if(c == 'I'){ int h; DB a,l; scanf(&quot;%d%lf%lf&quot;,&amp;h,&amp;a,&amp;l); (a *= 10) += 1; h -= 99; //为了让区间端点变成整数 modify(1,H,1,h,(int)a,l); } else{ int h1,h2; DB a1,a2; scanf(&quot;%d%d%lf%lf&quot;,&amp;h1,&amp;h2,&amp;a1,&amp;a2); if(h1 &gt; h2) swap(h1,h2); //坑点1 if(a1 &gt; a2) swap(a1,a2); h1 -= 99; h2 -= 99; (a1 *= 10) += 1; (a2 *= 10) += 1; DB ans = query(1,H,1,h1,h2,(int)a1,(int)a2); if(ans &lt; -EPS) printf(&quot;-1\\n&quot;); //坑点2 输出-1而不是-1.0 else printf(&quot;%.1lf\\n&quot;,ans); } } scanf(&quot;%d&quot;,&amp;Q); } return 0;}","link":"/2019/07/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DDuck%20and%20Dove/"},{"title":"「题解」Atlantis","text":"矩阵面积并问题：扫描线法+线段覆盖…… 一 题目 Source DescriptionsThere are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity. InputThe input file consists of several test cases. Each test case starts with a line containing a single integer n (1&lt;=n&lt;=100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0&lt;=x1&lt;x2&lt;=100000;0&lt;=y1&lt;y2&lt;=100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area. The input file is terminated by a line containing a single 0. Don’t process it. OutputFor each test case, your program should output one section. The first line of each section must be “Test case #k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point. Output a blank line after each test case. 二 题解题目大意二维平面内有n个矩形，有些矩形两两相交。给出矩形主对角线的两个端点的坐标（可能不是整数），试求矩形所覆盖的总面积。 思路扫描线法假设我们有一条平行于y轴的线段，从y轴开始不断向x轴正方向平移。我们可以根据这条线段把这个若干矩形组成的不规则图形划分成若干部分（实际上是根据每个矩形平行于y轴的那些边），如下图： 这样划分，那么每两条相邻的扫描线之间的图形面积就可以快速的求出，因为这部分图形都是矩形，且有相同的宽（即两条扫描线之间的距离）。那么我们只需要求出图形的高之和，也就是若干条线段的并。 线段覆盖如下图，两条扫描线之间的部分是两个不相交的矩形，它们的并的面积可以用下面的式子求出。 $(x_2-x_1)$这个值实际上枚举扫描线就可以确定，关键是求出$h$的值。单看$h$在y轴上的投影（图二），不难发现$h$是若干线段的并。于是我们不妨这样想：把每个矩形看成两条相等的线段（高），那么我们在扫描的过程中会先后遇到这两条线段。第一次遇到时，我们在y轴上投影这条线段（也可以看成把它覆盖在y轴上），第二次遇到时，我们把这条线段从y轴上删除。于是我们只需要求出某一时刻，在y轴上的所有线段之并就好了。 那么实际上我们要维护这样一个东西：维护若干线段的并的长度，支持删除或插入一段线段。 那么就可以引入“线段覆盖”这个概念。实际上就是一棵节点维护的是一条“线段”的线段树，树上的每个节点维护在某个区间$[l,r]$内被覆盖的线段长度。详细定义如下： 123456class node{ public: int l,r; //节点所维护的区间 int cnt; //这个区间被完全覆盖的次数 int len; //这个区间被覆盖的长度} 如下图，每条线段两头的标号代表节点所维护的线段的两个端点（离散化之后）： 不难发现线段是满足“区间加法”的性质的，因为在合并时，父区间若未被完全覆盖，则父区间维护的线段长度一定是子区间维护值的和，否则就是子区间的覆盖长度之和。另外还需要对线段的端点进行离散化，细节参见代码。 细节坐标是可能有小数的，因此需要离散化，详见代码。 其次，因为线段树上的每段区间只能划分成$[l,mid]$和$[mid+1,r]$这两个子区间，否则会无限递归。但是如果把 所维护线段的端点 和 线段树的端点 设定为一个点，实际上$[mid,mid+1]$这个区间是被扔掉了的。因此我们若要修改$[l,r]$区间的值，必须调用递归修改$[l,r-1]$区间，然后在回溯更新区间大小的时候，按照$[l,r]$区间更新就好了，正确性请自行验证。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt; #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define DB doubleint read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CN = 2010;class segment{ //定义一条线段 public: DB l,r,x; int f; //线段的值(1或-1) /*矩形的对边的值分别为1 -1，这样当扫描完这个矩形的时候，这两条线段会抵消掉*/ bool operator &lt; (const segment&amp; a)const {return x &lt; a.x;} //按横坐标排序}s[2*CN];int n,scnt = 0,pcnt = 0; //线段的数量:scnt 离散化后点的数量:pcntDB pos[2*CN],ans; //pos:离散化后每个点对应的原始值 ans:面积和class node{ //定义线段树的一个节点 public: DB len; //被覆盖的长度 int cnt; //是否被整段覆盖 (被整段覆盖的次数)};class st{ //线段树 public: node d[8*CN]; inline void build(int l,int r,int k){ //建树 d[k].cnt = 0; d[k].len = 0; //没有被覆盖 if(l == r) return; int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); } DB get_len(int l,int r,int k){ //更新线段长度 if(d[k].cnt) return pos[r+1]-pos[l]; //被整段覆盖，r要+1 if(l == r) return 0; //不是线段 return d[k&lt;&lt;1].len + d[k&lt;&lt;1|1].len; //子区间求和 } inline void modify(int l,int r,int k,int s,int t,int x){ //修改 if(s&lt;=l &amp;&amp; r&lt;=t){ //被包含 d[k].cnt += x; //更新覆盖情况 d[k].len = get_len(l,r,k); //更新 return; } //不被包含 int m = (l+r)&gt;&gt;1; if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k].len = get_len(l,r,k); //更新 }}sgt;int main(){ n = read(); int kase = 0; while(n){ ans = 0; scnt = 0; for(int i=1;i&lt;=n;i++){ DB x1,y1,x2,y2; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); //初始化线段 s[scnt+1].l = s[scnt+2].l = min(y1,y2); s[scnt+1].r = s[scnt+2].r = max(y1,y2); s[scnt+1].x = x1; s[scnt+2].x = x2; s[scnt+1].f = 1; s[scnt+2].f = -1; pos[scnt+1] = y1; pos[scnt+2] = y2; scnt += 2; } //离散化 sort(s+1,s+scnt+1); //把线段排序 sort(pos+1,pos+scnt+1); //把离散化的查询表排序 pcnt = 1; for(int i=2;i&lt;=scnt;i++) if(pos[i] != pos[i-1]) pos[++pcnt] = pos[i]; //建树 sgt.build(1,pcnt,1); for(int i=1;i&lt;=scnt;i++){ int l = lower_bound(pos+1,pos+pcnt+1,s[i].l)-pos; //查找离散化之后的值 int r = lower_bound(pos+1,pos+pcnt+1,s[i].r)-pos-1; //r要-1 sgt.modify(1,pcnt,1,l,r,s[i].f); ans += (s[i+1].x-s[i].x)*sgt.d[1].len; //统计答案 } printf(&quot;Test case #%d\\nTotal explored area: %.2lf\\n\\n&quot;,++kase,ans); n = read(); } return 0;}","link":"/2019/07/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DAtlantis/"},{"title":"「题解」Emiya家今天的饭","text":"众所周知，小葱同学擅长计算几何，但是并不擅长 DP。 $m = 2/3$ 设 $f[i,j,k]$ 表示考虑前 $i$ 行，第一列选了 $j$ 个，第二列选了 $k$ 个的方案数之和，有转移：$$f[i,j,k]\\gets f[i-1,j-1,k]·a[i,1]+f[i-1,j,k-1]·a[i,2]$$ $m = 3$ 的情况也同理，多开一维状态就好了，复杂度 $O(n^3)$ 或 $O(n^4)$，能拿到 64pts。 $m\\le 500$ 根据 lorem ipsum 原理，不合法方案中至多有一列的选择数超过 $\\lfloor k/2 \\rfloor$ ，则考虑补集转化，把不合法的方案 DP 出来。钦点第 $u$ 行不合法，设 $f[i,j,k]$ 表示考虑前 $i$ 行，其它行一共选 $j$ 个， $u$ 行选了 $k$ 个的方案数，有转移：$$ f[i,j,k]\\gets f[i-1,j,k]+f[i,j,k-1]·a[i,u]+\\sum\\limits_{v\\neq u} f[i,j-1,k]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^3)$，能拿到 84pts。 代码： 123456789101112131415161718for(int i = 1; i &lt;= n; i++) ans = 1ll * ans * (a[i][0] + 1) % P; ans = (ans + P - 1) % P;for(int u = 1; u &lt;= m; u++){ memset(f, 0, sizeof(f)), f[0][0][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= n; j++){ for(int k = 0; k &lt;= n; k++){ f[i][j][k] = f[i - 1][j][k]; if(k) f[i][j][k] = (1ll * f[i - 1][j][k - 1] * a[i][u] % P + f[i][j][k]) % P; if(j) f[i][j][k] = (1ll * f[i - 1][j - 1][k] * (a[i][0] - a[i][u] + P) % P + f[i][j][k]) % P; } } } for(int j = 0; j &lt;= n; j++) for(int k = 0; k &lt;= n; k++){ int s = (j + k) &gt;&gt; 1; if(k &lt;= s) continue; ans = (ans - f[n][j][k] + P) % P; }} $n\\le 100, m \\le 2000$ 考虑削状态，设 $f[i,l]$ 表示考虑前 $i$ 行，$n+k-j=l$ 时的方案数，有转移：$$ f[i,l]\\gets f[i-1,l]+f[i-1,l+1]·a[i,u]+\\sum\\limits_{u\\neq v}f[i-1,l-1]·a[i,v] $$ 预处理前缀和即可 $O(1)$ 转移，复杂度 $O(mn^2)$。 代码： 1234567891011for(int i = 1; i &lt;= n; i++) ans = 1ll * ans * (a[i][0] + 1) % P; ans = (ans + P - 1) % P;for(int u = 1; u &lt;= m; u++){ memset(f, 0, sizeof(f)), f[0][n] = 1; for(int i = 1; i &lt;= n; i++) for(int l = 0; l &lt;= (n &lt;&lt; 1); l++){ f[i][l] = f[i - 1][l]; f[i][l] = (1ll * f[i - 1][l + 1] * a[i][u] + f[i][l]) % P; if(l) f[i][l] = (1ll * f[i - 1][l - 1] * (a[i][0] - a[i][u] + P) % P + f[i][l]) % P; } for(int l = 0; l &lt; n; l++) ans = (ans - f[n][l] + P) % P;}","link":"/2020/08/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"},{"title":"「题解」Fancy Fence","text":"打了一场 CEOI2020 Day1 的线上镜像，发现这个 A 题好像有点水啊，于是切掉，来水个题解…… 原题链接 容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：$$A=\\dbinom{NM}{2}, B = M·\\dbinom{N}{2},C=N·\\dbinom{M}{2}$$ 有该矩形的子矩形数量为：$$(A-B-C)/2+B+C$$ 之所以要算的这么麻烦是为了去重…这个重复的问题考场上卡了我半小时/kk… 那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\\min\\limits_{l_i\\le k\\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。 剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。 于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;#define int long long // 惨痛经历const int P = 1e9 + 7;const int CN = 2e5 + 5;const int i2 = 500000004;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = 0, ans = 0; map&lt;int, bool&gt; cal[CN];int C(int x) {return (1ll * x * (x - 1) / 2ll) % P;}int calc(int l, int a, int b){ int ab = ((a - b) % P + P) % P; int rec = C(1ll * l * ab % P), t1 = C(ab), t2 = C(l); t1 = 1ll * t1 * l % P, t2 = 1ll * t2 * ab % P; rec = ((rec - t1 - t2) % P + P) % P, rec = 1ll * rec * i2 % P; rec = (rec + t1 + t2) % P; int t = C(l + 1); t = 1ll * t * b % P, t = 1ll * t * ab % P, t = (t + P) % P; return (rec + t) % P;}signed main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(); for(int i = 1; i &lt;= n; i++) h[i] = read(); for(int i = 1; i &lt;= n; i++) w[i] = read(), sum[i] = (sum[i - 1] + w[i]) % P, ans = (1ll * w[i] * h[i] % P + ans) % P; stk[++top] = 1, pr[1] = 0; for(int i = 2; i &lt;= n; i++){ while(h[ stk[top] ] &gt;= h[i]) top--; pr[i] = stk[top], stk[++top] = i; } stk[top = 1] = n + 1; for(int i = n; i; i--){ while(h[ stk[top] ] &gt;= h[i]) top--; nt[i] = stk[top], stk[++top] = i; } for(int i = 1; i &lt;= n; i++){ if(cal[ pr[i] ][ h[i] ]) continue; cal[ pr[i] ][ h[i] ] = true; int l = (sum[ nt[i] - 1 ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]); ans = (ans + calc(l, a, b)) % P; } printf(&quot;%lld&quot;, ans);}","link":"/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"},{"title":"「题解」Good Numbers","text":"可爱的数学题++…… 一 题目 Source DescriptionsThe only difference between easy and hard versions is the maximum value of n. You are given a positive integer number n. You really love good numbers so you want to find the smallest good number greater than or equal to n. The positive integer is called good if it can be represented as a sum of distinct powers of 3 (i.e. no duplicates of powers of 3 are allowed). For example:30 is a good number: 30=33+31,1 is a good number: 1=30,12 is a good number: 12=32+31,but 2 is not a good number: you can’t represent it as a sum of distinct powers of 3 (2=30+30),19 is not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representations 19=32+32+30=32+31+31+31+30 are invalid),20 is also not a good number: you can’t represent it as a sum of distinct powers of 3 (for example, the representation 20=32+32+30+30 is invalid).Note, that there exist other representations of 19 and 20 as sums of powers of 3 but none of them consists of distinct powers of 3. For the given positive integer n find such smallest m (n≤m) that m is a good number. You have to answer q independent queries. InputThe first line of the input contains one integer q (1≤q≤500) — the number of queries. Then q queries follow.The only line of the query contains one integer n (1≤n≤1018). OutputFor each query, print such smallest integer m (where n≤m) that m is a good number. 二 题解考虑 n⩽10^4 的情况。我们现在要在数列 [3^0,3^1,3^2,…,3^k](3^k&gt;n) 中选出一些数，使得它们的和 ⩾n ，并使得这个和最小。考虑 k 的范围，此时 k⩽log3(10^4)≈14 ，所以只需要 2^k 枚举每个数字选不选就好了。总复杂度 O(q·2^k) ，解决了 easy version 。 考虑 n⩽10^18 的情况。实际上上述枚举过程可以通过枚举二进制状态来实现，即用一个数字二进制位上的 0/1 来表示数列某一项选不选。假设我们当前二进制枚举的状态码为 S ，那么实际上该状态码所对应的数值是单调的；换句话说，随着 S 变大，其表示的那个数字也变大。 简单的 proof ，请理性偷税。考虑把二进制数 0100 变成 0101 （前者表示 3^2 ，后者表示 3^2+3^0） ，一定变大，因为又多了新的一项。考虑把二进制数 0100 变成 1000 （前者表示 3^2 ，后者表示 3^3），也一定变大，因为次数+1。 那么也就是说现在枚举的数值具有单调性，那么为什么不二分呢？只需要二分查找出一个 ⩾n 的最小位置就好了。总复杂度 O(qk)，其中 k 为常数，它大概是 log2(2^40) = 40 ，这已经很小了，于是切掉。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne; }int q; LL n;LL Pow3(int a){ LL rec = 1,base = 3; while(a) {if(a &amp; 1) rec *= base; base *= base,a &gt;&gt;= 1;} return rec;}LL gen(LL u){ LL g = 0; for(int i=0;i&lt;40;i++) if(u &amp; (1ll &lt;&lt; i)) g += Pow3(i); return g;}int main(){ q = read(); while(q--){ n = read(); LL l = 0,r = (1ll &lt;&lt; 40); while(l &lt; r){ LL m = (l + r) &gt;&gt; 1; if(gen(m) &gt;= n) r = m; else l = m + 1; } printf(&quot;%lld\\n&quot;,gen((l + r) &gt;&gt; 1)); } return 0;}","link":"/2019/10/28/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DGood%20Numbers/"},{"title":"「题解」Typewriter","text":"一道很好的SAM+DP综合题，虽然说坑点也很多…… 原题链接 考虑DP。设 $f[i]$ 为考虑前 $i$ 个位置的答案，应当有转移 $f[i] = \\min f[i - 1] + p, f[l]+q$ ，其中 $l$ 满足 $s[l+1:r]\\subseteq s[1:l]$ 。$f[]$ 显然是不降的，那么我们应取最小的 $l$ 。 考虑 $r\\to r + 1$ ，容易发现 $l$ 是不降的；那么对 $s[1:l]$ 建立SAM，每次尝试扩展 $s[r+1]$，如果不行则令 $l\\to l + 1$，即可找到最小的 $l$。维护当前的 $s[l+1:r]$ 对应在SAM上的路径，则可 O(1) 做到删除该路径上的第一个字符 $s[l+1]$ ，然后再扩展出$s[r+1]$即可。 小细节：当SAM在extend()的时候，若该路径的终点 $d$ 被拆成了 $v,d’$ 两个节点，且$\\text{nxt}[d’]=v$，则应当将路径的终点变换为 $v$，否则维护的路径就被破坏了。HDU不给数据，然后上面那个坑点卡了我一晚上… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5 + 5;int n, prv[CN]; long long p, q, f[CN]; char s[CN];class SAM{ public: int nxt[CN &lt;&lt; 1], son[CN &lt;&lt; 1][26], len[CN &lt;&lt; 1], sz, lst, cur, l; void init(int n){ for(int i = 0;i &lt; (n &lt;&lt; 1);i++) for(int j = 0;j &lt; 26;j++) son[i][j] = 0; // 题目卡memset() sz = 1, lst = cur = l = len[0] = 0, nxt[0] = -1; } void et(int c){ int u = sz++, p = lst; lst = u, len[u] = len[p] + 1; while(p != -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return (void)(nxt[u] = 0); int d = son[p][c]; if(len[d] == len[p] + 1) return (void)(nxt[u] = d); int v = sz++; if(d == cur) cur = v; // 坑点 len[v] = len[p] + 1, nxt[v] = nxt[d], nxt[d] = nxt[u] = v; for(int i = 0; i &lt; 26; i++) son[v][i] = son[d][i]; while(p != -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; } void del() {if(nxt[cur] != -1 &amp;&amp; --l == len[ nxt[cur] ]) cur = nxt[cur];} // delete bool rd(int c) {return son[cur][c] ? cur = son[cur][c], l++, true : false;} // read}D;int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;wa.out&quot;, &quot;w&quot;, stdout); while(cin &gt;&gt; (s + 1)){ n = strlen(s + 1), scanf(&quot;%lld%lld&quot;, &amp;p, &amp;q), D.init(n); int l = 1; D.et(s[1] - 'a'), prv[1] = 0; for(int i = 2; i &lt;= n; i++){ bool flag = true; while(!D.rd(s[i] - 'a')){ if(l + 1 == i) {flag = false; break;} D.del(), D.et(s[++l] - 'a'); } prv[i] = flag ? l : 0; if(!flag) D.et(s[++l] - 'a'); } f[1] = p; for(int i = 2;i &lt;= n;i++) if(prv[i]) f[i] = min(f[i - 1] + p, f[ prv[i] ] + q); else f[i] = f[i - 1] + p; printf(&quot;%lld&quot;, f[n]), puts(&quot;&quot;); }}","link":"/2020/08/06/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DTypewriter/"},{"title":"「题解」Optimal Currency Exchange","text":"一道很有意思的数学题，第一眼没觉得有多难，结果瞎搞了一个多小时才AC，真是有趣…… 一 题目 Source DescriptionsAndrew was very excited to participate in Olympiad of Metropolises. Days flew by quickly, and Andrew is already at the airport, ready to go home. He has n rubles left, and would like to exchange them to euro and dollar bills. Andrew can mix dollar bills and euro bills in whatever way he wants. The price of one dollar is d rubles, and one euro costs e rubles. Recall that there exist the following dollar bills: 1, 2, 5, 10, 20, 50, 100, and the following euro bills — 5, 10, 20, 50, 100, 200 (note that, in this problem we do not consider the 500 euro bill, it is hard to find such bills in the currency exchange points). Andrew can buy any combination of bills, and his goal is to minimize the total number of rubles he will have after the exchange. Help him — write a program that given integers n, e and d, finds the minimum number of rubles Andrew can get after buying dollar and euro bills. InputThe first line of the input contains one integer n (1≤n≤108) — the initial sum in rubles Andrew has.The second line of the input contains one integer d (30≤d≤100) — the price of one dollar in rubles.The third line of the input contains integer e (30≤e≤100) — the price of one euro in rubles. OutputOutput one integer — the minimum number of rubles Andrew can have after buying dollar and euro bills optimally. 二 题解题目大意：你有一堆卢布，去换两种钱（美元和欧元），汇率分别是d对1和e对1。美元有1, 2, 5, 10, 20, 50, 100的面值，欧元有5, 10, 20, 50, 100, 200的面值，现在要求求出你能剩下的钱数的最小值。 首先想到的是背包，这个大概都能想出来就不多讲，写起来长这样： 123456for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=7;j++) if(i-D[j] &gt;= 0) f[i] = max(f[i], f[i-D[j]]+D[j]); for(int j=1;j&lt;=5;j++) if(i-E[j] &gt;= 0) f[i] = max(f[i], f[i-E[j]]+E[j]);} 然后1e8的数据范围妥妥的RE了。 然后回到题目。首先观察到一个结论：对于美元来讲，所有的面值都是一美元面值的倍数啊…也就是说换美元的话，不管你换到多少张不同面值的钞票，实际上都可以看成换了一堆面值为一美元的钞票。对于欧元也同理。那么也就是说，我们只需要考虑换成一美元和五欧元两种面值就好了。 于是把这两种钞票分别所需要的卢布的数量表示出来，不妨设x=d,y=5e。设美元换了a张，欧元换了b张，那么剩下的钱数就是n-(ax+by)。设c=n-(ax+by)，实际上就是要最小化c。 然后c=n-(ax+by)不觉得很眼熟么…移项后就是ax+by=n-c，其中x,y,n已知，可以看作关于a,b的不定方程。但是c呢？c可能有很多取值，但是不难发现，某一c值可行的条件是ax+by=n-c这个关于a,b的不定方程有a,b同为非负整数的解。 怎么判定？由裴蜀定理的推广我们知道不定方程有整解的条件是(a,b)|c，但是非负这个条件怎么保证呢？不定方程的整数通解是：针对于某一特解(x0,y0)，( x0+i(b/(a,b)), y0-i(a/(a,b)) )是方程的通解（注意：其中i∈Z，除号后面的(a,b)实际表示gcd(a,b)）。那么显然，若x0,y0同时⩾0，则一定有非负整数解；若x0,y0同时&lt;0，则一定没有非负整数解，因为即使让x0,y0中的一者变得⩾0，另一者也只会越来越小。那么对于x0,y0中有一者&lt;0，另一者⩾0的情况呢？不妨假定x0⩾0而y0&lt;0。我们希望让y0⩾0，于是不妨设y0+i(a/(a,b))⩾0。那么对于整数i，如果i最小时，也有x0-i(b/(a,b))&lt;0的话，那么我们就肯定不能通过调整特解来使得解均为非负数，反之则一定可以。x0&lt;0而y0⩾0的情况也同理。那么实际上就是几个判断的事： 12345678910111213141516bool check(){ ... int k = c/g,kx = b/g,ky = a/g; x = x0*k,y = y0*k; if(x&gt;=0 &amp;&amp; y&gt;=0) return true; if(x&lt;0 &amp;&amp; y&lt;0) return false; int i = 0; if(x &lt; 0){ while(x &lt; 0) x += kx,i++; //调整特解使得x非负 if(y-i*ky &lt; 0) return false; //此时另一解为负，则一定无非负整数解 return true; } while(y &lt; 0) y += ky,i++; //反之同理 if(x-i*kx &lt; 0) return false; return true;} 然后就好了，我们知道了如何判断一个c可行与否。不难发现有c⩽min(n mod a, n mod b)，后面那个东西不会大于100，于是枚举c就好了啊。 上面的内容用到了一点解不定方程的知识，顺手推推博：1,2。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; int n,a,b,r = 0;int gcd(int a,int b) {return b?gcd(b,a%b):a;}void exgcd(int a,int &amp;x,int b,int &amp;y){ //exgcd递归 if(!b){x = 1; y = 0; return;} exgcd(b,x,a%b,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(int a,int &amp;x,int b,int &amp;y, int c){ //解不定方程并判断有无非负整数解 int g = gcd(a,b); if(c % g) return false; //无整数解 int x0,y0; exgcd(a,x0,b,y0); //转化为求解ax+by=gcd(a,b) int k = c/g,kx = b/g,ky = a/g; x = x0*k,y = y0*k; //得到ax+by=c的特解(x,y) //判定部分 if(x&gt;=0 &amp;&amp; y&gt;=0) return true; if(x&lt;0 &amp;&amp; y&lt;0) return false; int i = 0; if(x &lt; 0){ while(x &lt; 0) x += kx,i++; //调整特解使得x非负 if(y-i*ky &lt; 0) return false; //此时另一解为负，则一定无非负整数解 return true; } while(y &lt; 0) y += ky,i++; //同理 if(x-i*kx &lt; 0) return false; return true;} int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b); b *= 5; //乘上面值 int x,y; while(!ExGcd(a,x,b,y,n-r)) r++; //找到最小的r printf(&quot;%d&quot;,r); return 0;}","link":"/2019/09/14/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DOptimal%20Currency%20Exchange/"},{"title":"「题解」MUL","text":"第一眼看暴力水题，第二眼看筛法水题，第三眼想DP，没想到正解是…最大流…… 一 题目 原题链接 描述有 N 个宝石，编号为 1, 2, .., N你可以进行任意次以下操作（可以一次也不做） 选择一个正整数 x，将所有编号为 x 的倍数的宝石打碎 最后，对于每个没有被打碎的宝石 i，你可以获得 a_i 元。要注意的是，有些 a_i 是负值，这意味着你要倒贴钱。 在最好的情况下，你能获得多少元呢？ 输入第一行一个整数 N，代表共有 N 个宝石第二行 N 个整数，分别代表 a_1, a_2, …, a_N 输出一行一个整数，表示你最多可以得到的钱 二 题解初步分析先不妨称砸掉宝石为筛去一个数值。设筛去的总权值为$v$，获得的利益为$w$，则有$w=\\sum\\limits_{i=1}^n a_i -v$。显然，$v$越小，$w$越大，得到的答案越优。 也就是说，要让删除的数之和最小。 问题的转化考虑我们删除一个数的条件。删掉第$k$个数，必须要将编号为$2\\times k,3\\times k,…,ik(ik\\leqslant n)$的数一起删掉。不妨从编号为$k$的数向编号为$k$的倍数的数$ik$连一条有向边，那么我们会得到一张图。现在再分析删除一个数的条件：即是将从该节点所能到达的所有节点删除。那么这时候就可以引入一个新的概念：闭合子图。 闭合子图：在一张图中选出一些节点，它们及从它们所能到达的所有节点组成原图的的一张闭合子图。 同时这张图上每个节点都是有权值的（即问题中宝石的价值），我们要让选出的闭合子图权值最小。那么问题转化成了在我们所建的图中，求出最小权闭合子图。 网络流模型先抛开最小权闭合子图。 我们知道最大权闭合子图的网络流模型：将图中所有正权节点与源点$s$相连，所连边的流量限制为节点权值；所有负权节点与汇点$t$相连，所连边的流量限制为节点权值的相反数（绝对值）；图上原有边的流量限制为$\\infty$。设$s\\to t$的最小割（最大流）的大小为$g$，则最大权闭合子图的权值和为$\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&gt;0}a_i - g$。说得像人话一点，就是图上所有正权值之和减最小割。 以上结论我并不会证明，但是它是对的。好了，剩下的问题是用这个模型求出“最小权闭合子图”。 不妨将节点权值全部乘上$-1$，套用上面的模板，那么我们求出来的最大权闭合子图即是最小权闭合子图大小的相反数。设最小权闭合子图大小为$s$，则有$s = -(-\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&lt;0}a_i - g)$，即图上所有负权值的绝对值之和减最小割。 设最优解为$f$，则有$f = \\sum\\limits_{i=1}^na_i - s = \\sum\\limits_{i=1}^na_i +(-\\sum\\limits_{1\\leqslant i\\leqslant n}^{a_i&lt;0}a_i - g)$。好了，问题解决了。 用Dinic求出这个$g$，注意，long long不要忘开，边数开多一点，然后千万别写当前弧优化！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=110;const int CE=CP*CP*20;const LL INF=0x3f3f3f3f3f3f3f3f;LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt; LL cap,flow; void init(int f,int t,int n,LL c,LL fl) {from=f;to=t;nxt=n;cap=c;flow=fl;}}E[CE];int hd[CP],ecnt=1;void add(int x,int y,LL z){ E[++ecnt].init(x,y,hd[x],z,0); hd[x] = ecnt; E[++ecnt].init(y,x,hd[y],0,0); hd[y] = ecnt;}//v defineint n;LL a[CP];void copy(int *a,int *b,int pos,int sz){ for(int i=pos;i&lt;pos+sz;i++) b[i] = a[i];}//dinicint dep[CP];bool build(int s,int t){ //构造分层图 memset(dep,0,sizeof(dep)); dep[s] = 1; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(!dep[v] &amp;&amp; E[k].cap-E[k].flow&gt;0){ dep[v] = dep[u]+1; Q.push(v); } } } return dep[t];}LL augment(int u,int t,LL rst){ //多路增广 if(u == t) return rst; LL used = 0; for(int k=hd[u]; k; k=E[k].nxt){ fs &amp;e = E[k]; if(dep[e.to] == dep[u]+1){ LL a = augment(e.to,t, min(rst-used,e.cap-e.flow)); if(a){ used += a; E[k].flow += a; E[k^1].flow -= a; if(used == rst) return rst; } } } return used;}LL mf(int s,int t){ //最大流 LL _mf = 0; while(build(s,t)) _mf += augment(s,t,INF); return _mf;}int main(){ n = read(); for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) for(int k=2;i*k&lt;=n;k++) add(i,i*k,INF); //原图内的边 int s = n+1,t = n+2; for(int i=1;i&lt;=n;i++) if(a[i] &gt; 0) add(i,t,a[i]); //反着连边，搞不懂自己推一推 else add(s,i,-a[i]); LL sum = 0,sigma = 0; for(int i=1;i&lt;=n;i++) //求负权的绝对值之和 if(a[i] &lt; 0) sigma -= a[i]; for(int i=1;i&lt;=n;i++) sum += a[i]; printf(&quot;%lld&quot;,sum+(sigma-mf(s,t))); return 0;}","link":"/2019/06/28/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DMUL/"},{"title":"「题解」Watching Fireworks is Fun","text":"单调队列优化DP转移…… 一 题目 Source DescriptionsA festival will be held in a town’s main street. There are n sections in the main street. The sections are numbered 1 through n from left to right. The distance between each adjacent sections is 1. In the festival m fireworks will be launched. The i-th (1 ≤ i ≤ m) launching is on time ti at section ai. If you are at section x (1 ≤ x ≤ n) at the time of i-th launching, you’ll gain happiness value bi - |ai - x| (note that the happiness value might be a negative value). You can move up to d length units in a unit time interval, but it’s prohibited to go out of the main street. Also you can be in an arbitrary section at initial time moment (time equals to 1), and want to maximize the sum of happiness that can be gained from watching fireworks. Find the maximum total happiness. Note that two or more fireworks can be launched at the same time. InputThe first line contains three integers n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n). Each of the next m lines contains integers ai, bi, ti (1 ≤ ai ≤ n; 1 ≤ bi ≤ 109; 1 ≤ ti ≤ 109). The i-th line contains description of the i-th launching. It is guaranteed that the condition ti ≤ ti + 1 (1 ≤ i &lt; m) will be satisfied. OutputPrint a single integer — the maximum sum of happiness that you can gain from watching all the fireworks. Please, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier. 二 题解单调队列优化DP。从O(n^2m)变成O(nm)。 因为转移方程里面有个固定长度区间的$\\max$或$\\min$，这个是可以滑动窗口的。emm细节懒得讲了。 贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 2e5+5;const int CM = 310;const LL INF = 1e18;LL read(){ LL s=0,ne=1; char c = getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m,d;int a[CM],t[CM]; LL b[CM];LL f[2][CN]; int p = 0;LL abs(LL x){return x&gt;0 ? x:-x;} int main(){ //memset(f,-0x7f,sizeof(f)); n = read(); m = read(); d = read(); for(int i=1;i&lt;=m;i++) a[i] = read(),b[i] = read(),t[i] = read(); for(int i=1;i&lt;=n;i++) f[p][i] = b[1]-abs(a[1]-i); //初始化 for(int i=2;i&lt;=m;i++){ //枚举烟花 p ^= 1; LL MMD = (LL)(t[i]-t[i-1])*d; //MaxMoveDist //单调队列 int l = 1,r = 0,Q[CN]; for(int j=1;j&lt;=n;j++){ //正着扫一遍 j-k&lt;=MMD while(l&lt;=r &amp;&amp; j-Q[l]&gt;MMD) l++; //过时的出队 while(l&lt;=r &amp;&amp; f[p^1][j]&gt;f[p^1][Q[r]]) r--; //保持单减 Q[++r] = j; //入队 f[p][j] = f[p^1][Q[l]]+b[i]-abs(a[i]-j); //第一遍要强制更新状态 } l = 1; r = 0; for(int j=n;j;j--){ //倒着扫一遍 k-j&lt;=MMD while(l&lt;=r &amp;&amp; Q[l]-j&gt;MMD) l++; while(l&lt;=r &amp;&amp; f[p^1][j]&gt;f[p^1][Q[r]]) r--; Q[++r] = j; f[p][j] = max(f[p][j], f[p^1][Q[l]]+b[i]-abs(a[i]-j)); } } LL ans = -INF; for(int i=1;i&lt;=n;i++){ ans = max(ans, f[p][i]); //if(ans == 1) cout&lt;&lt;i&lt;&lt;endl; } printf(&quot;%lld&quot;,ans); return 0;} 另一个例子LG-P2627 可以结合着一下理解MQ优化DP到底应该怎么写。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e5+5;int n,k;LL e,f[CN],sum[CN];int Q[CN],l = 0,r = 0; //存下标/*r = l = 0的原因是默认队列里面有一个初始元素 0 */LL d[CN]; //存值/*d[i] = f[i-1]-sum[i]源于方程 f[i] = max(f[j-1]+sum[i]-sum[j]) ,位置 j 不选变形 f[i] = max(f[j-1]-sum[j]) + sum[i] ,位置 j 不选max()里面的用MQ维护 当扫描到 i 时,在队列中添加 d[i] = f[i-1]-sum[i] ,位置 i 不选在队列中查询出位置 j 转移时,位置 j 不选*/void PushBack(int i){ d[i] = f[i-1]-sum[i]; while(l&lt;=r &amp;&amp; d[Q[r]]&lt;d[i]) r--; Q[++r] = i;}LL QueryMax(int i){ while(l&lt;r &amp;&amp; Q[l]&lt;i-k) l++; return d[Q[l]];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;e),sum[i] = sum[i-1]+e; for(int i=1;i&lt;=n;i++){ PushBack(i); f[i] = QueryMax(i)+sum[i]; } printf(&quot;%lld&quot;,f[n]); return 0;}","link":"/2019/08/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DWatching%20Fireworks%20is%20Fun/"},{"title":"「题解」Unusual Sequences","text":"题意：输入 $x,y$，求有多少个数列满足其gcd为 $x$，和为 $y$。这里提供一个不使用反演的清奇思路…… 设 $f(s,g)$ 表示和为 $s$ ,gcd为 $g$ 的数列的数量，容易发现以下性质： $$\\begin{aligned} f(s,g)&amp;=0, \\text{ }g\\nmid s \\newline f(s,g)&amp;=f(s/g,1), \\text{ } g|s \\end{aligned}$$ 我们知道和为 $s$ 的数列应当有 $2^{s - 1}$ 个，即把 $s$ 看成 $s$ 个1，然后插上 $s - 1$ 个隔板。那么有： $$\\begin{aligned} 2^{s - 1} &amp;= \\sum\\limits_{g=1}^s f(s,g)\\newline &amp;=\\sum\\limits_{g | s}f(s,g)\\newline &amp;=\\sum\\limits_{g | s}f(s/g,1)\\end{aligned}$$ 移一下项，得到：$$ f(s,1)=2^{s - 1}-\\sum\\limits_{g|s,g&gt;1}f(s / g,1) $$ 设 $f[s]$ 表示 $f(s, 1)$ ，得到递推方程：$$ f[s] = 2^{s - 1}-\\sum\\limits_{g|s,g&gt;1}f[s/g]$$ 直接做是 $O(n)$ 的，但是容易知道有些位置的值是用不到的。开一个 map 储存 $f[]$ 数组，大力递推计算，参考杜教筛的复杂度，大约是 $O(n^{\\frac{3}{4}})$，但是实际上跑得出奇的快。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;#define LL long longconst int P = 1e9+7;int x,y;int qp(int a,int b){ int r = 1; while(b){ if(b &amp; 1) r = (1ll * a * r) % P; a = (1ll * a * a) % P; b &gt;&gt;= 1; } return r;}map&lt;int, int&gt; f;int dfs(int s){ if(s == 1) return 1; if(f.count(s)) return f[s]; int r = qp(2, s - 1); for(int g = 2;g * g &lt;= s;g++){ if(s % g) continue; if(g * g == s) r = (r - dfs(g) + P) % P; else r = ((r - dfs(s / g) - dfs(g)) % P + P) % P; } return f[s] = (r - 1 + P) % P;}int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(y % x) puts(&quot;0&quot;); else printf(&quot;%d&quot;, dfs(y / x));}","link":"/2020/07/08/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DUnusual%20Sequences/"},{"title":"「题解」小a和小uim之大逃离","text":"小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声…… 一 题目 原题链接 描述小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发、青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小a和他的小伙伴都惊呆了！ 瞬间，地面上出现了一个n*m的巨幅矩阵，矩阵的每个格子上有一坨0~k不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有k的容量，也就是说，如果装了k+1那么魔瓶会被清空成零，如果装了k+2就只剩下1，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！ 现在他想知道他们都能活下来有多少种方法。 输入第一行，三个空格隔开的整数n，m，k接下来n行，m列，表示矩阵每一个的魔液量。同一行的数字用空格隔开。 输出一个整数，表示方法数。由于可能很大，输出对1 000 000 007取余后的结果。 123对于20%的数据，n,m&lt;=10,k&lt;=2对于50%的数据，n,m&lt;=100,k&lt;=5对于100%的数据，n,m&lt;=800,1&lt;=k&lt;=15 二 题解题外话：这是蒟蒻的第三百道题，同时是本站的第二十篇文章。 50分算法还是很好想出来的。设$f_{i,j,p,q,0/1}$表示当前以格子$(i,j)$为终点，小a收集了$p$体积的魔液，小uim收集了$q$体积的魔液，且上一步是小a（$0$）还是小uim（$1$）走 的时候，所得到的方案数。边界条件是枚举起点（小a走出第一步的点），且方案为$1$。 可惜内存会炸掉。 我们发现转移状态只需要用到$p,q$的差值，所以记录$p,q$的值是很不划算的。设$v=p-q$，可以得到一个更优秀的状态设计：设$f_{i,j,v,0/1}$表示当前以格子$(i,j)$为终点，小a与小uim收集的魔液的体积之差等于$v$，且上一步是小a（$0$）还是小uim（$1$）走 的时候，所得到的方案数。 但是差值有负数。因为差值的取值范围在$-k \\text{~} k$，所以有一个很朴素的想法是把每个差值加上$k$来避免负数。但是这么大的空间还是有炸掉的危险。 其实继续研究就可以发现，根本不需要这么麻烦。因为即使是这个差值也是要模上$k+1$的，所以余数最多有$k+1$种情况。对于差值为负的情况，我们把它加上一个模数（$k+1$）再模，让余数总为正数。此时可以形象的理解一下：小uim的魔液比小a多，小a不服气，又拿来一瓶刚好溢出的魔液，把小uim又比下去了。因为题目的特殊性质，总满足$k+1=0$，所以并不会出问题。 方程： $$\\begin{align} f_{i,j,v,0} = f_{i-1,j,v-s_{i,j},1} + f_{i,j-1,v-s_{i,j},1} \\newline f_{i,j,v,1} = f_{i-1,j,v+s_{i,j},0} + f_{i,j-1,v+s_{i,j},0} \\end{align}$$ 其中$s_{i,j}$是格子$(i,j)$的魔液体积。 还有一个小坑：虽然余数是long long型的，但是转移状态必须用int，统计状态再用long long，不然MLE。并且此时还不能让int自然溢出，还必须模上一个long long型的余数，不然有神仙错误…… 附上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN=8e2+1;const LL R=1000000007;int n,m,k;int sum[CN][CN];/*0 : xiao a 1 : xiao uimv=a-u*/ int f[CN][CN][16][2]; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { scanf(&quot;%d&quot;,&amp;sum[i][j]); sum[i][j] %= (k+1); //魔液先取一遍模 f[i][j][sum[i][j]][0]=1; //边界 } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int v=0;v&lt;=k;v++) //枚举差值 { (f[i][j][v][0] += f[i-1][j][(v-sum[i][j]+k+1)%(k+1)][1])%=R; //加上一个模数再取模 (f[i][j][v][0] += f[i][j-1][(v-sum[i][j]+k+1)%(k+1)][1])%=R; (f[i][j][v][1] += f[i-1][j][(v+sum[i][j])%(k+1)][0])%=R; (f[i][j][v][1] += f[i][j-1][(v+sum[i][j])%(k+1)][0])%=R; } LL ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) (ans+=f[i][j][0][1])%=R; printf(&quot;%lld&quot;,ans); return 0;}","link":"/2019/03/05/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%B0%8Fa%E5%92%8C%E5%B0%8Fuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/"},{"title":"「题解」天际线","text":"Latium省的Genoa是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官Caesar的委任，前往Genoa建立新的城市….. 一 题目 原题链接 描述Latium省的Genoa是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官Caesar的委任，前往Genoa建立新的城市。Caesar对这次任务的要求是在Genoa这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。 正在你大刀阔斧地进行城市建设的时候，Caesar突然写信给你，说他要检查Genoa的建设情况。Caesar希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。 怎样描述一个城市的轮廓呢？我们知道Genoa所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组（Li,Hi,Ri）其中Li和Ri分别是建筑的左坐标和右坐标，Hi就是建筑的高度。在下方所示的图表中左边建筑物描述如下(1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28)，右边用轮廓线的顺序（1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0）表示： 输入在输入数据中，你将得到一系列表示建筑的三元组。在输入数据中所有建筑的坐标中的数值都是小于10000的正整数，且至少有1幢建筑，最多有5,000幢建筑。在输入输入中每幢建筑的三元组各占一行。三元组中的所有整数应由一个或多个空格分开。 输出在输出数据中，你被要求给出城市的轮廓线。你可以这样来描述：对于所有轮廓线上的折点，按顺序排好，第奇数个点输出x坐标，第偶数个点输出y坐标，两个数之间用空格分开。 二 题解扫描线+线段覆盖水题，不懂请参见「题解」Atlantis。 于是乎说一下我的AC过程吧。40min打完代码并调好样例，第一次提交拿了80pts，然后测试数据不给，只好自己去写对拍。然后我就可以顺理成章的贴出对拍的模板： run.bat123456789@echo off :loop g.exe&gt;data.in std.exe&lt;data.in&gt;std.out db.exe&lt;data.in&gt;my.out fc my.out std.out if not errorlevel 1 goto loop pause goto loop 顺便再贴一下上面这种样式的代码块的插入代码（对，这就是水博客）。 123{% codeblock [title] [lang:language] [url] [link text] %}code snippet{% endcodeblock %} 既然对拍的板子贴出来了，那么我水博客的目的达成了，然后发现应该一次性把在同一横坐标上的所有线段处理完，然后就AC了。 顺便一说，这代码反手就被我hack掉了。有什么办法么，我都AC了…… 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e6+6;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n;class locat{ public: int x,y; bool operator &lt; (const locat &amp;a)const{ if(x == a.x) return y &lt; a.y; return x &lt; a.x; }}ans[CN]; int acnt = 0;//Segment Cover class Segment{ public: int r,x,k; bool operator &lt; (const Segment &amp;a)const {return x &lt; a.x;}}seg[CN];int scnt = 0;int pos[CN],pcnt;class node{ public: int len,cnt;};class SGT{ public: node d[CN&lt;&lt;2]; int GetLen(int l,int r,int k){ if(d[k].cnt) return pos[r+1]-pos[l]; if(l == r) return 0; return d[k&lt;&lt;1].len + d[k&lt;&lt;1|1].len; } void modify(int l,int r,int k,int s,int t,int x){ if(s&lt;=l &amp;&amp; r&lt;=t){ d[k].cnt += x; d[k].len = GetLen(l,r,k); return; } int m = (l+r)&gt;&gt;1; if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k].len = GetLen(l,r,k); }}sgt;void SegmentCover(int i){ int l = 1; int r = lower_bound(pos+1,pos+pcnt+1,seg[i].r)-pos-1; sgt.modify(1,pcnt,1,l,r,seg[i].k);}int main(){ //freopen(&quot;data.in&quot;,&quot;r&quot;,stdin); n = 0; int x,y,z; while(~scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z)){ n++; seg[scnt+1].r = y; seg[scnt+1].x = x; seg[scnt+1].k = 1; seg[scnt+2].r = y; seg[scnt+2].x = z; seg[scnt+2].k = -1; scnt += 2; pos[n] = y; } pos[++n] = 0; //防止出锅 //离散化 sort(seg+1,seg+scnt+1); sort(pos+1,pos+n+1); pcnt =1; for(int i=2;i&lt;=n;i++) if(pos[i] != pos[i-1]) pos[++pcnt] = pos[i]; //solve int prvh = 0; for(int i=1;i&lt;=scnt;i++){ while(seg[i].x==seg[i+1].x &amp;&amp; i&lt;scnt) SegmentCover(i),i++; SegmentCover(i); if(sgt.d[1].len != prvh){ ans[++acnt].x = seg[i].x; ans[acnt].y = prvh; prvh = sgt.d[1].len; ans[++acnt].x = seg[i].x; ans[acnt].y = prvh; } } //print for(int i=1;i&lt;=acnt;i++) if(i &amp; 1) printf(&quot;%d &quot;,ans[i].x); else printf(&quot;%d &quot;,ans[i].y); return 0;}","link":"/2019/07/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%A4%A9%E9%99%85%E7%BA%BF/"},{"title":"「题解」异构体","text":"一道比较简单的分类讨论题…… 一 题目Source : qbxt2019.10.3 T2Author : zhxSubmit : luogu T101285 描述你是能看到第二题的friends呢。 ——aoao众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。 Paradeus是一个新兴的宗教组织，该组织包含了N-1个Nyto，以及一个Mercurows总共NN个人组成。每个Nyto都是被其他某个人传教而进入的Paradeus，Mercurows是宗教的创立者，也就是说Mercurows并没有被任何人拉进组织。这张记录了每个人是由谁拉进传销组织的记录被视为Paradeus的教义，一直被广为传颂。 然而，随着岁月的流逝， 有不法分子开始对Paradeus的教义发动了攻击。不法分子在Paradeus的教义上添加了一条记录(a, b)，代表b是由a介绍入教的。 这条记录的加入导致Nyto们发现教义已经不合法了。 为了复兴教义，教徒们决定找到这条被不法分子加入的记录，并将其删除以恢复教义的荣光。更具体的说，现在给定N对记录(a_i, b_i)代表a_i是将b_i拉入教的。注意这NN条记录包含了被不法分子添加的那一条。现在我们希望你找到某一条记录，使得删掉这条记录之后剩下的N-1N−1条记录能够形成合法的教义。要注意的是， 教义并没有标注Mercurows，所以任何人都有可能是Mercurows。 输入第一行一个数代表人数；接下来N行每行两个数a_i,b_i代表一条记录。 输出一行一个数代表删掉第几条记录能够使得教义合法。 如果有多种方案， 输出 编号最大 的方案。 数据保证有解。 范围与约定对于40%的数据，n≤1000；对于另外20%的数据，可能成为Mercurows的人一定只有一个；对于100%的数据，1≤N≤10^5。 二 题解因为题目保证有解，那么正向地考虑构造，实际上就是在一棵树（有向，边从子节点指向父节点）上多连了一条边（也有向）。我们要拎出一条边，并使图恢复为一颗有根内向树。 先看这条边会改变什么。它一定会使得一个点的出度 +1。那么就意味着可能存在出度为 2 的节点，当然也可能没有（连在根上）。然后如果没有初度为二的节点，图就会是严格的基环内向树；否则有可能有环（不严格的基环外向树）或无环（DAG）。 实际上就 图一~三 这么几种情况： 对于图一，只需要在换上选最大边；图二，只能选择出度为 2 的节点指向基环内的边；图三，只需要在出度为 2 的节点的两条出边中选最大的那条。然后判环和把环拎出来只需要写个tarjan，然后就做完了。 考场tarjan写锅还能拿80pts可还行？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;class fs{ public: int to,nxt,id; void init(int t,int n,int i){to = t;nxt = n;id = i;}}E[CN];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(y,hd[x],z); hd[x] = ecnt;}int n;int de[CN];bool ChuDuWeiEr(){ for(int i=1;i&lt;=n;i++) if(de[i] == 2) return true; return false;}bool vis[CN];/* tarjan */int dfn[CN],low[CN],idx = 0,stk[CN],top = 0,bel[CN],bcnt = 0;bool ins[CN];int tot[CN];void dfstj(int u){ dfn[u] = low[u] = ++idx; ins[u] = true; stk[++top] = u; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dfn[v]){ dfstj(v); low[u] = min(low[u],low[v]); } else if(ins[v]) low[u] = min(low[u], low[v]); } if(dfn[u] == low[u]){ bcnt++; while(true){ int pos = stk[top--]; ins[pos] = false; bel[pos] = bcnt; tot[bcnt]++; if(pos == u) break; } }}void scc(){ memset(ins,0,sizeof(ins)); memset(tot,0,sizeof(tot)); for(int i=1;i&lt;=n;i++) if(!dfn[i]) dfstj(i);}/* pan huan */bool PanHuan(){ scc(); for(int i=1;i&lt;=bcnt;i++) if(tot[i] &gt; 1) return true; return false;}/* zhao huan */bool On[CN];void GetCir(int &amp;p,int &amp;q){ memset(On,0,sizeof(On)); for(int i=1;i&lt;=bcnt;i++) if(tot[i] &gt; 1) {p = i; break;} for(int i=1;i&lt;=n;i++) if(bel[i] == p) On[q = i] = true;}/* ji huan nei xiang shu */int MaxEdge = 0;void dfsst1(int u){ if(vis[u]) return; vis[u] = true; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(On[v]){ MaxEdge = max(MaxEdge, E[k].id); dfsst1(v); } }}int ST1(){ // 严格基环外向树 int p,q; scc(); GetCir(p,q); memset(vis,0,sizeof(vis)); dfsst1(q); return MaxEdge;}/* ST2 */int ST2(){ int Ans = 0; int st; for(int i=1;i&lt;=n;i++) if(de[i] == 2) {st = i; break;} if(!PanHuan()){ // DAG for(int k=hd[st];k;k=E[k].nxt) Ans = max(Ans, E[k].id); } else{ // 不严格基环内向树 int p,q; GetCir(p,q); for(int k=hd[st];k;k=E[k].nxt) if(On[E[k].to]) Ans = max(Ans, E[k].id); } return Ans;}int main(){ // scan scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(b,a,i); de[b]++; } // calc int ans; if(ChuDuWeiEr()) ans = ST2(); else ans = ST1(); // ji huan nei xiang shu printf(&quot;%d&quot;,ans); return 0;}","link":"/2019/10/04/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%BC%82%E6%9E%84%E4%BD%93/"},{"title":"「题解」无序字母对","text":"给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现…… 一 题目 原题链接 描述给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。 输入第一行输入一个正整数n。以下n行每行两个字母，表示这两个字母需要相邻。 输出输出满足要求的字符串。如果没有满足要求的字符串，请输出“No Solution”。如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案。 二 题解把单个字母看作图上的点，字母的相邻关系（也就是上文中的“字母对”）看作无向边。即对于一个字母对$ab$，将$a$与$b$连无向边。 题目中描述“使得每个字母对都在这个字符串中出现”，即可看作图上的每条边都要被经过。所以得出本题为欧拉路问题，求出字典序最小的欧拉道路（或回路）即可解决问题。 因为一共26个英文字母，算上大小写区分还不到100个，所以本题使用邻接矩阵存图更为方便。直接把char型字符强制转换为int型的ascii码，求解即可。注意：在涉及类型转换时，需要注重细节的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CP=1e3+3;const int CE=CP*CP;bool g[CP][CP]; //邻接矩阵int elm[CP]; //所有出现的字符（强转int），也可以理解为图的点集bool ap[CP]; //一个字符是否已经被记录int n;//euler pathint deg[CP]; //节点的度int list[CP]; //答案数组bool exm(){ int sum=0; for(int i=1;i&lt;=n;i++) if(deg[elm[i]]%2) sum++; return sum&lt;=2; //仅当奇点个数小于2时有解（这里没有判断图的连通性，下面还需要判断）}void dfs(int u){ for(int j=1;j&lt;=elm[0];j++) //从小到大遍历，为了字典序尽量小 { int v=elm[j]; if(g[u][v]) { g[u][v]=g[v][u]=false; //删边 dfs(v); } } list[++list[0]]=u; //必须在退栈的时候记录，想想为什么}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { char _x,_y; cin&gt;&gt;_x&gt;&gt;_y; int x=_x,y=_y; //转换成int g[x][y]=g[y][x]=true; //邻接矩阵 deg[x]++; //记录节点的度 deg[y]++; if(!ap[x]) //统计出现的字符 { elm[++elm[0]]=x; ap[x]=true; } if(!ap[y]) { elm[++elm[0]]=y; ap[y]=true; } } sort(elm+1,elm+elm[0]+1); //排序，为了得到最小字典序 int s=elm[1]; //无奇点从最小的点开始 for(int i=1;i&lt;=n&amp;&amp;s==elm[1];i++) if(deg[elm[i]]%2) s=elm[i]; //有奇点从最小的奇点开始 dfs(s); if(exm() &amp;&amp; list[0]==n+1) //解的长度不为n-1，图一定不联通 for(int i=list[0];i;i--) //一定倒着输出 { char c=list[i]; //再转换成char型 cout&lt;&lt;c; } else printf(&quot;No Solution&quot;); return 0; }","link":"/2019/02/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9/"},{"title":"「题解」旧试题","text":"来自神仙 11Dimensions 的神仙做法…… 题目 原题链接 求：$$ \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B \\sum\\limits_{k=1}^C d(ijk) $$其中 $A,B,C ⩽ 200005$。 分析记$x⊥y$表示$(x,y)=1$。结论： $$d(ijk)=\\sum\\limits_{x|i}\\sum\\limits_{y|i}\\sum\\limits_{z|i}[x⊥y][x⊥z][y⊥z]$$ 其中[]表示艾弗森括号，当且仅当括号内命题为真时取值为1，否则为0。在本篇题解中，这个括号的意义等价于单位函数，即$\\epsilon((a,b))=[(a,b)=1]=[a⊥b]$。那么： $$\\begin{aligned}&amp; \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B \\sum\\limits_{k=1}^C d(xyz) \\newline=&amp; \\sum\\limits_{i=1}^A \\sum\\limits_{j=1}^B\\sum\\limits_{k=1}^C\\sum\\limits_{x|i}\\sum\\limits_{y|i}\\sum\\limits_{z|i}[x⊥y][x⊥z][y⊥z] \\newline=&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\end{aligned}$$ 从三个单位函数里面任选一个反演，利用$\\epsilon=\\mu*1$： $$\\begin{aligned}&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C[x⊥y][x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\newline=&amp; \\sum\\limits_{x=1}^A \\sum\\limits_{y=1}^B \\sum\\limits_{z=1}^C (\\sum\\limits_{d|x,d|y}\\mu(d)) [x⊥z][y⊥z] \\lfloor\\frac{A}{x}\\rfloor \\lfloor\\frac{B}{y}\\rfloor \\lfloor\\frac{C}{z}\\rfloor \\newline=&amp; \\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)\\sum\\limits_{k_1=1}^{\\lfloor\\frac{A}{d}\\rfloor}\\sum\\limits_{k_2=1}^{\\lfloor\\frac{B}{d}\\rfloor}[k_1d⊥z][k_2d⊥z]\\lfloor\\frac{A}{k_1d}\\rfloor \\lfloor\\frac{B}{k_2d}\\rfloor\\end{aligned}$$ 依据$[ab⊥c]\\iff[a⊥c][b⊥c]$，整理得到： $$\\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)[d⊥z](\\sum\\limits_{x=1}^{\\lfloor\\frac{A}{d}\\rfloor}[x⊥z]\\lfloor\\frac{A}{xd}\\rfloor)(\\sum\\limits_{y=1}^{\\lfloor\\frac{B}{d}\\rfloor}[y⊥z] \\lfloor\\frac{B}{yd}\\rfloor)$$ 记： $$\\begin{aligned} g(n,x) = \\sum\\limits_{i=1}^n\\mu(i)[i⊥x] \\newlinef(n,x) = \\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥x] \\end{aligned}$$ 答案变成： $$\\begin{aligned}&amp; \\sum\\limits_{z=1}^C\\lfloor\\frac{C}{z}\\rfloor\\sum\\limits_{d=1}^{\\min(A,B)}\\mu(d)[d⊥z]f(\\lfloor\\frac{A}{d}\\rfloor, z)f(\\lfloor\\frac{B}{d}\\rfloor, z) \\newline=&amp; \\sum\\lfloor\\frac{C}{z}\\rfloor\\sum(g(r,z) - g(l - 1, z))f(\\lfloor\\frac{A}{d}\\rfloor, z)f(\\lfloor\\frac{B}{d}\\rfloor, z)\\end{aligned}$$ 即对$\\mu()$做前缀和然后对后面的$f()$分段，其中$[l,r]$表示整除分段的一段区间。 假设$O(n)$枚举$z$，那么求出后面的$\\sum$的值是$O(\\sqrt{n})$的。但是发现$z$是变化的，当$z$变化时暴力维护$f(),g()$是$O(n^2)$的，这成为了代码复杂度的瓶颈。如何解决？能不能减少更新$f(),g()$的次数？不难发现$z$在函数中发挥作用的地方是判断一个数与其互质。考虑将$z$质因数分解，容易看出一个数与其互质仅和$z$的质因子的种类有关，而与质因子的幂次无关。记： $$lw(z) = \\prod\\limits_{i=1}^np_i, \\text{where }z = \\prod\\limits_{i=1}^np_i^{\\alpha_i}$$ 那么我们只需要考虑$z\\in [1,C]$的所有$lw(z)$值即可（即所有无平方因子的数），它们共用一套$f(),g()$的函数值。通过dfs暴力生成无平方因子数，我们可以把它们一并更新。 但是这远远不够，考虑通过递推来维护$f(),g()$。这个套路参考NOI2016 循环之美。考虑在$z$中删去其一个质因子$x$，即$f(n,z)\\to f(n,z/x)$，将出现何种变化？应当有一部分多加了，要减去： $$\\begin{aligned}f(n,z) &amp;= \\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥z/x] -\\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor[i⊥z/x][x|i] \\newline&amp;= f(n, z / x) - \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[kx⊥z/x]\\lfloor\\frac{n}{kx}\\rfloor \\newline&amp;= f(n, z / x) - [x⊥z/x]\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[k⊥z/x]\\lfloor\\frac{n}{kx}\\rfloor\\newline&amp;= f(n, z / x) - f(\\lfloor\\frac{n}{x}\\rfloor, z/x)\\end{aligned}$$ 对$g()$的推导也同理，利用$\\mu(ab)=\\mu(a)\\mu(b)[a⊥b]$，可以得出： $$\\begin{aligned}g(n,z) &amp;= \\sum\\limits_{i=1}^n \\mu(i) [i⊥z/x] -\\sum\\limits_{i=1}^n \\mu(i) [i⊥z/x][x|i] \\newline&amp;= g(n, z / x) - \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}[kx⊥z/x] \\mu(kx) \\newline&amp;= g(n, z / x) - \\mu(x)\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(k)[k⊥x][k⊥z/x] \\newline&amp;= g(n, z / x) + \\sum\\limits_{k=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(k)[k⊥x(z/x)] \\newline&amp;= g(n, z / x) + g(\\lfloor\\frac{n}{x}\\rfloor, z)\\end{aligned}$$ 即： $$\\begin{aligned} g(n,z) = g(n, z / x) + g(\\lfloor\\frac{n}{x}\\rfloor, z) \\newlinef(n,z) = f(n, z / x) - f(\\lfloor\\frac{n}{x}\\rfloor, z/x) \\end{aligned}$$ 那么就可以递推了，但是直接更新是$O(n)$的。容易发现整除分段并不会用到所用的$f(),g()$值，所以我们边做分段边更新就好了，这是$O(\\sqrt{n})$的。空间复杂度呢？f[2e5][2e5],g[2e5][2e5]看似存不下来，但是容易发现后面一维是不连续使用的，那么将其离散化，考虑在dfs构造无平方因子数的时候，下层状态的转移依赖于上层状态，而dfs树的深度是$O(\\log_2n)$的，所以开f[2e5][10]即可。 总复杂度？粗略估计，爆搜的复杂度是$O(2^{\\log_2n})$即$O(n)$的，后面的求和通过整除分段可以$O(\\sqrt{n})$得出，那么总复杂度是$O(n\\sqrt{n})$的。但实际上复杂度要小很多，也就是说如果常数写得好那么它可以跑的飞快（预处理整除分段的端点、cache-friendly之类的），但是本人代码常数没那么小，最慢一个点大约4s？比三元环是好得多了。 $\\text{1}{\\color{Red}{1Dimensions}}$ Orz %%%% 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 2e5+5;const LL P = 1e9+7;LL read(){ LL s = 0,ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9'; c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int p[CN],mu[CN],lw[CN]; LL d[CN]; bool np[CN];void sieve(int n){ np[1] = true; mu[1] = 1, d[1] = 1, lw[1] = 1; for(int i = 2;i &lt;= n; i++){ if(!np[i]) p[ ++p[0] ] = i, d[i] = 2, lw[i] = i, mu[i] = -1; for(int j = 1;j &lt;= p[0] &amp;&amp; i * p[j] &lt;= n; j++){ int x = i * p[j]; np[x] = true; if(i % p[j]) d[x] = d[i] &lt;&lt; 1, lw[x] = lw[i] * p[j], mu[x] = -mu[i]; else {d[x] = (d[i] &lt;&lt; 1) - d[i / p[j]], lw[x] = lw[i]; break;} } } for(int i = 1;i &lt;= n;i++) d[i] += d[i - 1],mu[i] += mu[i - 1];}// int t,A,B,C;LL f[CN][10],g[CN][10],s[CN],ans;void init(){ g[0][1] = f[0][1] = 0; for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); g[r][1] = mu[r]; f[A / l][1] = d[A / l]; f[B / l][1] = d[B / l]; l = r; } memset(s, 0 , sizeof(s)); for(int z = 1;z &lt;= C; z++) s[ lw[z] ] += 1ll * C / z; ans = 0;}void upd(int x,int k){ for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); g[r][k] = g[r][k - 1] + g[r / x][k]; f[A / l][k] = f[A / l][k - 1] - f[(A / l) / x][k - 1]; f[B / l][k] = f[B / l][k - 1] - f[(B / l) / x][k - 1]; l = r; }}void dfs(int z0, int u, int k){ LL cur = 0; for(int l = 1;l &lt;= A; l++){ int r = min(A / (A / l), B / (B / l)); cur += (g[r][k] - g[l - 1][k]) * f[A / l][k] * f[B / l][k]; cur = (cur % P + P) % P; l = r; } ans += (s[z0] * cur) % P; ans %= P; for(int v = u; 1ll * p[v] * z0 &lt;= C; v++) upd(p[v], k + 1), dfs(z0 * p[v], v + 1, k + 1);}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); t = read(); sieve(2e5); while(t--){ A = read(), B = read(), C = read(); if(A &gt; B) swap(A, B); init(); dfs(1, 1, 1); printf(&quot;%lld\\n&quot;, ans); }}","link":"/2020/06/19/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%97%A7%E8%AF%95%E9%A2%98/"},{"title":"「题解」摆花","text":"矩阵快速幂优化二维DP…… 一 题目 原题链接 描述艺术馆门前将摆出许多花，一共有n个位置排成一排，每个位置可以摆花也可以不摆花。有些花如果摆在相邻的位置（隔着一个空的位置不算相邻），就不好看了。假定每种花数量无限，求摆花的方案数。 输入输入有1+m行，第一行有两个用空格隔开的正整数n、m，m表示花的种类数。接下来的m行，每行有m个字符1或0,若第i行第j列为1，则表示第i种花和第j种花不能排在相邻的位置，输入保证对称。（提示：同一种花可能不能排在相邻位置）。 输出输出只有一个整数，为方案数（这个数字可能很大，请输出方案数除以1000000007的余数）。 二 题解对于矩阵的初学者，建议您先看矩阵基础。 DP思路很容易想到一个$O(nm)$级别的DP：设$f_{i,j}$为考虑前$i$个位置，且第$i$个位置摆放第$j$种花时的方案数。由于任意位置都可以一盆花也不摆，故当$j = 0 $时表示该位置不摆花。 初始状态： $f_{0,0} = 1$转移方程：设$a(x,y) = 1$表示$x,y$两种花可以相邻。则转移方程为： $ f_{i,j} = \\sum\\limits_{k\\in [0,m]}^{a(i,k) = 1} f_{i-1,k}$答案： 答案为$\\sum\\limits_{i = 0}^m f_{n,i}$ 空间复杂度为$O(nm)$，朴素时间复杂度为$O(nm^2)$。核心代码大约长这样： 12345678const int R = 1e9+7;f[0][0]=1;for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m;k++) if(a[j][k] || j==0 || k==0) f[i][j] = (f[i][j]+f[i-1][k])%R;for(int i=0;i&lt;=m;i++) ans = (ans+f[n][i])%R; 矩阵加速我们发现：上面的这个DP转移是由前一层状态转移到后一层状态，而我们最终需要第$n$层状态。 我们不妨设$F(i)$表示第$i$层的状态，即$F(i) = \\begin{bmatrix} f_{i,0}&amp;f_{i,1}&amp;f_{i,2}&amp;…&amp;f_{i,m} \\end{bmatrix}$，这是一个$1\\times (m+1)$阶的矩阵。 显然有$F(0) = \\begin{bmatrix}1&amp;\\overbrace{0 \\text{ }\\text{ }\\text{ }\\text{ }0\\text{ }\\text{ }\\text{ }\\text{ }…} \\end{bmatrix}$，后面的大括号里一共有$m$个$0$。 现在我们考虑怎么由$F(i-1)$推导$F(i)$。不妨把$a(x,y)$函数看成一个$(m+1)\\times (m+1)$阶的矩阵$A$，则有（注：乘号后面的$ A_{0\\text{~}m,j}$表示$A$矩阵的第$j$列，即一个$1\\times (m+1)$阶的矩阵）：$$ \\begin{aligned}&amp; F(i-1) \\times A_{0\\text{~}m,0} = f_{i,0} \\newline &amp; F(i-1) \\times A_{0\\text{~}m,1} = f_{i,1} \\newline &amp;… \\newline &amp; F(i-1) \\times A_{0\\text{~}m,m} = f_{i,m} \\end{aligned}$$ 故：$ F(i-1) \\times A = F(i)$$ $$ F(i) \\times A^k = F(i+k)$ 那么我们就可以用$F(0) \\times A^n = F(n)$推导出第$n$层状态，再求和就好了。 时间复杂度大约是$O(m^2\\log n )$。 一些细节$0$可以和任意一种花搭配，故$F,A$矩阵都是$k\\times {m+1}$阶级别的。因此在代码里我把$A$矩阵强行向右下平移了一格，即矩阵的有效区间是$(1\\text{~}m+1) \\times (1 \\text{~}m+1) $。在代码里看可能会更直白一些。 又因为$0$可以和任意一种花搭配，所以$A_{1,i} = A_{i,1} = 1 (i\\in[1,m+1])$（矩阵已经平移过了）。一定注意这一点！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CM = 102;const LL R = 1e9+7;int n,m;class matrix{ //定义矩阵 public: LL a[CM][CM]; int n,m; void MakeOne(int k){ n = m = k; for(int i=1;i&lt;=n;i++) a[i][i] = 1; } matrix operator * (const matrix &amp;b)const{ matrix rec = (matrix){{{0}}, n, b.m}; //注意别忘了定义相乘得到的矩阵的大小 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R ) %= R; return rec; } void operator *= (const matrix &amp;b) {*this = (*this)*b;}}A;matrix MatrixQuickPow(matrix &amp;a,LL b){ //矩阵快速幂 matrix rec; rec.MakeOne(a.m); while(b){ if(b &amp; 1) rec *= a; a *= a; b &gt;&gt;= 1; } return a = rec;}int main(){ //freopen(&quot;in.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); A.n = A.m = m+1; //平移后矩阵的大小是 (m+1)^2 for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++){ char c; cin&gt;&gt;c; if(c == '0') A.a[i+1][j+1] = 1; //平移 } for(int i=1;i&lt;=m+1;i++) A.a[1][i] = A.a[i][1] = 1; //初始化，0可以和任意花搭配 matrix c = (matrix){{{0}}, 1, m+1}; //定义 F(0) c.a[1][1] = 1; //初始状态 c *= MatrixQuickPow(A, n); //递推到 F(n) LL ans = 0; for(int i=1;i&lt;=m+1;i++) (ans += c.a[1][i]) %= R; //累加答案 printf(&quot;%lld&quot;,ans); return 0;}","link":"/2019/08/01/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%91%86%E8%8A%B1/"},{"title":"「题解」教主的魔法","text":"教主最近学会了一种神奇的魔法，能够使人长高…… 一 题目 原题链接 描述教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。 每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L, R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高） CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。 WD巨懒，于是他把这个回答的任务交给了你。 输入第1行为两个整数N、Q。Q为问题数与教主的施法数总和。第2行有N个正整数，第i个数代表第i个英雄的身高。第3到第Q+2行每行有一个操作：（1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。（2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。 输出对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。 二 题解元素的区间排名问题。使用分块解决，不过相比于模板问题，有一个地方需要稍微改动一下。 因为题目中让求“有多少英雄的身高大于等于C”，但是模板中lower_bound()找出来的是小于C的元素个数，假设这个值为$k$，那么在整块累加答案的时候应该加上的是$bcnt-k$（$bcnt$为块的大小同时也是块数）。但是还需要注意一个细节：最后一个块的大小不一定恰好等于块数。所以需要特判（详见代码）。 最后一个点是这题卡vector，会T一个点，如果用普通数组就没有问题。但是我懒得改代码了，所以吸O2过了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LL long longconst int CN=1e6+5;const int CB=1e3+3; //v defineint n,q;LL hg[CN];int sqr(int x){ for(int k=1;;k++) if(k*k &gt; x) return k;}//hzwer tqlint bel[CN],bcnt=0;LL tag[CB];vector&lt;int&gt;s[CB];void updata(int pos){ s[pos].clear(); for(int i=(pos-1)*bcnt+1; i&lt;=pos*bcnt; i++) s[pos].push_back(hg[pos]); sort(s[pos].begin(),s[pos].end());}void build(){ bcnt=sqr(n); for(int i=1;i&lt;=n;i++){ bel[i] = (i-1)/bcnt+1; s[bel[i]].push_back(hg[i]); } for(int i=1;i&lt;=bcnt;i++) sort(s[i].begin(),s[i].end());}void modify(int l,int r,LL c){ for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) hg[i] += c; updata(bel[l]); if(bel[l] != bel[r]){ for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) hg[i] += c; updata(bel[r]); } for(int i=bel[l]+1; i&lt;bel[r]; i++) tag[i] += c;}LL query(int l,int r,LL c){ LL ans=0; for(int i=l; i&lt;=min(bel[l]*bcnt, r); i++) if(hg[i]+tag[bel[i]] &gt;= c) ans++; if(bel[l] != bel[r]) for(int i=(bel[r]-1)*bcnt+1; i&lt;=r; i++) if(hg[i]+tag[bel[i]] &gt;= c) ans++; for(int i=bel[l]+1; i&lt;bel[r]; i++){ int x=c-tag[i]; vector&lt;int&gt;::iterator it=lower_bound(s[i].begin(),s[i].end(),x); int sum=bcnt; if(i == bcnt) //最后一个块可能不为整 sum = min(n-((i-1)*bcnt), bcnt); ans += sum-(it-s[i].begin()); } return ans;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;hg[i]); build(); while(q--){ char m; int l,r; LL c; cin&gt;&gt;m; scanf(&quot;%d%d%lld&quot;,&amp;l,&amp;r,&amp;c); if(m == 'M') modify(l,r,c); if(m == 'A') printf(&quot;%lld\\n&quot;,query(l,r,c)); } return 0;}","link":"/2019/03/15/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/"},{"title":"「题解」最优贸易","text":"C国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市…… 一 题目 原题链接 描述C国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1~n 号城市的水晶球价格分别为 4,3,5,6,1。 阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3 号城市以 5的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。 接下来 m 行，每行有 3 个正整数x,y,z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。 输出一个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。 二 题解本题的缩点做法不好想，缩点之后的DP是个难点，在某位cy巨佬的指点下才悟出正解。 1 思路考虑原图为DAG时的情况。 设$ val_i $为当前节点的物价，$ mn_i $为从$1$节点搜索到$i$节点的最小买入价格，$f_i$为从$1$节点到$i$节点的最大利润（不一定在$i$售出），则转移方程：$$ f_i =\\max { f_j,val_i-mn_i } | (j,i) \\in E$$也就是把状态分解成继承前面的状态（当前点不售出）和当前点售出，两者取较大值。 原图不一定为DAG，考虑使用tarjan缩点。那么转移方程也得变一变。 考虑一个连通分量的贡献。 这个最大利润可能出自同一个连通分量，也可能出自不同。 那么它的贡献分为两类（$mx_i$表示连通分量$i$中的最大售价，$mn_i$表示连通分量$i$中的最小进价，$totmn_i$表示连通分量$1-i$中的最小进价）： 最优解来自同一个连通分量。贡献为$mx_i-mn_i$。 最优解来自不同的连通分量，且在当前连通分量售出物品。贡献为$mx_i-totmn_i$。 最优解根当前联通分量不沾边。没有贡献并继承前面的最优解（因为状态设计的缘故，要满足无后效性） 转移方程$$ f_i=\\max { mx_i-mn_i,mx_i-totmn_i,f_j } | (j,i) \\in E $$ 转移需要按照拓扑序进行，再跑一遍拓扑即可。 2 实现边表 1234567891011121314151617181920const int CE=1e6+6;const int CP=1e5+5;const int INF=0x7f7f7f3f;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}void E_init(){ memset(hd,0,sizeof(hd)); ecnt=0;} 缩点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//tarjan主过程int dfn[CP],low[CP],idx=0;int stack[CP],top=0;bool ins[CP];int bel[CP],mn[CP],mx[CP],scnt=0;void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; stack[++top]=cur; ins[cur]=true; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { tarjan(to); low[cur] = min(low[cur], low[to]); } else if(ins[to]) low[cur] = min(low[cur], low[to]); } if(dfn[cur] == low[cur]) { int pos; scnt++; mx[scnt]=-INF; mn[scnt]=INF; while(true){ pos=stack[top--]; ins[pos]=false; bel[pos]=scnt; mx[scnt] = max(mx[scnt], val[pos]); mn[scnt] = min(mn[scnt], val[pos]); if(pos == cur) break; } }}void scc(){ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}//重新建图int in[CP];void re_build(){ E_init(); for(int i=1;i&lt;=m;i++) { if(bel[_x[i]] == bel[_y[i]]) //这里的_x,_y,_z都是图中边的输入数据 continue; add(bel[_x[i]], bel[_y[i]]); in[bel[_y[i]]]+=1; if(_z[i] == 2){ add(bel[_y[i]], bel[_x[i]]); in[bel[_x[i]]]+=1; //统计节点入度，为了跑拓扑 } }} DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//topo sortint list[CP];queue&lt;int&gt;Q;void tsort(){ for(int i=1;i&lt;=scnt;i++) if(!in[i]) Q.push(i); while(!Q.empty()){ int cur=Q.front(); Q.pop(); list[++list[0]]=cur; for(int k=hd[cur]; k; k=E[k].nxt){ in[E[k].to]--; if(!in[E[k].to]) Q.push(E[k].to); } }}//dpint dp(){ /*此时_x,_y已经用完，重复利用以节省空间*/ memset(_x,0,sizeof(_x)); //_x[i] : 从scc_1到scc_i的最小买入价格 memset(_y,0,sizeof(_y)); //_y[i] : 从scc_1到scc_i的最大利益 tsort(); /*先递推最小买入价格*/ for(int i=1;i&lt;=scnt;i++) _x[i] = mn[i]; for(int i=1;i&lt;=scnt;i++) { int cur=list[i]; for(int k=hd[cur]; k; k=E[k].nxt) _x[E[k].to] = min(_x[E[k].to], _x[cur]); } for(int i=1;i&lt;=scnt;i++) { int cur=list[i]; for(int k=hd[cur]; k; k=E[k].nxt) _y[E[k].to] = max(max(_y[E[k].to], _y[cur]), //维护最优解 或 继承状态 max(mx[E[k].to]-mn[E[k].to], mx[E[k].to]-_x[E[k].to]) //当前scc中的最大利益 或 当前最大价值减去之前最小差价 ); } return _y[bel[n]]; //返回解。注意这里的下标都是连通分量的编号}","link":"/2019/02/22/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/"},{"title":"「题解」派","text":"你感受过被疯狂卡精度的恐惧吗…… 一 题目 原题链接 描述我的生日要到了！根据习俗，我需要将一些派分给大家。我有N个不同口味、不同大小的派。有F个朋友会来参加我的派对，每个人会拿到一块派（必须一个派的一块，不能由几个派的小块拼成；可以是一整个派）。 我的朋友们都特别小气，如果有人拿到更大的一块，就会开始抱怨。因此所有人拿到的派是同样大小的（但不需要是同样形状的），虽然这样有些派会被浪费，但总比搞砸整个派对好。当然，我也要给自己留一块，而这一块也要和其他人的同样大小。 请问我们每个人拿到的派最大是多少？每个派都是一个高为1，半径不等的圆柱体。 输入第一行包含两个正整数N和F，1 ≤ N, F ≤ 10 000，表示派的数量和朋友的数量。第二行包含N个1到10000之间的整数，表示每个派的半径。 输出输出每个人能得到的最大的派的体积，精确到小数点后三位。 二 题解先分析这个“派的体积”。柱体体积公式$v=sh$，其中底面积$s=\\pi r^2$，故$v=\\pi r^2h$。 再继续分析。若当前确定的派的体积为$v_1$，半径为$r_1$；并且存在一个原体积为$v_2$,半径为$r_2$的派。那么当前这个派可以被切成$\\dfrac{v_1}{v_2}$块，也就是可以分给$\\dfrac{v_1}{v_2}$个人。 分析这个$\\dfrac{v_1}{v_2}$，有$\\dfrac{v_1}{v_2}=\\dfrac{\\pi r_1^2 h_1}{\\pi r_2^2 h_2}$。因$h_1=h_2=1$，上述分式可简化成$\\dfrac{v_1}{v_2}=\\dfrac{r_1^2}{r_2^2}$，也就是说一个派被分成的块数仅与当前确定的$r_1^2$有关（注意是平方）。 那么可以二分这个$r_1^2$，再计算面积即可。为什么不直接二分体积？体积是带着$\\pi$的，一定会是一个浮点数（小数）。二分本来就有精度折损，因此二分体积可能会带来极大的精度问题。 但是本题疯狂卡精度！！既卡最终得数的精度，甚至还卡$\\pi$的精度！真是丧心病狂…解决方法：对于最终得数，用long long储存$r_2$，并且每个$r^2$都乘上1e4以避免精度问题。虽然题面说保留三位小数，但并不代表乘上1e2就能避免被卡！对于$\\pi$，在定义的时候令pi=acos(-1.0)即可。注意要引用cmath（即c中的math.h）库。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;#define LL long longconst int CN=1e4+4;const double pi=acos(-1.0);LL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}//v defineLL n,m,_r[CN];LL l=0,r,mid;LL calc(LL k){ LL sum=0; for(int i=1;i&lt;=n;i++) sum += _r[i]/k; return sum;}int main(){ n=read(); m=read(); m+=1; for(int i=1;i&lt;=n;i++){ _r[i]=read(); (_r[i]*=_r[i])*=10000; //精度 r = max(r, _r[i]); } while(l &lt; r){ mid = (l+r+1)&gt;&gt;1; //强制上取整，避免死循环 if(calc(mid) &gt;= m) l = mid; else r = mid-1; } double v=(pi*l)/10000.0; printf(&quot;%.3lf&quot;,v); return 0;}","link":"/2019/04/20/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E6%B4%BE/"},{"title":"「题解」生成树求和","text":"多项式题单里面唯一会做的题/kk苦痛了一中午终于调出来了，写个题解纪念一下…… 原题 考虑先拆位 $O(\\log_3c)$，然后对于这一位，需要计算所有“生成树边权在三进制下不进位加法和”在十进制下的和。 考虑由于是不进位加法，最后的结果一定是 $0,1,2$ 中的一种。那么可以在边权上放一个 $t_u(x)=x^{c_u}$，可以用矩阵树定理求出一个 $A(x)=\\sum_T\\prod_u t_u(x)$，我们关注的是 $A(x)\\bmod x^3-1$ 这个多项式。 设结果是 $0,1,2$ 的分别有 $cnt[0/1/2]$ 棵树，假设这是第 $x(x\\ge 0)$ 位，那么贡献就是 $3^x(cnt[1]+2cnt[2])$。 那么只考虑计算 $cnt[1],cnt[2]$，可以发现不需要真的做循环卷积，直接将 $\\omega_3$ 代入多项式求值即可，也就是单位根反演： $$\\sum\\limits_{i\\ge 0}[3|(i-c)]a_i=\\dfrac{1}{3}\\sum\\limits_{k=0}^2\\omega_3^{-ck}\\sum\\limits_{i\\ge 0}a_i\\omega_3^{ki}$$ 很可惜模数没有单位根，考虑 $\\omega_3=e^{\\text i\\frac{2\\pi}{3}}=-\\frac{1}{2}+\\text i\\frac{\\sqrt 3}{2}$，设 $\\text i^2=-3$ 扩域即可。 这样就是 $O(3n^3\\log_3c)$。 注意基尔霍夫矩阵是度数矩阵减掉邻接矩阵，这里 $u$ 的度数指的是所有与其相邻点的边权和！！因为这个点自闭了一中午/kk 大常数辣鸡代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long LL; const int CN = 110, P = 1e9 + 7, i2 = (P + 1) &gt;&gt; 1;int read(){ int s = 0, ne = 1; char c = getchar(); for(; c &lt; '0' || c &gt; '9'; c = getchar()) if(c == '-') ne = -1; for(; c &gt;= '0' &amp;&amp; c &lt;= '9'; c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int qp(int a, int b){ int r = 1; for(; b; b &gt;&gt;= 1, a = (LL)a * a % P) if(b &amp; 1) r = (LL)r * a % P; return r;}int inv(int x) {return qp(x, P - 2);}class COMP{ public: int a, b; COMP operator + (const COMP &amp;o) const {COMP r; r.a = add(a, o.a), r.b = add(b, o.b); return r;} COMP operator - (const COMP &amp;o) const {COMP r; r.a = add(a, P - o.a), r.b = add(b, P - o.b); return r;} COMP operator * (const COMP &amp;o) const{ COMP r; r.a = (((LL)a * o.a - (LL)3 * b * o.b) % P + P) % P; r.b = ((LL)a * o.b + (LL)b * o.a) % P; return r; }} a[CN][CN], w[5];COMP I(int a, int b) {COMP o; o.a = a, o.b = b; return o;}bool extinv(COMP o) {return ((LL)o.a * o.a + (LL)3 * o.b * o.b) % P;}COMP inv(COMP o){ if(o.b) o.b = P - o.b; int t = ((LL)o.a * o.a + (LL)3 * o.b * o.b) % P; t = (t + P) % P, t = inv(t), o.a = (LL)o.a * t % P, o.b = (LL)o.b * t % P; return o;}COMP ne(COMP o) {if(o.a) o.a = P - o.a; if(o.b) o.b = P - o.b; return o;}int n, m, B, X[CN * CN], Y[CN * CN], W[CN * CN], ans;int bit(int x, int i) {while(i) x /= 3, i--; return x % 3;}COMP det(){ COMP res = I(1, 0); for(int i = 1; i &lt; n; i++){ int p = i; while(p &lt; n &amp;&amp; !extinv(a[p][i])) p++; if(p &gt;= n) return I(0, 0); if(i ^ p) swap(a[p], a[i]), res = ne(res); for(int j = i + 1; j &lt; n; j++){ COMP t = a[j][i] * inv(a[i][i]); for(int k = i; k &lt; n; k++) a[j][k] = a[j][k] - t * a[i][k]; } res = res * a[i][i]; } return res;}void work(int bi, int pw){ COMP cnt1 = I(0, 0), cnt2 = I(0, 0); for(int i = 0; i &lt; 3; i++){ memset(a, 0, sizeof(a)); for(int j = 1; j &lt;= m; j++){ int u = X[j], v = Y[j], c = bit(W[j], bi); if(c == 0) a[u][v] = a[v][u] = ne(w[0]), a[u][u] = a[u][u] + w[0], a[v][v] = a[v][v] + w[0]; if(c == 1) a[u][v] = a[v][u] = ne(w[i]), a[u][u] = a[u][u] + w[i], a[v][v] = a[v][v] + w[i]; if(c == 2) a[u][v] = a[v][u] = ne(w[i &lt;&lt; 1]), a[u][u] = a[u][u] + w[i &lt;&lt; 1], a[v][v] = a[v][v] + w[i &lt;&lt; 1]; } COMP cur = det(); cnt1 = cnt1 + cur * inv(w[i]), cnt2 = cnt2 + cur * inv(w[i &lt;&lt; 1]); } ans = add(ans, add((LL)cnt1.a * pw % P, (LL)2 * cnt2.a * pw % P));}int main(){ freopen(&quot;sum.in&quot;, &quot;r&quot;, stdin), freopen(&quot;sum.out&quot;, &quot;w&quot;, stdout); n = read(), m = read(), w[0] = I(1, 0), w[1] = I(P - i2, i2), w[2] = w[1] * w[1], w[3] = w[0], w[4] = w[1]; for(int i = 1; i &lt;= m; i++) X[i] = read(), Y[i] = read(), B = max(B, W[i] = read()); for(int k = 0, pw = 1; pw &lt;= B; pw *= 3, k++) work(k, pw); printf(&quot;%lld\\n&quot;, (LL)inv(3) * ans % P); return 0;} LOJ垫底了…我也不知道为什么常数会这么大…","link":"/2021/03/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%94%9F%E6%88%90%E6%A0%91%E6%B1%82%E5%92%8C/"},{"title":"「题解」灾后重建","text":"B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车…… 一 题目 原题链接 描述给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t_i ，你可以认为是同时开始重建，并在第t_i天重建完成，并且在当天即可通车。若t_i为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回−1。 输入第一行包含两个正整数N,M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数$ t_0, t_1,…, t_{N-1} $，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}$。 接下来M行，每行3个非负整数i,j,w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。接下来Q行，每行3个非负整数x,y,t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。 二 题解简化题意，就是给定一张无向图，并且节点$i$在时间$t_i$时才可用，求任意时间两个节点间的最短路（不连通输出-1）。 “任意点间最短路”，是不是有点钦点floyd的意味？ 看floyd的转移方式。设$f_{i,j,k}$表示仅考虑经过前$k$个点中转，点$i$到$j$的最短路。 $f_{i,j,k}$可以继承前面的状态（$f_{i,j,k-1}$），也可以尝试用新增的节点$k$来中转，那么转移方程：$$ f_{i,j,k} = \\min f_{i,j,k-1},f_{i,k,k-1}+f_{k,j,k-1} |(i,k) \\in E,(k,j) \\in E $$ 状态$f_{i,j}$的转移来自同一个层级（都是$k-1$），那么$k$这一维可以滚动（不过$k$一定在最外重循环）。转移方程变成：$$ f_{i,j} = \\min f_{i,j},f_{i,k}+f_{k,j} |(i,k) \\in E,(k,j) \\in E $$ 那么也就是说：随着$k$的变化，所经过的中转节点不断增加，从而使得最短路不断松弛。而本题就是要控制最短路经过的中转节点，在仅经过一些节点的情况下求出最短路。 也就有了下面的想法：把村庄按修建时间升序排序，以该顺序作为$k$这一维循环的顺序，来更新最短路。这样就能控制在某一时刻内，仅有$t_i \\leqslant t_k$的村庄$i$可以参与中转最短路。然后离线处理询问。把每个询问按照询问时间升序排序，若当前前$k$个村庄更新后可以回答（排序后的）第一个问题（$t_k \\geqslant t_q$，$t_q$是询问的时间），那么就记录答案，并删掉这个问题。不考虑排序消耗的时间，复杂度大约是$O(n^3+q)$。 但是出题人很良心：数据是排好序的（题目中加粗了）。那么直接排，然后顺序处理询问就好了。 注意点的编号是$0 \\text{~} n-1$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CN=220;const int INF=0x3f3f3f2f;//v defineint f[CN][CN],k=1,n,m,q;int bt[CN];void init(){ memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;i++) f[i][i]=0;}int main(){ n=read(); m=read(); init(); for(int i=1;i&lt;=n;i++) bt[i] = read(); while(m--){ int x=read(),y=read(),z=read(); x+=1; y+=1; //把编号变成1 ~ n f[x][y] = f[y][x] = z; } q=read(); while(q--) { int x=read(),y=read(),t=read(); x+=1; y+=1; if(bt[x]&gt;t || bt[y]&gt;t){ printf(&quot;-1\\n&quot;); continue; } while(bt[k]&lt;=t &amp;&amp; k&lt;=n){ //分段更新，每次一直更新到当前时间 = 询问时间 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]); k++; } if(f[x][y] &gt; INF) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,f[x][y]); printf(&quot;\\n&quot;); } return 0;}","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/"},{"title":"「题解」硬币购物","text":"一道有意思的容斥题 + 对于背包求方案数的总结…… 一 题目 原题链接 描述硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。 输入第一行 c1,c2,c3,c4,tot 下面tot行 d1,d2,d3,d4,s。 输出每次的方法数。 二 题解直接拆分物品多重背包肯定是要T掉的。 先考虑没有硬币限制的情况，那么就是完全背包求方案数。这里有点东西可说。 完全背包求方案数实际上就是一个完全背包的变形，不过有两种写法：不去重 和 去重，代码如下： 12345678910/* 不去重 */for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) if(j - c[i] == 0) f[j] += 1; else if(j - c[i] &gt; 0) f[j] += f[ j - c[i] ];/* 去重 */for(int i=1;i&lt;=n;i++){ f[ c[i] ] += 1; for(int j=c[i];j&lt;=m;j++) f[j] += f[ j - c[i] ];} 这两份代码的本质区别就是循环的顺序：先枚举物品 还是 先枚举空间。但是为什么对呢。 实际上，先枚举物品可以理解做人为地制定了一个取物品的“顺序”，一个物品在转移的时候，前面的物品就已经不可能再次被用来转移状态，因此不会出现重复；先枚举空间则反之。 然后是考虑容斥。 答案的容斥首先，对于给定的 s ，在不考虑限制的情况下，答案一定为 f[s] 。 现在来考虑限制。什么样的状态是不合法的？不妨我们先假定取了 (di+1) 枚硬币 i ，这肯定是不行的。考虑这部分硬币对答案的贡献：取过它们之后，还剩下 (s-ci(di+1)) 的面值没有被凑出，这一部分一共有 f[s-ci(di+1)] 种选取方案，那么一定包含 (di+1) 枚硬币 i 的方案的数量就是 1×f[s-ci(di+1)] = f[s-ci(di+1)] 。这部分是不合法的，因此减掉，答案变成 f[s] - f[s-ci(di+1)] 。 然后就是简单的容斥了：把减了两遍的部分加回来，再把加了两遍的部分减回去，再加，再减 …… 直到最后的区间两两无交（或只剩一个区间）。 然后就做完了，代码太丑就不放了，核心部分是这样的： 12345678910111213141516int k1 = (d[1]+1)*c[1],k2 = (d[2]+1)*c[2],k3 = (d[3]+1)*c[3],k4 = (d[4]+1)*c[4];if(s-k1 &gt;= 0) ans -= f[s-k1];if(s-k2 &gt;= 0) ans -= f[s-k2];if(s-k3 &gt;= 0) ans -= f[s-k3];if(s-k4 &gt;= 0) ans -= f[s-k4];if(s-k1-k2 &gt;= 0) ans += f[s-k1-k2];if(s-k1-k3 &gt;= 0) ans += f[s-k1-k3];if(s-k1-k4 &gt;= 0) ans += f[s-k1-k4];if(s-k2-k3 &gt;= 0) ans += f[s-k2-k3];if(s-k2-k4 &gt;= 0) ans += f[s-k2-k4];if(s-k3-k4 &gt;= 0) ans += f[s-k3-k4];if(s-k1-k2-k3 &gt;= 0) ans -= f[s-k1-k2-k3];if(s-k1-k2-k4 &gt;= 0) ans -= f[s-k1-k2-k4];if(s-k1-k3-k4 &gt;= 0) ans -= f[s-k1-k3-k4];if(s-k2-k3-k4 &gt;= 0) ans -= f[s-k2-k3-k4];if(s-k1-k2-k3-k4 &gt;= 0) ans += f[s-k1-k2-k3-k4];","link":"/2019/10/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/"},{"title":"「题解」糖果","text":"幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果…… 一 题目 原题链接 描述幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求 输入输入的第一行是两个整数 $N$，$K$。接下来 $K$ 行，表示这些点需要满足的关系，每行 $3$ 个数字，$X$，$A$，$B$。如果 $X=1$， 表示第 $A$ 个小朋友分到的糖果必须和第 $B$ 个小朋友分到的糖果一样多；如果 $X=2$， 表示第 $A$ 个小朋友分到的糖果必须少于第 $B$ 个小朋友分到的糖果；如果 $X=3$， 表示第 $A$ 个小朋友分到的糖果必须不少于第 $B$ 个小朋友分到的糖果；如果 $X=4$， 表示第 $A$ 个小朋友分到的糖果必须多于第 $B$ 个小朋友分到的糖果；如果 $X=5$， 表示第 $A$ 个小朋友分到的糖果必须不多于第 $B$ 个小朋友分到的糖果。 输出输出一行，表示 $\\text{lxhgww}$ 老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 $-1$。 二 题解本题的差分约束实现需要变一下，但不着急，先分析给出的条件。 罗列如下： 编号 条件 变换 1 $x_a=x_b$ $x_a-x_b \\leqslant 0,x_b-x_a \\leqslant 0$ 2 $x_a-x_b &lt; 0$ $x_a-x_b \\leqslant -1$ 3 $x_a-x_b \\geqslant 0$ $x_b-x_a \\leqslant 0$ 4 $x_a-x_b &gt; 0$ $x_b-x_a \\leqslant -1$ 5 $x_a-x_b \\leqslant 0$ \\ 在使用最短路求解差分约束的时候，不难发现影响系统的解（单源最短路）的只有图上的负权边。 对于本题，因为边权仅存在$0$或$-1$两种情况，故所求的最短路长度一定为负数或零。对于负数，原来的不等关系会不成立（它们仅针对正数），从而使求解出现一些偏差。也就是说，我们求出的解实际上是不等式解的相反数。进一步来讲，对于所有的$d_i$，满足$ -d_a - (-d_b) \\leqslant C$，与题目中推出的三角形不等式恰好相反！那直接这样建边一定是不行的。我们需要把题目中的条件乘上一个$-1$，这样我们求解最短路之后，$x_i=-d_i$才会是答案。 如下： 编号 原不等式 新不等式 对应连边 1 $x_a-x_b \\leqslant 0,x_b-x_a \\leqslant 0$ 同前 $ \\text{add(a,b,0) ;add(b,a,0)}$ 2 $x_a-x_b \\leqslant -1$ $x_b-x_a \\leqslant -1$ $ \\text{add(a,b,-1)}$ 3 $x_b-x_a \\leqslant 0$ $x_a-x_b \\leqslant 0$ $ \\text{add(b,a,0)}$ 4 $x_b-x_a \\leqslant -1$ $x_a-x_b \\leqslant -1$ $ \\text{add(b,a,-1)}$ 5 $x_a-x_b \\leqslant 0$ $x_b-x_a \\leqslant 0$ $ \\text{add(a,b,0)}$ 另，每个小朋友至少有一个糖果，所以最短路径长度需要初始为$-1$。 还有一个坑点（毒瘤），测试点#6是一个很长的链，所以在新建原点时，必须倒序连边，防止每次都会走链然后被卡TLE。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int CP=1e5+5;const int CE=CP*1008;const LL INF=0x7f7f7f7f7f7f3f3f;class fs{ public: int to,nxt; LL dist; void init(int t,int n,LL d){ to=t; nxt=n; dist=d; }}E[CE];int hd[CP],ecnt=0;void add(int x,int y,LL z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}int n,m;//spfaLL d[CP];int times[CP];bool ins[CP];bool spfa(int s){ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(times,0,sizeof(times)); d[s]=0; queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[e.to] &gt; d[u]+e.dist) //最短路 { d[e.to] = d[u]+e.dist; if(!ins[e.to]) { Q.push(e.to); ins[e.to]=true; if(++times[e.to] == n) //判负环 return false; } } } } return true;}int main(){ bool flag=false; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--) { int x,a,b; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;a,&amp;b); if(x==1){ add(a,b,0); add(b,a,0); } if(x==2){ //出现负自环边直接退出 if(a == b){ flag=true; break; } add(a,b,-1); } if(x==3) add(b,a,0); if(x==4){ if(a == b){ flag=true; break; } add(b,a,-1); } if(x==5) add(a,b,0); } for(int i=n; i; i--) //新建总源（必须倒序循环） add(0,i,-1); //这里相当于初始最短路径长度 if(spfa(0) &amp;&amp; !flag) { LL sum=0; for(int i=1;i&lt;=n;i++) sum+=d[i]; printf(&quot;%lld&quot;,-sum); //对sum取相反数 } else printf(&quot;-1&quot;); return 0;}","link":"/2019/02/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%B3%96%E6%9E%9C/"},{"title":"「题解」负载平衡问题","text":"2019.4第一道题，也是第二道wll24题，希望能rp++…… 一 题目 原题链接 描述G 公司有 n 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 n 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 输入文件的第 1 行中有 1 个正整数 n，表示有 n 个仓库。第 2 行中有 n 个正整数，表示 n 个仓库的库存量。 输出输出最少搬运量。 二 题解wll24题中蓝色的题目2/3，rp++。 本题有数学解法！但是我太菜了。 既然是最少搬运量，那么肯定跟费用流有关。关键就是这个怎么均分负载的问题了。 可以计算库存量（设它为$a_i$）的平均数$\\overline a$。如果有解，那么最后每个仓库的库存量都一定会是$\\overline a$。可以把仓库分成两类： $a_i &gt; \\overline a$ 的仓库$i$，记为图$L$。 $a_i &lt; \\overline a$ 的仓库$i$，记为图$R$。 $a_i = \\overline a$的仓库不会影响答案，所以放在哪一类里面都行。 很明显，$L$中节点的点权需要转移到$R$中节点去。把这个点权变成边权，那么新建总源$s$和总汇$t$，连边$s\\to L$，$L \\rightleftarrows R$与$R\\to t$。$s\\to L$边上的流量限制为$L$中节点点权超出$\\overline a$的部分，即$a_i - \\overline a$。$R\\to t$边上的流量限制为$R$中节点点权不足$\\overline a$的部分，即$\\overline a- a_i$。图上所有相邻节点互相连双向边，边上没有流量限制，因为可以无限转移。不过转移的费用就是$1$。 这样，当增广一条路时，$s\\to L$的边流量增大，$R\\to t$的边流量也增大，其实意味着$L,R$中点的点权会更接近于平均值$\\overline a$。当网络流达到最大时，也就是说所有不等于平均值的点权都已经被增广到平均值大小，也就达到了负载平衡（前提是保证有解！）。 然后只需要处理一下环。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=101*10;const int CE=CP*CP;const int INF=0x3f3f2f3f;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}class fs{ public: int from,to,nxt,flow,cap,cost; void init(int f,int t,int n,int w,int c,int s) {from=f; to=t; nxt=n; flow=w; cap=c; cost=s;}}E[CE];int hd[CP],ecnt=1;void _add(int x,int y,int c,int w){ E[++ecnt].init(x,y,hd[x],0,c,w); hd[x] = ecnt;}void add(int x,int y,int c,int w){ _add(x,y,c,w); _add(y,x,0,-w); //反向边 }//v defineint n,_a,s,t;int a[CP];//mcmfint maxflow=0,mincost=0;int d[CP],rst[CP],prv[CP];bool ins[CP];bool Augment(int _s,int _t){ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(prv,0,sizeof(prv)); memset(rst,0x3f,sizeof(rst)); queue&lt;int&gt;Q; Q.push(_s); d[_s] = 0; ins[_s] = true; while(!Q.empty()) { int u = Q.front(); Q.pop(); ins[u] = false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; d[e.to]&gt;d[u]+e.cost){ d[e.to] = d[u]+e.cost; prv[e.to] = k; rst[e.to] = min(rst[u], e.cap-e.flow); if(!ins[e.to]) Q.push(e.to),ins[e.to] = true; } } } return d[_t] &lt; INF;}void update(int _s,int _t,int r){ int pos=_t; while(pos != _s){ E[prv[pos]].flow += r; E[prv[pos]^1].flow -= r; pos = E[prv[pos]].from; }}void mcmf(int _s,int _t){ while(Augment(_s, _t)){ maxflow += rst[_t]; mincost += d[_t]*rst[_t]; update(_s,_t, rst[_t]); }}int main(){ n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),_a+=a[i]; _a /= n; s=n+1; t=n+2; for(int i=1;i&lt;=n;i++) //connect s/t with i if(a[i] &gt; _a) add(s,i, a[i]-_a, 0); else add(i,t, _a-a[i], 0); for(int i=2;i&lt;n;i++){ //connect between nodes add(i,i+1, INF, 1); add(i,i-1, INF, 1); } //circle add(1,n, INF, 1); add(1,2, INF, 1); add(n,1, INF, 1); add(n,n-1, INF, 1); mcmf(s,t); printf(&quot;%d&quot;,mincost); return 0;}","link":"/2019/04/02/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/"},{"title":"「题解」糖果传递","text":"我真是烦这种数学题啊，让人头秃。 ——某巨佬 一 题目 原题链接 描述有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。现要使每个小朋友获得均等糖果，请求出最小代价。 输入小朋友个数n。下面n行 ai。 输出求使所有人获得均等糖果的最小代价。 二 题解这种题型大概有两种通解：费用流解法（如网络流24题中的负载平衡问题）和数学解法。但是解法一特别容易被卡MLE，能运行的数据范围大概只有$n\\leqslant 100$，所以这题来谈谈数学解法。 假设有五个小朋友1,2,3,4,5，其中1号给了2号5颗糖，2号给了1号1颗糖，1号给了5号3颗糖，也可以看作1号给了5号3颗糖，2号给了1号-4颗糖。于是可以得出一个结论，即任意一个人给别人的糖数总可以看作一个定值。假设1号只给5号糖，2号只给1号糖，……，5号只给4号糖，且给的糖数分别为$x_1,x_2,…,x_5$，那么$x_1,x_2,…,x_5$一定有绝对值最小的确定的值。现在我们要使$\\sum\\limits_{1\\leqslant i\\leqslant 5}|x_i|$最小，显然要求出这些“确定的值”。 因为每个人最终拿到的糖数为$\\sum\\limits_{1\\leqslant i\\leqslant n}a_i \\div n$，设这个数为$\\overline a$，则有以下等式：$$\\begin{aligned} &amp; a_1 = \\overline a - x_2 + x_1 \\newline &amp; a_2 = \\overline a - x_3 + x_2 \\newline &amp; … \\newline &amp; a_5 = \\overline a - x_1 + x_5 \\end{aligned}$$移项，得：$$\\begin{aligned} &amp; x_2 = x_1 - (a_1-\\overline a) \\newline &amp; x_3 = x_2 - (a_2 - \\overline a) \\newline &amp; … \\newline &amp; x_5 = x_1 - (a_5 - \\overline a)\\end{aligned}$$将前式分别带入后式可得：$$\\begin{aligned} &amp; x_1 = x_1 \\newline &amp;x_2 = x_1 - (a_1-\\overline a) \\newline &amp;x_3 = x_1 - (a_1 + a_2 - 2\\overline a) \\newline &amp;… \\newline &amp;x_5 = x_1 - (a_1+a_2+a_3+a_4 - 4\\overline a)\\end{aligned}$$可知：$$ x_n = x_1 - (\\sum\\limits_{1\\leqslant 1&lt; n}a_i - (n-1)\\times \\overline a) $$ 设$c_1 = a_1 - \\overline a,c_2 = a_1 + a_2 - 2\\overline a,…$，以此类推，可知$x_n = x_1 - c_{n-1}$。同时有递推式$c_i = c_{i-1} + a_i - \\overline a$。这个递推式与$x$取值无关，且总有$c_0 = 0$，因此可以计算出所有$c_i$的值。 又有$x_2 = x_1 - c_1,x_3= x_1- c_2,…$，则$\\sum\\limits_{1\\leqslant i\\leqslant 5}|x_i|$可表示为：$$ |x_1| + |x_1 -c_1| +|x_1-c_2| + … +|x_1-c_4| $$这也可以看作数轴上每个$c_i$到$x_1$的距离之和。那么我们就要找一个$x_1$，使得在数轴上它到每个$c_i$的距离最小。这个$x_1$即是$c_1,c_2,…,c_4$的中位数。 证明先把$c_1,c_2,…,c_4$排好序，表示在数轴上，如下图所示。任取一$x_1$，则距离之和可以化为$\\text{dist}(c_1,c_4) + \\text{dist}(c_2,c_3) +2\\times \\text{dist}(c_2,x_1)$。其中$\\text{dist}(c_1,c_4) + \\text{dist}(c_2,c_3)$为定值，那么让$\\text{dist}(c_2,x_1) $最小一定会更优一点。它的最小值为$0$，此时$x_1$选在$c_2$上。归纳，可知将$x_1$选在$c_1\\text{~}c_4$中的一个点上一定要优一点。 然后再分别尝试$c_1,c_2,…,c_4$这些点，不难发现$x_1$选的越靠中间距离之和越小，故可知$x_1$取$c_1,c_2,…,c_4$的中位数。 那么$x_1$就很好求了，于是我们就解决了这个问题。注意当$n$为偶数时，两个中位数取哪一个都可以。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}const int CN=1e6+6;LL n,x1,a[CN],c[CN],_a;LL llabs(LL a) {return a&gt;0 ? a:-a;}int main(){ n=read(); LL sigma = 0; for(int i=1;i&lt;=n;i++) a[i] = read(),sigma += a[i]; _a = sigma/n; //求平均值 c[0] = 0; for(int i=1;i&lt;=n;i++) c[i] = c[i-1]+a[i]-_a; //递推c[i] sort(c+1,c+n+1); x1 = c[(n+1)/2]; //计算中位数 LL ans=0; for(int i=1;i&lt;=n;i++) ans += llabs(x1-c[i]); //求代价 printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2019/06/21/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/"},{"title":"「题解」苗条的生成树","text":"给定一张连通图，求所有生成树中最大边权与最小边权差最小的，输出它们的差值…… 一 题目 原题链接 描述求所有生成树中最大边权与最小边权差最小的，输出它们的差值。 输入输入文件包含多组测试数据，每组测试数据如下： 第1行：2个整数n m （2 ≤ n ≤ 100 and 0 ≤ m ≤ n(n − 1)/2），n表示顶点数，m表示边数。接下来m行，每行3个空格分开的整数a b w（1 ≤ w ≤ 10000） , 表示顶点a与顶点b之间有一条边，权值为w。 输出对每组测试数据，如果图存在生成树，输出生成树的差值最小的；否则，输出-1。 二 题解$n$不大，考虑暴力。 把边权升序排序，每次固定mst的第一条边，那么最后一条边也肯定固定了。（贪心原理：最后一条边越靠前差值越少）。枚举起始边，kruskal求最小生成树，维护最优解就好了。 复杂度大约是$O(q(m^2 +mlogm))$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=110;const int CE=CP*CP;const int INF=0x3f3f3f3f;class fs{ public: int from,to,dist; void init(int f,int t,int d) {from=f; to=t; dist=d;} bool operator &lt; (const fs&amp; e)const {return dist&lt;e.dist;}}E[CE];int ecnt=0;void add(int x,int y,int z){ E[++ecnt].init(x,y,z);}//并查集class ufs{ public: int fa[CP]; ufs() {for(int i=1;i&lt;CP;i++) fa[i]=i;} void init() {for(int i=1;i&lt;CP;i++) fa[i]=i;} int find(int u) {return fa[u]==u ? u : fa[u]=find(fa[u]);} bool exm(int x,int y) {return find(x)!=find(y);} void merge(int x,int y) {fa[find(x)]=find(y);}}s;//v defineint n,m;//mstint mst(){ sort(E+1,E+ecnt+1); int ans=INF; for(int st=1; st&lt;=ecnt; st++) //枚举起始边 { s.init(); int cnt=0,lst=-1; for(int k=st; k&lt;=ecnt&amp;&amp;cnt!=n-1; k++) //kruskal { fs e=E[k]; if(!s.exm(e.from,e.to)) continue; s.merge(e.from,e.to); lst=k; cnt++; } if(cnt != n-1) continue; //没能生成mst ans = min(ans, E[lst].dist-E[st].dist); //维护 } return ans==INF ? -1 : ans;}int main(){ //freopen(&quot;out.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); while(n) { ecnt = 0; //forward-star init while(m--) { int x=read(),y=read(),z=read(); add(x,y,z); } printf(&quot;%d\\n&quot;,mst()); n=read(); m=read(); } return 0;}","link":"/2019/03/24/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%8B%97%E6%9D%A1%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91/"},{"title":"「题解」解方程","text":"求高次方程$a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n=0$在区间$[1,m]$内的所有整数解…… 一 题目 原题链接 描述如题，求高次方程$a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n=0$在区间$[1,m]$内的所有整数解。 数据范围：$n\\leqslant 100,|a_i|\\leqslant 10^{10000},a_n\\ne 0,m&lt; 10^6$ 二 题解数据范围一看就是坑。首先$n\\leqslant 100,m&lt; 10^6$，那么就可以枚举答案，每次花$O(n)$的时间去验证答案的正误。但是系数太大了！高次方程又不存在通解公式，那我们只能把系数模大质数以储存下来。 分析不妨将方程看作函数。设高次函数$f(x) = a_0+a_1x+a_2x^2+a_3x^3+…+a_nx^n$，然后我们要把$a_0\\text{~}a_1$都模$R$，也就是把原函数变成$f’(x) = a_0\\text{ mod } R+(a_1\\text{ mod } R)x+(a_2\\text{ mod } R)x^2+(a_3\\text{ mod } R)x^3+…+(a_n\\text{ mod } R)x^n$。实际上这个函数应该在对$R$取模的情况下才有意义（即在取模意义下与$f(x)$大致重合）。 验证画出了$f(x) = 879+653x+597x^2+497x^3+432x^4+421x^5$的图像，$r(x)=f(x)\\text{ mod }397$的图像和$f’(x) = (85+256x+200x^2+100x^3+35x^4+24x^5)\\text{ mod }397$的图像。其中，对于相同的$x$，总存在$f(x) \\equiv r(x)(\\text{mod }397)$。而$r$与$f’$基本重合，故推出：若有$x$使得$f’(x)=k$，那么$f(x)\\equiv k(\\text{mod }397)$有几率成立。 但是别忘了：我们推出来的只是同余。也就是说，只是有几率会有$f’(x)=k \\Rightarrow f(x)\\equiv k (\\text{mod }R)$，实际上$f(x)$不一定恰好等于$k$。所以为了避免这个问题，$R$不妨选的大一点，然后最好是质数。当然，为了保证准确，也可以多选择几个$R$值，不过这会拖慢程序运行效率。 回到题目那么不妨选取两个大质数$R_1,R_2$，然后得到两个系数分别模$R_1,R_2$的函数$f’_1,f’_2$。枚举$x\\in [1,m]$，若对于同一个$x$，有$f’_1(x)=f’_2(x)=0$，则基本可以断定$x$是我们想要的解。 但是还要考虑运行效率。取余运算是很慢的，而算法复杂度为$O(nm)$，最高$O(10^8)$，再乘上一个大常数，无疑会TLE。但是可以发现，若$f’(x)\\text{ mod } R=0$，则一定有$f’(x+kR)\\text{ mod } R=0$。 证明把$a_n(x+kR)^n$展开，得：$$ \\begin{aligned} a_n(x+kR)^n &amp;= a_n[x^n+ b_1x^{n-1}kR + …+b_{n-1}x(kR)^{n-1}+(kR)^n] \\newline &amp; = a_nx^n + a_nb_1x^{n-1}kR+ … + a_nb_{n-1}x(kR)^{n-1}+a_n(kR)^n\\end{aligned}$$其中$(a_nb_1x^{n-1}kR+ … + a_nb_{n-1}x(kR)^{n-1}+a_n(kR)^n )\\text{ mod } R = 0$，因为都可以提出因式$kR$。所以得：$$ a_n(x+kR)^n \\equiv a_nx^n (\\text{mod }R) $$一般情况证明完成，也就是说对于任意正整数$n$都满足上面的式子。故$a_1\\text{}a_n$都分别同余于$a_1(x+kR)\\text{}a_n(x+kR)^n$。那么一定有$f’(x) \\equiv f’(x+kR) (\\text{mod }R)$。 所以我们只需要枚举$k\\in [1,R_1)$，处理出有哪些$k$，使$f’_1(k)=0$。然后再枚举$i\\in [1,m]$，若$i\\text{ mod }k=0$且$f’_2(i)=0$，则断定$i$是解。 附：常用大质数1e5+7,99991,1e8+7,1e9+7,998244353。 代码，其实long long可以不开。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 110;const int R1 = 99991; //R1小一点，提高运行效率const int R2 = 1e8+7; //R2大一点，提高精度int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}int n,m;LL a1[CN],a2[CN]; //f1,f2的系数bool is[CN*CN*CN]; //is[x] : 判断f1(x)是否为0int ans[CN*CN*CN];void aread(int i){ LL ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()){ a1[i]=((a1[i]&lt;&lt;1)+(a1[i]&lt;&lt;3)+c-'0')%R1; //记录系数 a2[i]=((a2[i]&lt;&lt;1)+(a2[i]&lt;&lt;3)+c-'0')%R2; } a1[i] *= ne; a2[i] *= ne;}bool calc(LL x,int R,LL* a){ LL f = 0; //f(x) for(int i=n;i;i--) ((f += a[i]) *= x) %= R; //秦九韶公式 (f += a[0]) %= R; //只有在取模意义下上面的推导才会成立 return !f;}int main(){ n = read(); m = read(); for(int i=0;i&lt;=n;i++) aread(i); for(LL i=1;i&lt;R1;i++) if(calc(i,R1,a1)) is[(int)i] = true; for(LL i=1;i&lt;=m;i++) if(is[(int)i%R1] &amp;&amp; calc(i,R2,a2)) ans[++ans[0]] = i; //记录答案 printf(&quot;%d\\n&quot;,ans[0]); for(int i=1;i&lt;=ans[0];i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;}","link":"/2019/07/12/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%A7%A3%E6%96%B9%E7%A8%8B/"},{"title":"「题解」青蛙的约会","text":"exgcd大水题…… 一 题目 原题链接 描述两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 输入输入只包括一行5个整数x，y，m，n，L。其中0&lt;x≠y &lt; =2000000000，0 &lt; m、n &lt; =2000000000，0 &lt; L &lt; =2100000000。 输出输出碰面所需要的天数，如果永远不可能碰面则输出一行”Impossible”。 二 题解实际上就是让你解一个同余方程……设k天之后相遇，那么就有x+km≡y+kn(mod L)，然后展开就是x+km=y+kn+qL，整理得到k(m-n)-qL=y-x，这不就是个exgcd么……处理一下负数问题就好了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL x,y,m,n,L;LL gcd(LL a,LL b) {return b?gcd(b,a%b):a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1,y = 0; return; } _exgcd(b,a%b,x,y); LL t = x; x = y; y = t-(a/b)*y;}bool exgcd(LL a,LL b,LL c,LL &amp;x,LL &amp;kx){ //通解 x + p*kx (p ∈ Z) LL g = gcd(a,b); if(c % g) return false; LL y; _exgcd(a,b,x,y); x *= c/g; kx = b/g; return true;}int main(){ scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;m,&amp;n,&amp;L); LL ans,kx; bool flag = true; if(m-n &lt; 0){ if(!exgcd(n-m,L,y-x,ans,kx)) flag = false; else{ ans = -ans; ans %= kx; if(ans &lt; 0) ans += kx; //搞成最小正数解 flag = true; } } else{ if(!exgcd(m-n,L,y-x,ans,kx)) flag = false; else{ ans %= kx; if(ans &lt; 0) ans += kx; //搞成最小正数解 flag = true; } } if(flag) printf(&quot;%lld&quot;,ans); else printf(&quot;Impossible&quot;); return 0;}","link":"/2019/08/16/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/"},{"title":"「题解」魔法猪学院","text":"K 短路模板题…… 一 题目 原题链接 描述能量守恒……iPig 今天就在进行一个麻烦的测验。iPig 在之前的学习中已经知道了很多种元素，并学会了可以转化这些元素的魔法，每种魔法需要消耗 iPig 一定的能量。作为 PKU 的顶尖学猪，让 iPig 用最少的能量完成从一种元素转换到另一种元素……等等，iPig 的魔法导猪可没这么笨！这一次，他给 iPig 带来了很多 1 号元素的样本，要求 iPig 使用学习过的魔法将它们一个个转化为 N 号元素，为了增加难度，要求每份样本的转换过程都不相同。这个看似困难的任务实际上对 iPig 并没有挑战性，因为，他有坚实的后盾……现在的你呀！ 注意，两个元素之间的转化可能有多种魔法，转化是单向的。转化的过程中，可以转化到一个元素（包括开始元素）多次，但是一但转化到目标元素，则一份样本的转化过程结束。iPig 的总能量是有限的，所以最多能够转换的样本数一定是一个有限数。具体请参看样例。 输入第一行三个数 N、M、E 表示iPig知道的元素个数（元素从 1 到 N 编号）、iPig已经学会的魔法个数和iPig的总能量。 后跟 M 行每行三个数 si、ti、ei 表示 iPig 知道一种魔法，消耗 ei 的能量将元素 si 变换到元素 ti 。 输出一行一个数，表示最多可以完成的方式数。输入数据保证至少可以完成一种方式。 二 题解简化题意：给定一张有向联通图，设图上$1\\to n$的最短路为长度为$d_1$，次短路长度为$d_2$，……，$k$短路长度为$d_k$。若$k$总满足$\\sum\\limits_{i=1}^k d_i \\leqslant E$，请求出最大的$k$值。 实际上就是让你求第$k$短路的大小。此题可以用A*算法解。 设估价函数$h(x)$表示$x\\to n$的最短距离（也就是反图上$n\\to x$的最短路）设$g(x)$为$1\\to x$已走过的距离。设启发函数$f(x)=g(x)+h(x)$，然后再跑A*。当遍历到一个节点$x$第$k$次时，当前的$g(x)$就是$1\\to x$的$k$短路。 当然你肯定不能这样直接跑。必要性剪枝：因为只需求出前$k$短，所以当遍历一个节点超过$k$次时，直接跳过该节点；可行性剪枝：当估价函数$f()$大于当前剩余的$E$值时，剪枝。然后你就可以写出下面这一份代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;#define DB doubleint read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}const int CP=1e7+7;const int CE=1e7+7;const DB INF=987654321.0;const DB EPS=1e-7;class fs{ // 边表 public: int to,nxt; DB dist; void init(int t,int n,DB d) {to=t; nxt=n; dist=d;}}E[CE];int hd[CP],ecnt=0;void add(int x,int y,DB z){ E[++ecnt].init(y,hd[x],z); hd[x]=ecnt;}void fsinit(){ // 边表重置 memset(hd,0,sizeof(hd)); ecnt=0;}// v defineint n,m,X[CP],Y[CP];DB _E,Z[CP];// dijkstraclass DJ{ public: DB v; int c; bool operator &lt; (const DJ &amp;x)const {return v&gt;x.v;}};priority_queue&lt;DJ&gt;Q;bool vis[CP];DB d[CP];void sp(int s){ // 反图上跑最短路 for(int i=1;i&lt;=n;i++) d[i] = INF; memset(vis,false,sizeof(vis)); d[s] = 0.0; Q.push((DJ){d[s],s}); while(!Q.empty()){ DJ u = Q.top(); Q.pop(); if(vis[u.c]) continue; vis[u.c] = true; for(int k=hd[u.c]; k; k=E[k].nxt){ fs v = E[k]; if(d[v.to] &gt; d[u.c]+v.dist){ d[v.to] = d[u.c]+v.dist; if(!vis[v.to]) Q.push((DJ){d[v.to],v.to}); } } }}// A*class state{ public: int c; DB g; // g:距离函数 d[c]:估价函数 bool operator &lt; (const state&amp; a)const {return g+d[c] &gt; a.g+d[a.c];}};priority_queue&lt;state&gt; _Q;int vistimes[CP];void A_star(int k){ memset(vistimes,0,sizeof(vistimes)); state cur = (state){1,0.0}; _Q.push(cur); while(!_Q.empty()){ cur = _Q.top(); _Q.pop(); if(cur.g+d[cur.c] &gt; _E) return; // 可行性剪枝 vistimes[cur.c]++; if(cur.c == n) {_E -= cur.g; continue;} if(vistimes[cur.c] &gt; k) continue; // 剪枝 for(int k=hd[cur.c];k;k=E[k].nxt){ state nxt = (state){E[k].to,cur.g+E[k].dist}; // 下个节点 _Q.push(nxt); } }}int main(){ n=read(); m=read(); scanf(&quot;%lf&quot;,&amp;_E); for(int i=1;i&lt;=m;i++){ X[i] = read(); Y[i] = read(); scanf(&quot;%lf&quot;,&amp;Z[i]); add(Y[i],X[i],Z[i]); // 反图 } sp(n); fsinit(); // 建正图 for(int i=1;i&lt;=m;i++) add(X[i],Y[i],Z[i]); A_star(_E/d[1]); // k &lt;= E/d[1]一定成立 printf(&quot;%d&quot;,vistimes[n]); return 0;} 然后你提交会发现：最多得92分？一个点被卡MLE？是的，这题专卡A*。您只需在读入之后添加这样一段玄学优化就好了，美之名曰“面向数据编程”。 1234if(_E == 10000000){ printf(&quot;2002000\\n&quot;); return 0;} 附 k短路模板需要在class::state中加入标记位进行状态判重。答案储存在kd[]数组中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int CP=1e3+3;const int CE=1e6+6;const int INF=0x3f3f3f3f;class fs{ public: int to,nxt; int dist; void init(int t,int n,int d) {to=t;nxt=n;dist=d;}}E[CE];int hd[CP],ecnt=0;// v defineint n,m;// DJclass DJ{ public: int v; /* 权值 */ int c; /* 编号 */ bool operator &lt; (const DJ &amp;a)const {return v &gt; a.v;} };priority_queue&lt;DJ&gt; Q;int d[CP]; // 以n为源的最短路bool vis[CP];void sp(int s){ memset(d,0x3f,sizeof(d)); memset(vis,false,sizeof(vis)); d[s] = 0; Q.push((DJ){d[s],s}); while(!Q.empty()){ DJ u = Q.top(); Q.pop(); if(vis[u.c]) continue; vis[u.c] = true; for(int k=hd[u.c];k;k=E[k].nxt){ fs v = E[k]; if(d[v.to] &gt; d[u.c]+v.dist){ d[v.to] = d[u.c]+v.dist; if(!vis[v.to]) Q.push((DJ){d[v.to], v.to}); } } }} /*A*h(x) : x-&gt;n 的最短路 : d[x] */class state{ public: int g; int x; bool vis[CP]; bool operator &lt; (const state &amp;a)const {return g+d[x] &gt; a.g+d[a.x];}};priority_queue&lt;state&gt; A;int vistimes[CP];int kd[CP]; // kd[i] : 储存起点(s)到节点i的k短路void A_star(int k,int s){ memset(vistimes,0,sizeof(vistimes)); state u = (state){0,s}; // 当前状态 memset(u.vis,false,sizeof(u.vis)); // 初始化标记位 u.vis[s]= true; A.push(u); while(!A.empty()){ u = A.top(); A.pop(); vistimes[u.x]++; if(vistimes[u.x] &gt; k) continue; // 剪枝 if(vistimes[u.x] == k) kd[u.x] = u.g; for(int k=hd[u.x];k;k=E[k].nxt){ if(u.vis[E[k].to]) continue; state v = (state){u.g+E[k].dist,E[k].to}; for(int i=1;i&lt;=n;i++) // 复制标记位 v.vis[i] = u.vis[i]; v.vis[E[k].to] = true; A.push(v); } }}/* k : 阈值 s : 起点 t : 终点 */int ksp(int k,int s,int t){ // 主求解函数 ...(build) // 建反图 sp(t); // 求以t为汇(终点)的最短路 ...(rebuild) // 建正图 A_star(k,s); return kd[t];}","link":"/2019/06/26/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E9%AD%94%E6%B3%95%E7%8C%AA%E5%AD%A6%E9%99%A2/"},{"title":"「题解」货币系统","text":"在网友的国度中共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]…… 一 题解 原题链接 描述在网友的国度中共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 n、面额数组为 a[1..n] 的货币系统记作 (n,a)。 在一个完善的货币系统中，每一个非负整数的金额 x 都应该可以被表示出，即对每一个非负整数 x，都存在 n 个非负整数 t[i] 满足 a[i]×t[i] 的和为 x。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 x 不能被该货币系统表示出。例如在货币系统 n=3, a=[2,5,9] 中，金额 1,3 就无法被表示出来。 两个货币系统 (n,a) 和 (m,b) 是等价的，当且仅当对于任意非负整数 x，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 (m,b)，满足 (m,b) 与原来的货币系统 (n,a) 等价，且 m 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 m。 输入输入文件的第一行包含一个整数 T，表示数据的组数。 接下来按照如下格式分别给出 T 组数据。 每组数据的第一行包含一个正整数 n。接下来一行包含 n 个由空格隔开的正整数 a[i]。 输出输出文件共有 T 行，对于每组数据，输出一行一个正整数，表示所有与 (n,a) 等价的货币系统 (m,b) 中，最小的 m。 样例输入123452 4 3 19 10 6 5 11 29 13 19 17 输出1225 二 题解先来分析一下给的样例：有四种面值，分别是$3,19,10,6$， 可以用集合表示成$A={ 3,19,10,6 }$。然后我们发现其中有些面值可以被其它面值组成，如$6$可以被$3$组成。我们把这些面值从集合里面删去，得到一个新的集合$A’={ 3,10 }$。然后我们发现只剩下两个元素，恰好是答案？！ 这难道就是数学题的魅力？ 于是可以猜想：若把答案货币系统$B={ m,b }$中的$b$数组看作集合$B$，当$B$中的元素最少时，总有一种方案是$B=A’$（$A’$是集合$A$中不能被集合内其他元素组成的元素组成的的集合）。 简单的证明：若$B$存在一种元素数更少的方案，则$B$中一定有若干元素能组成$A’$中的所有元素。因为$A’$中的元素是不能互相组成的，所以此时$B$中一定存在不在$A’$中的元素，也就是不在$A$中的元素。所以$A \\cap B \\neq A$，也就是说货币系统$A$不与$B$等价。 之后的问题就是怎么求出$A’$来。设$f_j$表示凑足$j$元钱最多能用到的钱币数，很明显有转移方程$$ f_j = \\max f_{j-a_i}+1 | a_i \\in A$$其实就是完全背包。跑一边然后找出所有$f$值等于$1$的面值$j$，则$j \\in A’$。因为只让求集合大小，所以累加答案就好了。 代码（真是简短）： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=2.5e4+4;const int INF=0x3f3f3f3f;int read(){ //快读 int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}//v defineint t,n,a[CN],f[CN];int main(){ t=read(); while(t--){ memset(f,0,sizeof(f)); n=read(); int mx=-INF; //面值最大值，下面跑背包用 for(int i=1;i&lt;=n;i++){ a[i]=read(); mx = max(mx,a[i]); } for(int i=1;i&lt;=n;i++) //完全背包 for(int j=a[i]; j&lt;=mx; j++) if(f[j-a[i]] || !(j-a[i])) f[j] = max(f[j], f[j-a[i]]+1); //转移 int cnt=0; for(int j=1;j&lt;=mx;j++) if(f[j]==1) cnt++; printf(&quot;%d\\n&quot;,cnt); } return 0;}","link":"/2019/03/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F/"},{"title":"主席树","text":"众所周知，主席树即可持久化值域线段树， 用于解决区间 $k$ 小值问题以及动态二维数点问题。 1 静态主席树 静态区间 k 小值 给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。 静态主席树一般指可持久化值域线段树，并不支持修改操作。 容易发现区间信息是满足可减性的，则只需要在每次插入时建立一个船新版本即可，查询也只需要对两个历史版本作差便能得到区间信息。类似的，01-Trie 与 Treap 之类的无法维护区间信息的数据结构也可以通过可持久化来实现区间信息的维护。 容易得出下面的这份代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], rt[CN * 50], ch[CN * 50][2], idx; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} void md(int &amp;u, int v, int l, int r, int p){ if(!u) u = make(); if(l == r) return (void)(d[u] = d[v] + 1); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, ch[v][0], l, m, p), rc = ch[v][1]; else md(rc, ch[v][1], m + 1, r, p), lc = ch[v][0]; d[u] = d[lc] + d[rc]; } int qu(int u, int v, int l, int r, int k){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = d[lc] - d[ ch[v][0] ]; if(s &gt;= k) return qu(lc, ch[v][0], l, m, k); else return qu(rc, ch[v][1], m + 1, r, k - s); }} D;int n, m, a[CN], val[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[i] = a[i] = read(); sort(val + 1, val + n + 1); val[0] = 1; for(int i = 2; i &lt;= n; i++) if(val[i] ^ val[i - 1]) val[ ++val[0] ] = val[i]; for(int i = 1; i &lt;= n; i++) D.md(D.rt[i], D.rt[i - 1], 1, val[0], id( a[i] )); while(m--){ int l = read(), r = read(), k = read(); printf(&quot;%d&quot;, val[ D.qu( D.rt[r], D.rt[l - 1], 1, val[0], k ) ]), puts(&quot;&quot;); }} 2 带修主席树 动态区间 k 小值 给定一个含有 $n$ 个数的序列 $a_1, a_2, …, a_n$ ，需要支持两种操作： Q l r k 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数 C x y 表示将 $a_x$ 改为 $y$ 带修主席树一般指树状数组套可持久化值域线段树。 容易发现主席树的每个版本是对区间信息做一个前缀和，这样如果在某个版本上修改是 $O(n)$ 的。既然是前缀和，套用树状数组的方式写主席树就好了，复杂度 $O(n\\log^2n)$ 。 于是容易得到下面的这份代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 4e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], ch[CN * 50][2], rt[CN], idx, n; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void md(int &amp;u, int l, int r, int p, int x){ // 修改不新建版本 if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, l, m, p, x); else md(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void cg(int u, int p, int x){ // 修改 BIT 中所有的树 while(u &lt;= rt[0]) md(rt[u], 1, n, p, x), u += lb(u); } int t1[101], t2[101]; // 把 O(log) 棵主席树的根搞下来 void qu_pre(int l, int r){ // (l, r] t1[0] = t2[0] = 0; int u = l; while(u) t1[ ++t1[0] ] = rt[u], u -= lb(u); u = r; while(u) t2[ ++t2[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int k){ if(l == r) return l; int m = (l + r) &gt;&gt; 1, s = 0; for(int i = 1; i &lt;= t1[0]; i++) s -= d[ ch[ t1[i] ][0] ]; for(int i = 1; i &lt;= t2[0]; i++) s += d[ ch[ t2[i] ][0] ]; if(s &gt;= k){ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][0]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][0]; return qu(l, m, k); } else{ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][1]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][1]; return qu(m + 1, r, k - s); } }} D;class QUERY { public: int tp, a, b, c;} Q[CN];int n, m, a[CN], val[CN];int id(int x) {return lower_bound(val + 1, val + val[0] + 1, x) - val;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); D.rt[0] = n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[ ++val[0] ] = a[i] = read(); for(int i = 1; i &lt;= m; i++) { char c; cin &gt;&gt; c; if(c == 'Q') Q[i].tp = 0, Q[i].a = read(), Q[i].b = read(), Q[i].c = read(); else Q[i].tp = 1, Q[i].a = read(), val[ ++val[0] ] = Q[i].b = read(); } sort(val + 1, val + val[0] + 1); int cnt = 1; for(int i = 2; i &lt;= val[0]; i++) if(val[i] ^ val[i - 1]) val[ ++cnt ] = val[i]; D.n = val[0] = cnt; for(int i = 1; i &lt;= n; i++) D.cg(i, id( a[i] ), 1); for(int i = 1; i &lt;= m; i++){ if(!Q[i].tp){ D.qu_pre(Q[i].a - 1, Q[i].b); printf(&quot;%d&quot;, val[ D.qu(1, val[0], Q[i].c) ]), puts(&quot;&quot;); } else D.cg(Q[i].a, id( a[ Q[i].a ] ), -1), a[ Q[i].a ] = Q[i].b, D.cg(Q[i].a, id( a[ Q[i].a ] ), 1); }} 由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，导致其常数巨大，不过它依然能在 1s 左右的时间内通过此题。 3 一道栗题 「CQOI2011」动态逆序对 给出 $1\\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，在每次删除一个元素之前统计整个序列的逆序对数。 如果是静态问题，那么只需要用权值树状数组就可以简单维护。 由于只有删除操作，考虑计算删除一个元素对答案的贡献（实际上是减少量而不是增加量），容易发现这样的查询同时存在下标和权值两个维度；下标即通过版本来区分，因此用主席树。考虑到修改和影响传递的过程，仿照上题套一个树状数组即可。 于是容易得到如下代码。同样的，由于代码中各种空间跳跃以及频繁出现的 Cache-Miss ，其常数巨大，不过它依然能在 1.2s 左右的时间内通过此题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT{ public: int d[CN * 50], rt[CN], ch[CN * 50][2], idx, n; #define lc ch[u][0] #define rc ch[u][1] SGT() {idx = 0;} int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void md(int &amp;u, int l, int r, int p, int x){ if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(lc, l, m, p, x); else md(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void cg(int u, int p, int x){ while(u &lt;= rt[0]) md(rt[u], 1, n, p, x), u += lb(u); } int t[CN]; void pqu(int r){ t[0] = 0; int u = r; while(u) t[ ++t[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int p){ if(l == r){ int s = 0; for(int i = 1; i &lt;= t[0]; i++) s += d[ t[i] ]; return s; } int m = (l + r) &gt;&gt; 1; if(p &lt;= m){ for(int i = 1; i &lt;= t[0]; i++) t[i] = ch[ t[i] ][0]; return qu(l, m, p); } else{ int s = 0; for(int i = 1; i &lt;= t[0]; i++) s += d[ ch[ t[i] ][0] ]; for(int i = 1; i &lt;= t[0]; i++) t[i] = ch[ t[i] ][1]; return s + qu(m + 1, r, p); } }} D;int n, m, a[CN], val[CN], rk[CN];int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) val[i] = a[i] = read(), rk[ a[i] ] = i; D.rt[0] = D.n = n; LL ans = 0; for(int i = 1; i &lt;= n; i++) D.cg(i, a[i], 1), D.pqu(i - 1), ans -= D.qu(1, n, a[i]), D.pqu(i - 1), ans += D.qu(1, n, n); m -= 1; while(m--){ printf(&quot;%lld&quot;, ans), puts(&quot;&quot;); int x = read(), p = rk[x], s1, s2; D.cg(p, x, -1); D.pqu(p - 1), s2 = D.qu(1, n, x); D.pqu(p - 1), s1 = D.qu(1, n, n) - s2; D.pqu(n), s2 = D.qu(1, n, x) - s2; ans -= s1 + s2; } printf(&quot;%lld&quot;, ans);} 4 二维数点 「SHOI2007」园丁的烦恼 维护二维坐标系上的 $n$ 个点，$q$ 次查询矩形 $(a,b):(c,d)$ 内的点的个数。 二维数点是一类宽泛的 RMQ 问题，甚至于许多树上问题都能通过 dfs 序转化成二维数点问题。 众所周知，带修主席树可以用来解决动态二维数点问题，其本质与上面的题目类似。对于静态的二维数点，带修主席树 $O(n\\log^2n)$ 的复杂度要比 $O(n\\log n)$ 的树状数组解法要劣，可通过实现一个版本修改函数来避免带修。具体实现也较为简单，因此不再赘述。 这里给出一份带修主席树解决静态二维数点的代码，使用时需注意常数因子对程序效率带来的影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e6 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SGT { public: int d[CN * 50], ch[CN * 50][2], rt[CN], idx, n, m; #define lc ch[u][0] #define rc ch[u][1] int make() {return ++idx;} int lb(int x) {return x &amp; (-x);} void pmd(int &amp;u, int l, int r, int p, int x){ if(!u) u = make(); if(l == r) return (void)(d[u] += x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) pmd(lc, l, m, p, x); else pmd(rc, m + 1, r, p, x); d[u] = d[lc] + d[rc]; } void md(int u, int p, int x) {while(u &lt;= m) pmd(rt[u], 1, n, p, x), u += lb(u);} int t1[25], t2[25]; void pqu(int s, int t){ int u = s; t1[0] = 0; while(u) t1[ ++t1[0] ] = rt[u], u -= lb(u); u = t; t2[0] = 0; while(u) t2[ ++t2[0] ] = rt[u], u -= lb(u); } int qu(int l, int r, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t){ int ans = 0; for(int i = 1; i &lt;= t2[0]; i++) ans += d[ t2[i] ]; for(int i = 1; i &lt;= t1[0]; i++) ans -= d[ t1[i] ]; return ans; } int m = (l + r) &gt;&gt; 1, ans = 0, tmp1[25], tmp2[25]; if(s &lt;= m){ if(m &lt; t) memcpy(tmp1, t1, sizeof(t1)), memcpy(tmp2, t2, sizeof(t2)); for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][0]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][0]; ans += qu(l, m, s, t); if(m &lt; t) memcpy(t1, tmp1, sizeof(tmp1)), memcpy(t2, tmp2, sizeof(tmp2)); } if(m &lt; t){ for(int i = 1; i &lt;= t1[0]; i++) t1[i] = ch[ t1[i] ][1]; for(int i = 1; i &lt;= t2[0]; i++) t2[i] = ch[ t2[i] ][1]; ans += qu(m + 1, r, s, t); } return ans; }} D;int n, m, vX[CN], vY[CN], X[CN], Y[CN];int idx(int x) {return lower_bound(vX + 1, vX + vX[0] + 1, x) - vX;}int idy(int x) {return lower_bound(vY + 1, vY + vY[0] + 1, x) - vY;}class QU {public: int a, b, c, d;} q[CN];int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) vX[i] = X[i] = read() + 1, vY[i] = Y[i] = read() + 1; vX[0] = vY[0] = n; for(int i = 1; i &lt;= m; i++) vX[ ++vX[0] ] = q[i].a = read() + 1, vY[ ++vY[0] ] = q[i].b = read() + 1, vX[ ++vX[0] ] = q[i].c = read() + 1, vY[ ++vY[0] ] = q[i].d = read() + 1; sort(vX + 1, vX + vX[0] + 1), sort(vY + 1, vY + vY[0] + 1); int tmp = 1; for(int i = 2; i &lt;= vX[0]; i++) if(vX[i] ^ vX[i - 1]) vX[++tmp] = vX[i]; vX[0] = tmp; tmp = 1; for(int i = 2; i &lt;= vY[0]; i++) if(vY[i] ^ vY[i - 1]) vY[++tmp] = vY[i]; vY[0] = tmp; D.n = vY[0], D.m = vX[0]; for(int i = 1; i &lt;= n; i++) D.md( idx( X[i] ), idy( Y[i] ), 1); for(int i = 1; i &lt;= m; i++){ int a = q[i].a, b = q[i].b, c = q[i].c, d = q[i].d; D.pqu(idx(a) - 1, idx(c)), printf(&quot;%d&quot;, D.qu(1, D.n, idy(b), idy(d))), puts(&quot;&quot;); }}","link":"/2020/08/17/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"title":"元旦闲扯","text":"又是一个元旦，高二也过去了大半了。高中的最后一个元旦晚会错过了，不知道高三还有没有这样的机会。2021 是一个新的起点，想一想，还是需要写下一点东西来记一些事情的。 [00:19.58]なんとなく、でいいよね？总觉得…也可以吧？ [00:23.27]「気があいますね」「真是心有灵犀呢」 [00:27.09]おんなじ時に会いたくなるってシンクロリズム 在同一个时刻突然会变得想见到彼此 [00:34.33] [00:34.84]どんなあいさつだったら 该怎样打招呼 [00:38.49]「気がつきますか？」「才能让她注意到？」 [00:42.23]小さな声でもかならず手を振ってよ 虽然声音很小但是肯定会挥着手吧 [00:48.33] [00:49.46]こんな毎日が続きますようにと 许下「这样的日子能够继续下去」的愿望 [00:57.51]ティースプーンを投げたら 然后把茶匙投出的话 [01:03.17] [01:05.25]お茶のカミサマ 聞いてくれるかも 茶叶的神明大人 或许就能听到呢 [01:12.52]いつか大人になる でもでもでも遊ぼうよ 总有一天大家都会长大 但是但是但是来玩耍吧 [01:20.32]お茶のカミサマ みんなを見ていて 茶叶的神明大人 注视着大家 [01:27.66]やさしい大人になる そしてそして…それ以上わからないっ 要成为温柔的大人哦 然后然后然后…之后的事还不明白呢 [01:37.24] [01:43.43]なんとなく、がいいよね？总觉得…也可以吧？ [01:47.12]「明日もきてね」「明天还要来噢」 [01:50.88]きっと話したいことがあるシンクロミライ 一定还有很多想说的话 心灵相通的未来 [01:58.09] [01:58.58]とっても楽しいから 今天很开心哦 [01:59.77]「明日もくるよ」「明天还会来的」 [02:06.09]大きな声で笑っちゃえ 今日の続き放声欢笑 继续今天的话题 [02:12.89] [02:13.26]夢はふわふわと曖昧なままなの 梦是轻飘飘软绵绵的样子 [02:21.27]ポットからの湯気みたい 就像壶中冒出的热气一样 [02:26.94] [02:28.99]珈琲のカミサマ 白いミルクで 咖啡的神明大人 用洁白的牛奶 [02:36.30]いつか大人になる わたしたちを 描いて描绘出长大成人的 我们的模样 [02:44.22]珈琲のカミサマ みんなでいつかは 咖啡的神明大人 大家一定都会 [02:51.53]かわいい大人になる つもりだけど…それ以上わからないっ 成为可爱的大人…虽然这样打算 但是该怎么做呢 [03:00.98] [03:02.80]だからミライのあれこれを なんとなく語るけど 所以说虽然不由地就会 聊起未来的这样那样 [03:11.00]なんとなく、のままわからない まあいいっか！ 但是就这样，憧憬着未知的未来 不是挺好吗 [03:20.62] [03:35.80]お茶のカミサマ みんなを見ていて 茶叶的神明大人 注视着大家 [03:42.92]やさしい大人になる つもりだからがんばる 要成为温柔的大人 因为这样打算 所以要努力呢 [03:51.01]珈琲のカミサマ 白いミルクで 咖啡的神明大人 用洁白的牛奶 [03:58.14]いつか大人になる わたしたちを描いて 描绘出长大成人的 我们的模样 [04:06.10]珈琲のカミサマ みんなでいつかは 咖啡的神明大人 大家一定都会 [04:13.22]かわいい大人になる つもりだけど…それ以上わからないっ 成为可爱的大人…虽然这样打算 但是该怎么做呢 [04:23.38] var ap = new APlayer({ element: document.getElementById(\"aplayer-HdJFoZTO\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"なんとなくミライ\", author: \"Petit Rabbit's\", url: \"/pictures/bgm1.mp3\", pic: \"/pictures/bgm1.png\", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 先放一首歌，感觉扔在这里还是很应景的。 2020 年对我来说的确是不平凡的一年，从一个老年退役菜鸡变成一个老年没退役菜鸡，甚至还想去考一场 NOI，六个月之前，这是想都不敢想的事情。 CSP2019 游记里面我并没有放多少回忆，因为我混沌的高一生涯的确没能留下多少值得记录的事情。 回首半年前在宿舍对着 11D 的洛谷网课讲义硬啃 DFT，发现一个数的 $n$ 次根实际上有 $n$ 个的时候，感觉就像看到了新大陆。然而不得不说，当年的我就是这么 naive。 但是事实是我成功的苟过了 CSP2020 和 NOIP2020，为冲击省队留出了一线希望。 “苟”属于用词准确，因为根本不是我考得好，而是比我强的都考的差。 CSP2020，洛谷估分 40+75+50+0=165，挂的连骨灰都不剩下了，可是谁曾想 CCF 给我来了个 60+100+70=230。 NOIP2020 终于没挂成暴力分，可是 90+84+0+40=214 究竟算好吗？显然不是，先不说 T3 的考场降智，实际就连 T4 80pts 的暴力都只能嘴巴，写了 60pts 却被卡常成真·暴力分。 人生三大错觉：CCF机子快，我能过，我是松怪 突击补学完一大堆知识点显然是缺少了一点积累，只能嘴巴和脑子短路这两个问题，时至今日依然成为了我考试垫底的最强动力。 可是侥幸的是路并没有在此完结，可喜可贺，2021 年，我依然是一个老年没退役菜鸡。 几年前在大佬 $w{\\color{Red}{jyyy}}$ 的博客中读到一篇 NOI 游记，如下写道： “很多寝室人都走完了，也熄灯了，此时我的 OI 路也只剩下了最后一盏。” 大佬不幸地以 Cu rk1 的成绩退役，但是至少他走完了这一程。在回忆的终点，踏上归程的时候，无论结果如何，希望我也能留下铭刻着一段时光的文字。 以上 祝各位元旦快乐。 qwq","link":"/2021/01/01/%E5%85%83%E6%97%A6%E9%97%B2%E6%89%AF/"},{"title":"利用vector重现set","text":"提供一种小数据下运行效率极高的std::set替代方法。 此页面存在相关页面。关于普通平衡树，请参见「Splay」。 众所周知，平衡树有两类：一类维护集合，一类维护序列。维护序列的平衡树通常作为线段树的替代，用于解决线段树并不支持的区间翻转操作；而维护集合的平衡树则可以被看作是在重现std::set。 但是这并不是最简便的方案，实际上，我们可以利用std::vector去吊锤维护集合的平衡树。此种方法在 $10^5$ 量级下速度极快，运行时间甚至优于普通 Splay。 维护集合的平衡树被用来解决这样一类问题： 您需要写一种数据结构，来维护一些数，其中需要提供以下操作： 插入 $x$ 数 删除 $x$ 数（若有多个相同的数，因只删除一个） 查询 $x$ 数的排名（排名定义为比当前数小的数的个数 $+1$） 查询排名为 $x$ 的数 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数） 求 $x$ 的后继（后继定义为大于 $x$，且最小的数） 设 $n$ 为集合的最大大小，对所有数据，满足 $n\\le 10^5$。 利用std::lower_bound和std::upper_bound，可以得到下面的这样两条语句： 12lower_bound(v.begin(), v.end(), x) - v.begin() // &lt; x 的元素个数upper_bound(v.begin(), v.end(), x) - v.begin() // &lt;= x 的元素个数 于是可以得到下面这份代码实现。显然，它吊锤了 Splay。 1234567891011vector&lt;int&gt; v; int n = read();while(n--){ int tp = read(), x = read(); if(tp == 1) v.insert(lower_bound(v.begin(), v.end(), x), x); if(tp == 2) v.erase(lower_bound(v.begin(), v.end(), x)); if(tp == 3) printf(&quot;%d&quot;, lower_bound(v.begin(), v.end(), x) - v.begin() + 1); if(tp == 4) printf(&quot;%d&quot;, v[x - 1]); if(tp == 5) printf(&quot;%d&quot;, v[lower_bound(v.begin(), v.end(), x) - v.begin() - 1]); if(tp == 6) printf(&quot;%d&quot;, v[upper_bound(v.begin(), v.end(), x) - v.begin()]); if(tp &gt; 2) puts(&quot;&quot;);} 理性分析一下，这份代码的时间复杂度为 $O(n^2\\log n)$，瓶颈在于erase()和insert()。 但是我们可以对其进行测试，Generator 如下： 12345678910111213#include&lt;cstdio&gt;#include&lt;string&gt;int n = 100000;int main() { freopen(&quot;_in.in&quot;, &quot;w&quot;, stdout); printf(&quot;%d&quot;, n), puts(&quot;&quot;); int t1 = 1, t2 = 1000000000; for(int i = 1; i &lt; n; i++){ if(i &amp; 1) printf(&quot;1 %d&quot;, t1++), puts(&quot;&quot;); else printf(&quot;1 %d&quot;, t2--), puts(&quot;&quot;); } printf(&quot;4 %d&quot;, n / 2);} 本机测试结果如下： 数据范围 $n=5\\times10^4$ $n=10^5$ $n=5\\times 10^5$ $n=10^6$ 运行时间（平均，向下近似） 100ms 280ms 7.7s 30s 运行时间（平均，向下近似，O2） 70ms 280ms 7s 28s 对比（普通 Splay） 30ms 30ms 260ms 380ms 容易发现当 $n$ 超过 $10^5$ 的量级后，其运行效率略大于 $O(n\\sqrt{n})$，而在之前效率及其优秀。但是实际上题目中插入操作的数量并没有达到测试中的量级，因此出现了吊锤 Splay 的现象。 于是我们可以初步地得出结论：在 $10^5$ 的数据量级下，利用vector代替 Splay 有着优秀的运行效率。 一个栗子 $n$ 个点的图，给出 $m$ 对点和 $q$ 条边。顺序尝试加入每条边，如果不会使得 $m$ 对点中的任意一对点联通，则加入，否则不加入。判断每条边是否会被加入。$n,m,q\\le 10^5$ 条件反射：看到不可逆性修改操作，就应该想到结构合并。 容易想到对每个点维护一个set，表示该点不能到达的点集，然后连一条边相当于合并两个set，在合并前判断一下，然后启发式合并就好了。然后把set换成vector，运行时间得以缩小一半。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int CN = 2e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class DSU { public: int fa[CN]; DSU() {for(int i = 1; i &lt;= 100000; i++) fa[i] = i;} int fd(int x) {return fa[x] ^ x ? fa[x] = fd( fa[x] ) : x;}} C;int n, m, q; vector&lt;int&gt; v[CN];int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(), q = read(); while(m--){ int x = read(), y = read(); v[x].push_back(y), v[y].push_back(x); } while(q--){ int x = read(), y = read(), fx = C.fd(x), fy = C.fd(y); if(fx == fy) {putchar('1'); continue;} int szx = v[fx].size(), szy = v[fy].size(); if(szx &gt; szy) swap(fx, fy), swap(szx, szy); bool flag = true; for(int i = 0; i &lt; szx &amp;&amp; flag; i++) if(C.fd( v[fx][i] ) == fy) flag = false; if(!flag) {putchar('0'); continue;} putchar('1'); /* fx -&gt; fy */ C.fa[fx] = fy; for(int i = 0; i &lt; szx; i++){ int u = v[fx][i], p = lower_bound(v[fy].begin(), v[fy].end(), u) - v[fy].begin() - 1; if(v[fy][p] == u) continue; v[fy].insert(lower_bound(v[fy].begin(), v[fy].end(), u), u); } }}","link":"/2020/08/28/%E5%88%A9%E7%94%A8vector%E9%87%8D%E7%8E%B0set/"},{"title":"二分图匹配","text":"设$G=(V,E)$（$V$为点集，$E$为边集）是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集 $(i \\in A,j \\in B)$，则称图$G$为一个二分图…… 一 定义1 什么是二分图 设$G=(V,E)$（$V$为点集，$E$为边集）是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集 $(i \\in A,j \\in B)$，则称图$G$为一个二分图。 如下图，一张图被分为$U$，$V$两个点集，每个点集内部均无边，则是一个二分图。 2 什么是匹配在一个二分图$G$中选出$k$条边，组成新图$G’$，使得任意一条边的两个端点都与其他边的端点不重合，则称$G’$为$G$的一个匹配。 上图中，若$U$集编号从上至下为$1,2,3,4,5$，$V$集编号从上至下为$a,b,c,d$，则$(2,b),(5,a)$是一个匹配。 3 最大匹配在一个二分图$G$中，匹配$G_m$的边数最大（仅考虑不带权匹配），则称$G_m$为$G$的最大匹配。 上图中，若$U$集编号从上至下为$1,2,3,4,5$，$V$集编号从上至下为$a,b,c,d$，则$(1,a),(2,b),(3,c),(5,d)$是最大匹配。 4 增广与增广路从$U$集一未匹配点开始，找一个并$V$集的未匹配点并进行匹配（前提是有连边）的过程称为增广。连接两个新匹配点间的边被称为增广路。 二 判定二分图的判定可以有染色法解决。因为二分图中不存在奇圈，故若用两种颜色将二分图中的每个节点染色，且使得相邻的节点颜色不同，若存在一种合法方案，就可以判定图是二分图。 用dfs模拟染色过程，一旦发现颜色冲突就跳出染色，否则返回染色成功即可。 1234567891011121314151617181920212223242526272829303132333435const int CP=1e4;const int CE=1e5;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}//paintint col[CP]; //col[i]=0 : 未染色 //col[i]=1 : 颜色1 //col[i]=-1 : 颜色2 bool dfs(int u,int c){ col[u] = c; for(int k=hd[u]; k; k=E[k].nxt){ int to=E[k].to; if(col[to] == c) return false; //冲突 if(!col[to] &amp;&amp; !dfs(to,-c)) return false; //向下递归 } return true;}bool examine(){ for(int i=1;i&lt;=n;i++) if(!col[i]){ int flag = dfs(i,1); if(!flag) return false; } return true;} 三 匈牙利算法1 流程 step1以$1$为起点，找一条增广路，选中$(1,a)$（蓝线）。 step2以$2$为起点，找一条增广路，试图选中$(2,a)$（红线）。发现$a$已被匹配，故从$2$开始，走匹配边（蓝线）到$1$，试图寻找增广路，失败。故$a$无法失配，配对失败。 此处若能寻找到增广路$(1,x)$，则$a$失配并与$2$配对，$1$重新与$x$配对，因为这样实际上增加了一条匹配边。 step 3继续以$2$为起点，找一条增广路，选中$(2,c)$（蓝线）。 step 4以$3$为起点，找一条增广路，选中$(3,b)$（蓝线）。至此，左图中所有点皆以匹配完成，算法结束。 2 代码实现（match）判断能否增广的过程需要一遍dfs，且需要知道 能(true)与否(false)。故我们需要定义一个返回值为bool的dfs。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//match/*节点1~n:左图节点节点n+1~2n:右图节点边表存图，E为边集*/const int CON=2e3+3;//边表class fs{ public: int to,nxt;}E[CON];int hd[CON],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}bool ins[CON]; //判断右图的节点是否已经被访问过int mtclf[CON]; //mtclf[i]为左图节点i在右图中的匹配节点int mtcrt[CON]; //mtclf[i]为右图节点i在左图中的匹配节点bool dfs(int cur){ for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; //to一定在右图中 if(!ins[to]) //不走回头路 { ins[to] = true; if(!mtcrt[to] || dfs(mtcrt[to])) //若to为没有匹配的节点，或从to节点开始可以找到新的增广路 { mtclf[cur] = to; //to失配并与当前节点配对 mtcrt[to] = cur; return true; //找到了一条增广路 } } } return false; //无法增广}int match(){ int ret=0; //统计答案数 for(int st=1; st&lt;=n; st++) //遍历起点（左图中） if(!mtclf[st]) { memset(ins,false,sizeof(ins)); if(dfs(st)) ret++; //每次dfs仅找到一条增广路，故答案+1 } return ret; //返回答案}","link":"/2019/02/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"title":"单调队列","text":"常见的队列一般分为两类：FIFO（先进先出）型和特定元素优先型。第一类常称作普通队列，第二类常被称作优先队列，它实际上更像是一个小根堆…… 一 引入在讲解单调队列之前， 让我们先回顾一下普通队列。 1 为什么需要单调队列常见的队列一般分为两类：FIFO（先进先出）型和特定元素优先型。第一类常称作普通队列，第二类常被称作优先队列，它实际上更像是一个小根堆。二者的用处也不尽相同，前者用于维护进队次序上的先入队者，而后者用来维护数值上的极大（小）者。对于这两类，STL中都有相应的模板，常数也不是很大，而且支持的操作也很多，因此只在这里罗列一下： 123456789101112131415//queue and priority_queue in STL#include&lt;queue&gt;using namespace std;queue&lt;int&gt;Q;Q.push(); //插入Q.front(); //返回队首元素Q.pop(); //出对Q.empty(); //返回是否队空priority_queue&lt;int&gt;heap;heap.push(); //插入heap.top(); //返回堆顶heap.pop(); //删除heap.empty(); //返回是否堆空 但是如果我们遇到这样一个问题：维护一段数列，支持在末尾插入一个数据，在首端删除一个数据，和查询在某一范围内的最大（小）值。这样，普通队列和优先队列都会黯然失色。因为普通队列仅能维护次序性而忽略了元素本身，而优先队列仅维护了元素大小关系却忽略了它们的入队次序。这时，我们就需要单调队列。 2 什么是单调队列正如上面的问题，单调队列就是这样的一个数据结构：维护一段数列，支持在末尾插入一个数据，在首端删除一个数据，和查询数列的最大（小）值。 显然我们还有一种强大的数据结构可以部分替代它——为所欲为的线段树。但有时候它会跑的很慢，因为它还有一个$O(\\log n)$的累赘，而单调队列是$O(n)$的。 二 实现1 实现思想那么单调队列怎么实现这些操作呢？ 可以这样设想：保证队首的元素最大，这样就可以$O(1)$的查询最大值。但是，在首端删除需要维护元素的次序性，因为最大元素不一定是数列的第一个元素。又要使得这个队列内的元素单调下降，因为只有这样，才能保证首端删除后的新首端依然是最大的。 插入元素的时候该怎样维护？不难发现，若当前队尾为$s_t$，新插入的元素为$s_k$，且队列中存在元素$s_i$满足$s_i &lt; s_k$且$s_{i-1} &gt; s_k$，那么$s_{i},s_{i+1},…,s_t$这一部分都是无用的，因为它们比新插入的元素小，对最大值已经没了贡献。删掉它们（这时从队尾出队），既能维护单调性，又可以维护次序性。 这样就实现了单调队列：在维护次序性的同时维护元素单调递减。 2 代码实现123456789101112131415161718192021222324const int C=1e6+6;class mqueue{ public: int d[C],key[C]; //元素的值与下标 int head,tail; //首尾指针 mqueue() {tail=-1;head=0;} void pop(int s) //出队，s为出队后队首的下标 { while(key[head]&lt;s &amp;&amp; head&lt;=tail) head++; } int front() {return d[head];} //返回队首 void push(int v,int k) //插入： v 值; k 下标 { while(head&lt;=tail &amp;&amp; d[tail]&gt;v) //出队直到满足单调性 tail--; d[++tail]=v; //插入 key[tail]=k; }};","link":"/2019/02/28/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"博弈论学习笔记","text":"Alice 和 Bob 又开始玩游戏了…… SG 函数对于博弈论中的局面 $S$，定义它的 SG 函数为 $SG(S)=\\text{mex} SG(T)$，其中 $T$ 是 $S$ 的后继局面。对于无法做出任何移动的局面（先手必败态），我们称之为 P 态，否则称之为 N 态（先手必胜态）。 SG 定理：一个局面 $S$ 是 P 态当且仅当 $SG(S)=0$ 这个定理也可以这样理解：可以到达 P 态的局面是 N 态，所有移动都导致 N 态的局面是 P 态。另一个非常有用的结论：对于由多个局面 $S_1, S_2,…S_n$ 组成的博弈游戏，该局面的 SG 函数是所有 $SG(S_i)$ 的异或和。 经典 Nim 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取，最后没石子可取的人就输了。问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 根据 SG 定理，容易发现 $SG(S_i)=a_i$，故先手必胜当且仅当 $a_i$ 的异或和不为0。 阶梯 Nim 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出任意多枚石子移动到前面一堆石子，可以取完，不能不取，最后无法移动的人就输了（此时所有石子都在位置0）。问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 若先手移动偶数堆的石子到奇数堆去，那么后手可以立刻将其移入下一个偶数堆，这样看起来对奇数堆毫无影响。但是如果先手移动奇数堆的石子去偶数堆，则可能会将其移入第 0 堆。因此，只有在奇数堆移动石子是本质的。 “从奇数堆移动一些石子去偶数堆”等价于从奇数堆拿走一些石子扔掉，因子对奇数堆做 Nim 即可。 一道栗题 有 $n$ 个箱子，每个箱子有 $a_i$ 个石头，一开始所有箱子都是关着的。Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。不能操作的输，求先手必胜还是后手必胜。$1\\le n\\le 10^5, 0\\le a_i\\le 10^9$ 考虑如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。 因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。 又一道栗题 有 $n$ 堆石子，每堆石子有 $a_i$ 个，每人每次可从任意一堆石子里取出一枚石子扔掉，但任意两次不能取同堆的石子。最后无法移动的人输，问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 若存在一堆石子，满足其中石子的个数比其它堆石子个数总和还多，则先手是必胜的，即一直取这一堆就好了。如果不存在呢？那么任意时刻，不能存在一堆石子，使得其中石子的个数多于其它堆石子个数总和。这意味着所有石子都要被取走，因此直接判断奇偶性即可，复杂度 $O(n)$。 双一道栗题 给你 $n$ 张卡片，每张卡片的两个面各有数字 $a_i$ 和 $b_i$，每个面都有 $1/2$ 的概率出现为卡片的正面，卡牌正反面的概率相互独立，求把所有卡牌正面数字拿来玩 Nim 游戏，先手必胜的概率。$n\\le 5\\times 10^5, a_i,b_i\\le 10^{18}$ 设 $S=\\bigoplus\\limits_{i=1}^na_i$，定义序列 $c_i=a_i\\oplus b_i$，则问题等价于求序列 $c$ 有多少个子集使得异或和为 $S$，线性基维护即可，复杂度 $O(n\\log a_i)$。 代码： 1234567891011121314151617181920212223242526class LB { public: LL a[101]; void ins(LL x){ for(int i = 63; i + 1; i--){ if(!(x &amp; (1ll &lt;&lt; i))) continue; if(a[i]) x ^= a[i]; else{ for(int j = i - 1; j + 1; j--) if(x &amp; (1ll &lt;&lt; j)) x ^= a[j]; for(int j = i + 1; j &lt;= 63; j++) if(a[j] &amp; (1ll &lt;&lt; i)) a[j] ^= x; a[i] = x; break; } } } int sz() {int cnt = 0; for(int i = 0; i &lt;= 63; i++) if(a[i]) cnt++; return cnt;} bool ext(LL x) {for(int i = 63; i + 1; i--) if(x &amp; (1ll &lt;&lt; i)) x ^= a[i]; return x == 0 ? 1 : 0;}} D;LL n, sum, a[CN], b[CN];n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), b[i] = read(), D.ins(a[i] ^ b[i]), sum ^= a[i];if(!D.ext(sum)) puts(&quot;1/1&quot;);else{ int k = D.sz(); LL ans = 1; while(k--) ans &lt;&lt;= 1; printf(&quot;%lld/%lld&quot;, ans - 1, ans);} 叒一道栗题 有 $n$ 堆石子（$n$ 是偶数），每堆石子有 $a_i$ 个，每人每次可从任意 $n/2$ 堆石子里取出至少一枚石子扔掉。最后无法移动（有石子的堆的数量 $\\le n/2$）的人输，问是否存在先手必胜的策略。$n\\le 10^7, a_i\\le 10^9$ 考虑若存在石子个数为 1 的堆，设堆数为 $x(x&gt;0)$，则有情况如下： $x &gt; n/2$，则先手必败，因为无法避免在操作中形成空堆； $x\\le n/2$，则先手必胜，因为先手只要令操作后 $x&gt;n/2$ 即可 剩下的唯一问题是不存在石子个数为 1 的堆的情况。可以考虑放宽限制，即考虑石子个数为 2 的堆的情况。容易发现石子个数为 2 的情况依然可以归结到上述的两种讨论，因此直接猜出结论：先手必胜当且仅当石子个数最小的堆的数量 $\\le n / 2$。 相关题目 「LG-P2197」NIM游戏 暂无来源 暂无来源 「CF1396B」Stoned Game 「CF662A」Gambling Nim 「CF1147C」Thanos Nim","link":"/2020/09/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"双连通分量","text":"两只$\\mathbf{Tarjan}$，两只$\\mathbf{Tarjan}$，跑得快，跑得快…… 此页面存在相关页面。关于强连通分量，请参见「强连通分量」。 一 概念1 基本定义无向图的双连通有两种情况：点-双连通 与 边-双连通。 点-双连通：若一个无向图中的去掉任意一个节点，都不会改变此图的连通性，即不存在割顶，则称作点-双连通图。 —— Baidu 边-双连通：若一个无向图中的去掉任意一条边，都不会改变此图的连通性，即不存在桥，则称作边-双连通图。 —— Baidu 类似与有向图的强连通分量，无向图的 点-双连通 的极大子图被称作该图的双连通分量（BiConnected Component,BCC）。而无向图的 边-双连通 的极大子图被称作该图的边-双连通分量（Edge-BiConnected Component,EBCC）。 上述还涉及到了两个概念，割顶与桥，定义如下： 对于一张无向图，若删去一个端点后，产生了新的连通块，则称这个端点为割顶（也称割点）。 对于一张无向图，若删去一条边后，产生了新的连通块，则称这条边为桥（也称割边）。 不难发现：割顶决定了点-双连通，而桥决定了边-双连通。 对于一张无向图，割顶（桥）可能不存在，也可能不仅一个。 2 图示 如上图，节点$4$是割顶，边$(4,6)$是桥。图中点-双连通子图有${1,2,4}$，${1,3,4,5}$等，但BCC只有${1,2,3,4,5}$和${6}$。类似的，边-双连通子图有${1,2,4}$等，但EBCC只有${1,2,3,4,5}$和${6}$。 二 割顶在求解BCC之前，先来学习割顶的必备知识。 注：因为 桥和边-双连通 与 点-双连通 有许多相似之处，故不重点说明。以下所有 “双连通/双连通子图/双连通分量/BCC” 等均指 “点-双连通”。 1 dfs树dfs树的基本内容在SCC算法分析中已经讲过，这里不再过多重复，只对部分概念做必要说明。 树边：dfs所经过的边 返祖边：连接子节点与它的祖先节点的边，本质上与树边无异 注意：无向图的dfs树上不存在横叉边。 可以绘制出上图的dfs树： 2 定理我们先来推导一下割顶的基本判定方法。 猜想： 在一个无向图中，若$u$是割顶，当且仅当$u$存在一个子节点$v$，使得子树$v$内没有边返回$u$的祖先。 画出图来就长这样： 看上去很对，但是有疏漏。 根节点很特殊。一定没有返祖边指向根的祖先，因为根没有祖先。但是仅当根由两棵及以上的子树时，根才是割点，否则删去它并不影响图的连通。所以需要特判根。 2-1 割顶的判定定理 根节点是割顶，当且仅当在dfs树上它有两个及以上的子节点。 非根节点$u$是割顶，当且仅当在dfs树上$u$存在一个子节点$v$，使得子树$v$内没有返祖边返回$u$的祖先。 简单证明： 此时删去根节点会让它的各个子树互不连通，因为不存在横叉边。 此时删去$u$，会使得子树$v$中的节点“独立”出来，形成新的连通块。 2-2 桥的判定定理与上面的类似。 对于任意节点$u$，若$u$存在一个子节点$v$，使得子树$v$内没有返祖边返回**$u$及$u$的祖先**，则边$(u,v)$是桥。 图示如下： 证明其实挺好想：删掉这条边会孤立子树$v$。 3 算法 该算法由Robert Tarjan提出（又是他）。 3-1 思路设节点$u$被dfs到的次序号是$dfn[u]$，从它能到达的祖先的最小次序号是$low[u]$，那么定理中的第二条就变成了： 找一个节点$u$，使得$low[v] \\geqslant dfn[u] | (u,v)\\in E$，则判定$u$是割顶。 同理，桥的判定定理可以表示为： 找一个节点$u$，使得$low[v] &gt; dfn[u] | (u,v)\\in E$，则判定无向边$(u,v)$是桥。 于是可以在dfs一张无向图的时候求解。 3-2 流程该算法主要有以下四步： dfs整个图。 对于每个非根节点，使用子节点的$low$值更新当前节点的$low$值。 访问该节点出发的所有返祖边，并用这条边指向的祖先的$dfn$值更新当前节点的$low$值。注意一定是$dfn$值，下面会讲。 判定是否是割顶（用到上面的不等式）。 对于1-2中的图，可以得到如下的一张dfs树（桥和割顶都已经标出）。发现存在$low[6]\\geqslant dfn[4]$，故判定$4$是割顶。 小问题：为什么一定是dfn值？看下面的图。 此时使用$low[u]$更新$low[v]$，实际上走了两条返祖边。则会判定$u$不是割顶，但实际上它是。 3-3 代码割顶的求解如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],cnt=0;void add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//cutint dfn[CP],low[CP];int idx=0;bool iscut[CP]; //是否是割顶void tarjan(int cur,int prv){ int child = 0; //孩子数，用于根的特判 dfn[cur] = low[cur] = ++idx; //设置初始值 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) //是树边 { child++; tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); //更新 if(low[to] &gt;= dfn[cur]) //用儿子来判定 iscut[cur]=true; } else if(to != prv) //是返祖边 low[cur] = min(low[cur], dfn[to]); //更新 } if(!prv &amp;&amp; child==1) //处理根 iscut[cur]=false; }void bcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 桥的求解如下： 因为边表没法有效地一次性保存双向边。所以边的下标从$1$开始，使得$k \\text{ xor } 1$就是$k$的反向边。（$k$与$k \\text{ xor } 1$共同组成一条无向边）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],cnt=1; //从1开始void add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//bridgeint dfn[CP],low[CP];int idx=0;bool isbri[CE]; //是否是桥void tarjan(int cur,int prv){ dfn[cur] = low[cur] = ++idx; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); if(low[to] &gt; dfn[cur]) //判定 isbri[k] = isbri[k^1] = true; } else if(to != prv) low[cur] = min(low[cur], dfn[to]); }}void ebcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 三 算法实现1 BCC学会了求解割顶，求出BCC就再容易不过了。 维护一个栈，栈内保存每一次走过的边（一定保存边，因为两个不同的双连通子图可能有交点，但一定没有交边）。每当发现割顶时，出栈，直到发现当前出栈的边恰好是连接割顶与判定它的子节点的边。则出栈的所有边同属一个双连通子图，这些边的端点也同属一个双连通子图。 代码如下：因为回溯到根的时候，剩余栈内元素一定是一个双连通子图，故先出栈再特判根。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int CP=1e3+3;const int CE=CP*CP;//边表class fs{ public: int from,to,nxt;}E[CE];int hd[CP],cnt=0;void add(int x,int y){ E[++cnt].from=x; E[cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}//bccint dfn[CP],low[CP];int idx=0;int bel[CP],bcnt=0; //每个点所属的bcc编号，为-1则表示该点是割顶（割顶同时属于两个bcc，所以它的bel无意义）int stack[CE],top=0;void tarjan(int cur,int prv){ int child = 0; dfn[cur] = low[cur] = ++idx; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]) { child++; stack[++top]=k; //入栈 tarjan(to,cur); //向下搜索 low[cur] = min(low[cur], low[to]); if(low[to] &gt;= dfn[cur]) //是割顶 { int pos; ++bcnt; while(true) { pos=stack[top--]; //出栈 bel[E[pos].from] = bel[E[pos].to] = bcnt; if(E[pos].from==cur &amp;&amp; E[pos].to==to) //发现当前的树边 break; } bel[cur] = -1; //标记割顶 } } else if(to != prv) low[cur] = min(low[cur], dfn[to]); } if(!prv &amp;&amp; child==1) //处理根 bel[cur] = bcnt;}void bcc() //主求解函数{ for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,0);} 2 EBCCEBCC可以用更简单的两遍dfs求出： 第一遍dfs在图上删去所有的桥。第二遍dfs求出这之后所有的连通块。那么每个连通块都是一个边-双连通子图。 四 BCC可以解决什么样的问题？噫，好了，我中了，我们已经学会了BCC。但是BCC可以用来求解什么样的问题呢？ 在这里梳理一下BCC的主要性质： 一个BCC一定是若干个简单环（环上的边数等于点数）的并。求出BCC的主要目的就是求出图上的若干环。 根据双连通（也是环的性质）可知：同一双连通子图中的点一定有至少两条路径可达。 两个不同的双连通子图的交点一定是该图的割顶，或这个点不存在。","link":"/2019/03/08/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"title":"后缀树","text":"众所周知：后缀树是不对劲的 Tire 树…. 后缀树即是路径压缩之后的后缀 Trie ，满足其中的 一些节点 可以双射原串的所有后缀。其分为 显示构造 与 隐式构造 两种，区别在于是否在字符串尾添加一个终止符。其中，显示构造的后缀树满足每个叶子双射原串的一个后缀。 众所周知，SAM 的 Parent 树是反串的后缀树，从而可以通过将字符串倒着插入 SAM 来得到一个串的后缀树。注意，这样得到的后缀树是隐式构造的。 后缀树为我们提供了一个新的思路：两个字符串的 LCP 是它们在 Trie 上的 LCA ，则两个后缀的 LCP 也是它们在后缀树上的 LCA。这可以被形式化地表达如下： $$ \\text{LCP}(s[i:n], s[j:n]) = \\text{len}[ \\text{LCA}(i, j) ] $$ 其中等号后面的 $i, j$ 应当对应为在树上的编号，$\\text{len}[]$ 即为 SAM 中的 len[] 数组。 给出一份查询两个后缀的 LCP 的代码。显然，该份代码也可以通过 SA 实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;const int CN = 1e5 + 5;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class SAM{ public: int len[CN &lt;&lt; 1], nxt[CN &lt;&lt; 1], son[CN &lt;&lt; 1][26], lst, idx; SAM() {nxt[0] = -1, idx = lst = 0;} int et(int c){ int u = ++idx, p = lst; len[u] = len[p] + 1, lst = u; while(p ^ -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return idx; int d = son[p][c]; if(len[d] == len[p] + 1) return nxt[u] = d, idx; int v = ++idx; nxt[v] = nxt[d], nxt[d] = nxt[u] = v, len[v] = len[p] + 1, memcpy(son[v], son[d], sizeof(son[d])); while(p ^ -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; return idx - 1; }} D;int n, id[CN]; char ch[CN];vector&lt;int&gt; to[CN];void rbd(){ for(int i = 1; i &lt;= D.idx; i++) to[ D.nxt[i] ].push_back(i);}int fa[CN][30], dep[CN];void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1; int sz = to[u].size(); for(int i = 0; i &lt; sz; i++){ int v = to[u][i]; if(v ^ p) dfs(v, u); }}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v) {for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0];} return u;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; ch; n = strlen(ch); for(int i = n - 1; i + 1; i--) id[i + 1] = D.et( ch[i] - 'a' ); rbd(), dfs(0, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= D.idx; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; int q = read(); while(q--){ int i = read(), j = read(), l = lca( id[i], id[j] ); printf(&quot;%d&quot;, D.len[l]), puts(&quot;&quot;); }}","link":"/2020/08/16/%E5%90%8E%E7%BC%80%E6%A0%91/"},{"title":"差分约束系统","text":"给定若干组形如$x_i - x_j \\leqslant k_a$（$k$为常数）的不等式，询问该不等式组的一组解。解是指一组$x$，使得$x_1,x_2,…x_n$均满足上述不等式组的限制…… 一 基本概念1 什么是差分约束系统给定若干组形如$x_i - x_j \\leqslant k_a$（$k$为常数）的不等式，询问该不等式组的一组解。解是指一组$x$，使得$x_1,x_2,…x_n$均满足上述不等式组的限制。 2 求解将不等式变形可得$x_i \\leqslant k_a+x_j$。这个限制类似于单源最短路径中总存在$d_i \\leqslant dist(j,i)+d_j | (j,i) \\in E$。于是我们从$j$向$i$建立一条权为$k_a$的有向边。再将每个节点与一个源点相连，将这些从源点出发的边的边权定义为一个固定的常数$c$，求出单源最短路，则$x_1=d_1,x_2=d_2,…,x_n=d_n$就是差分约束系统的一组解。当常数$c$改变时，得到的解也会相应地变化（若常数$c$加上$y$，则所有的$d$值均加上$y$，对满足不等关系无影响）。 对上面的不等式，建图得到下图，$s$为源点。 二 实现差分约束系统是可能无解的。在求解之前，首先要讨论解的存在性。 1 有解与无解（图上的环）在一个图上，环的有无及性质决定了差分约束系统解的有无。 环可以分为以下三种： 正权环：一个正权环在最短路中至多被经过一次。因为当绕这个环第二圈时，只会让走过的路径增大，并且这种增大总是无意义的。 零权环：相似于正权环，零权环至多被经过一次。因为它并不能使最短路改变。 负权环：对于一个包含负权环的图，不存在最短路。因为只要在负环中无限转圈，就可以让路径无限变短。 因此任意一个节点最多被$n-1$个节点松弛。则存在负权环时，一个环上的节点会被松弛无限次，则当任意一个点的松弛次数达到$n$时，不存在最短路，同样不存在差分约束系统的解。 我们只需要记录节点被松弛的次数，即可求出是否有解。 2 SPFA求解差分约束1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int CP=1e3+3;const int CE=CP*404;const int INF=0x3f3f3f2f;//边表class fs{ public: int to,nxt,dist;}E[CE];int hd[CP],ecnt=0;void add(int x,int y,int z){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; E[ecnt].dist=z; hd[x]=ecnt;}//spfabool ins[CP]; //是否在队列中int times[CP]; //times[i] : 节点i被松弛的次数int d[CP]; //保存单源最短路bool spfa(int s) //返回有解（true）或无解（false）{ memset(d,0x3f,sizeof(d)); memset(ins,false,sizeof(ins)); memset(times,0,sizeof(times)); queue&lt;int&gt;Q; Q.push(s); d[s]=0; while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u]=false; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[u]+e.dist &lt; d[e.to]) //松弛 { d[e.to]=d[u]+e.dist; if(!ins[e.to]) //不在队列中就入队 { Q.push(e.to); ins[e.to]=true; if(++times[e.to] == n) //松弛了超过n次，存在负环 return false; } } } } return true;} 3 dfs判断解的存在性相对于上文算法，这里的dfs算法具有一定激进性。它的复杂度是极不稳定的，在某些保证有解并需要求解的题目中，它比上文算法更好卡掉。这种方法的主要思路就是记录有哪些元素在当前路径（也就是dfs栈）中。若当松弛操作时，发现正在使用在栈内的元素松弛当前节点（也就是dfs路径绕了一个圈），此时可以直接判定存在负环，不需要松弛$n$次才可以判定。 这种思想有点暴力的意味，因此复杂度不稳定，在某些数据中可能跑的比某某记者还快。给出核心代码： 123456789101112131415161718192021const int INF=0x3f3f3f3f;bool ins[CP]; //判断是否在当前路径中int d[CP]; //最短路数组，需要初始化为INFbool spfa(int u){ ins[u]=true; for(int k=hd[u]; k; k=E[k].nxt) { fs e=E[k]; if(d[e.to] &gt; d[u]+e.dist) { d[e.to]=d[u]+e.dist; if(ins[e.to] || !spfa(e.to)) //又绕回到栈内元素，即出现负环 return false; } } ins[u]=false; return true; //全部检查完毕}","link":"/2019/02/25/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"},{"title":"强连通分量","text":"Tarjan陪伴强连通分量，生成树完成后思路才闪光。Euler跑过的七桥古塘，让你，心驰神往…… 此页面存在相关页面。关于双连通分量，请参见「双连通分量」。 一 定义1 强连通在有向图 $ G $ 中，选出 $ n $ 个点，使得这些点两两可达，则称这些点强连通。 有向图 $ G $ 上强连通的的顶点，被称为 $ G $ 的强连通子图。显然，一个有向环上的点一定是强连通的（或说强连通子图中一定存在一个环）。 若 $ G $ 整体强连通，则称 $ G $ 为一个强连通图。 2 强连通分量在非强连通图 $ G’ $ 中，极大强连通子图称为 $ G’ $ 的强连通分量（Strongly Connected Components，SCC）。注意极大的概念，它强调相对于自身无法继续扩大。 如下图，SCC有 $ \\begin{Bmatrix}1,2,3,4\\end{Bmatrix} $ ， $ \\begin{Bmatrix}5\\end{Bmatrix} $ 和 $ \\begin{Bmatrix}6\\end{Bmatrix} $ 。其中强连通子图还有 $ \\begin{Bmatrix}1,3,4\\end{Bmatrix} $ ，但是它不“极大”（因为它还可以扩大为 $ \\begin{Bmatrix}1,2,3,4\\end{Bmatrix} $ ），所以不是SCC。 二 Tarjan算法 Robert Tarjan（1984~），美帝人，计算机科学家，以LCA、强连通分量等算法闻名。 1 dfs树学习tarjan的玄学算法，我们首先要了解dfs树，即把一张有向连通图转化为一棵搜索树。 树上的一些定义： $ \\text{dfn} $ （dfs number）：结点第一次被访问的时间（起点为 $ 1 $ ，每次搜索 $ +1 $ ） $ \\text{low} $ ：结点所能到达的最小 $ \\text{dfn} $ 值 树边：dfs树上应有的边，又父节点指向子节点 返祖边：dfs树上不应有的边，且该边由子辈节点指向父辈节点（注意这里不一定是父子节点） 横叉边：dfs树上不应有的边，且该边连接的两个点无父子辈关系（注意横叉边一定由 $ \\text{dfn} $ 值大的节点指向 $ \\text{dfn} $ 值小的节点，否则它是树边） 上图的dfs树，以 $ 1 $ 为起点。图中 $ 5 $ 节点的 $ \\text{low} $ 值为 $ 5 $ 而不是 $ 4 $ ，是因为横插边 $ (5,6) $ 会被忽略，下面会讲。 2 处理思路SCC中一定存在若干个环，那么我们可以通过找环来判断是否找到了SCC。 2-1 怎么判断环的有无当存在一个节点 $ u $ ，使得 $ \\text{dfn}[u] = \\text{low}[u] $ 时，那么就发现了一个环。从定义看，这代表从当前节点出发能到达的最早的祖先是当前节点，也就是说递归“绕回来了”，那么就一定存在环。这个环也包括自环，这需要默认每个节点初始状态下都存在自环，即初始化 $ \\text{low}[u] = \\text{dfn}[u] $ 。 那么剩下的问题就是怎么计算 $ \\text{low}[u] $ 。假设存在边 $ (u,v) $ ，那么这条边有以下三种可能。 边 $ (u,v) $ 为树边。那么向下dfs节点 $ v $ ， $ \\text{low}[u] $ 可由 $ \\text{low}[v] $ 推得，即 $ \\text{low}[u] = \\text{low}[v] $ 。 边 $ (u,v) $ 为返祖边。根据 $ \\text{low} $ 的定义，直接更新 $ \\text{low}[u] $ ，即 $ \\text{low}[u] = \\text{dfn}[v] $ 。此处也可以直接令 $ \\text{low}[u] = \\text{low}[v] $ ，因为 $ v $ 能到达的的祖先也可以被 $ u $ 到达，通过多条返祖边即可。 边 $ (u,v) $ 为横叉边。此时分情况处理，详见二.2-3。 2-2 怎么维护SCC判环只能发现SCC，我们还需要维护SCC中的节点。 考虑用一个栈（stack）来实现。每次深搜时，把节点的编号入栈。回溯时，仅当某节点处出现环，且子树都检索完毕（也就是说子树中所有不在环上的点都已经 入/出栈 完成），此时出栈至该节点为止。那么此时该节点以上的所有栈内元素均可以互达，均在一个环上，均属同一个SCC。 2-3 怎么处理横叉边假设当前节点为 $ u $ ，有一条到 $ v $ 的横叉边 $ (u,v) $ 。如果从 $ v $ 处出发，能直接或间接地到达 $ u,v $ 的公共祖先（不一定最近），那么这条横叉边应该被重视，因为这样就会出现环。反之，这条横叉边就应该被忽略。 假设存在一条返祖边 $ (v,a) $ ， $ a $ 为 $ v $ 能回到的最远祖先。那么当 $ u $ 在以 $ a $ 为根的子树中时，横叉边被重视，反之被忽略。 再看上述维护方法：当 $ u $ 不在以 $ a $ 为根的子树中，当检索到 $ u $ 时，因为横叉边一定从后访问的节点指向先访问的节点，那么 $ v $ 一定被检索过。 $ a $ 是 $ v $ 的祖先，那么子树 $ a $ 一定已经检索完成。因为存在返祖边 $ (v,a) $ ，所以此时存在从 $ a $ 出发的环，那么子树 $ a $ 必然已经出栈，此时 $ v $ 不在栈内。 同理可知，若 $ u $ 在以 $ a $ 为根的子树中，则此时 $ v $ 一定在栈内。于是我们可以知道，当且仅当 $ v $ 在栈内时，横叉边 $ (u,v) $ 应被重视，需要更新 $ \\text{low}[u] = \\text{low}[v] $ ，回答了上文二.2-1中留下的问题。 3 流程手推对于上图的 tarjan 算法。代码见二.4。 Step 1扫描到节点 $ 1 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 n/a n/a n/a n/a n/a low 1 n/a n/a n/a n/a n/a stack 1 Step 2访问边 $ (1,2) $ ，扫描到节点 $ 2 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a n/a n/a n/a low 1 2 n/a n/a n/a n/a stack 1 2 Step 3访问边 $ (2,4) $ ，扫描到节点 $ 4 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a n/a low 1 2 n/a 3 n/a n/a stack 1 2 4 Step 4访问边 $ (4,6) $ ，扫描到节点 $ 6 $ ，节点入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 2 n/a 3 n/a 4 stack 1 2 4 6 Step 5节点 $ 6 $ 无出度，且存在自环（ $ dfn[6]=low[6] $ ），出栈至节点 $ 6 $ ，回溯至节点 $ 4 $ 。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 2 n/a 3 n/a 4 stack 1 2 4 发现强连通分量 $ {6} $ Step 6发现返祖边 $ (4,1) $ ，更新 $ 4 $ 的 $ \\text{low} $ 值，不出栈并回溯至节点 $ 2 $ 。 $ 2 $ 的 $ \\text{low} $ 值更新。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 n/a 4 low 1 1 n/a 1 n/a 4 stack 1 2 4 Step 7发现边 $ (2,5) $ ，扫描至节点 $ 5 $ ，入栈。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 5 4 low 1 1 n/a 1 5 4 stack 1 2 4 5 Step 8发现横叉边 $ (5,6) $ ，此时 $ 6 $ 不在栈内，忽略该横叉边。出栈至节点 $ 5 $ ，回溯至节点 $ 2 $ 。 cde 1 2 3 4 5 6 dfn 1 2 n/a 3 5 4 low 1 1 n/a 1 5 4 stack 1 2 4 发现强连通分量 $ {5} $ Step 9回溯至节点 $ 1 $ ，扫描边 $ (1,3) $ ，节点 $ 3 $ 入栈。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 6 1 5 4 stack 1 2 4 3 Step 10发现横叉边 $ (3,4) $ ，此时 $ 4 $ 在栈内，用 $ 4 $ 的 $ \\text{low} $ 值更新 $ 3 $ 的 $ \\text{low} $ 值。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 1 1 5 4 stack 1 2 4 3 Final回溯至节点 $ 1 $ ，出栈至栈空，算法结束。 cde 1 2 3 4 5 6 dfn 1 2 6 3 5 4 low 1 1 1 1 5 4 stack 发现强连通分量 $ {1,2,3,4} $ 4 代码实现1234567891011121314151617181920212223242526272829303132const int CP=1e3+3;int dfn[CP],low[CP],idx=0,stk[CP],top=0;bool ins[CP]; // 是否在栈中int ans=0;void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; //设置初始值 stk[++top] = cur; ins[cur] = true; //节点入栈 for(int k=hd[cur]; k; k=E[k].nxt){ //遍历边表 int to=E[k].to; //边的终点 if(!dfn[to]){ //未被访问，说明这是树边 tarjan(to); //深搜 low[cur] = min(low[cur], low[to]); } else if(ins[to]) //已经访问且在栈内，说明这是返祖边或需要重视的横叉边 low[cur] = min(low[cur], low[to]); //此处写成low[cur] = min(low[cur], dfn[to])也没有问题 } if(dfn[cur] == low[cur]){ //发现环 ans++; //计数 while(true){ int pos=stk[top--]; ins[pos] = false; //标记去除 if(pos == cur) break; //出栈至当前节点 } }}void scc(){ //主求解函数 for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);} 三 缩点1 模型给定一张有向图 $ G_0 $ ，不保证无环，图上的节点有点权（正权，注意无法处理负环），要求找一条从起点到终点的路径，使得经过节点的点权和存在最大值。对于每条边，可以走多次。对于每个节点，点权仅计算一次。 怎么解决呢？ 先考虑无环时的情况，那么只需要一遍DP（记忆化搜索）就可以解决问题。再考虑环。对于任意一个环，如果走这个环，那么一定要全走才能获得最大价值，也就是一条环的价值可以被看作一个点的价值。一条环一定是强连通的，那么我们只需要求出 $ G_0 $ 的所有的强连通子图，分别统计它们的点权（累加环上点权和），并重新建图连边。于是我们会得到一个有向无环图（Directed Acyclic Graph，DAG）。借用无环时的解决方案即可解决问题。 2 代码实现边表 123456789101112131415class fs{ public: int to,nxt;}E[CON];int hd[CON],cnt=0;void E_add(int x,int y){ E[++cnt].to=y; E[cnt].nxt=hd[x]; hd[x]=cnt;}void E_init(){ memset(hd,0,sizeof(hd)); memset(E,0,sizeof(E)); cnt=0;} 算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int dfn[CON],low[CON],idx=0,stk[CON],top=0,belong[CON];bool ins[CON];void tarjan(int cur){ dfn[cur] = low[cur] = ++idx; stk[++top] = cur; ins[cur] = true; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; if(!dfn[to]){ tarjan(to); low[cur] = min(low[cur], low[to]); } else if(ins[to]) low[cur] = min(low[cur], low[to]); } if(dfn[cur] == low[cur]){ //出现环，则定义cur为当前环的根（因为它先被扫描到） int sum=0; while(true){ int pos = stk[top--]; ins[pos] = false; sum += c[pos]; c[pos] = 0; //这样不是根的节点c值一定为0 belong[pos] = cur; //染色，即记录环的根 if(pos==cur) break; } c[cur] = sum; //将环上点的权值累加入根的权值 }}void scc(){ //主求解函数 for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);}//dpint f[CON]; //f[i]为从i出发的最优解 int dp(int cur){ //记忆化搜索 if(f[cur]) return f[cur]; f[cur] = c[cur]; //初始化 for(int k=hd[cur]; k; k=E[k].nxt) f[cur] = max(f[cur], dp(E[k].to)+c[cur]); //转移方程 return f[cur];//返回解}int solve(){ E_init(); //边表初始化 for(int i=1;i&lt;=m;i++) if(belong[x[i]] != belong[y[i]]) //不在一个环上，避免连出自环边 E_add(belong[x[i]], belong[y[i]]); //将两个强连通子图的根连边。原图中x[i]-&gt;y[i]存在边 int ans=0; for(int i=1;i&lt;=n;i++) //枚举起点 if(c[i]) ans=max(ans, dp(i)); //是根，更新答案 return ans;} 3 推论设一有向联通图缩点后得到图 $ G’ $ ，且在 $ G’ $ 中，入度为 $ 0 $ 的点（DAG的起点）有 $ x $ 个，出度为 $ 0 $ 的点（DAG的终点）有 $ y $ 个，有推论： 图 $ G’ $ 必为一个DAG。 选出最少的点，使得从这些点出发，可以到达整个图。则这个最小值一定为 $ x $ 。（必要性：不从起点出发那么起点永远无法到达。 最优性：考虑任意一个非起点的点，从它出发一定比从它的起点出发覆盖的节点少。） 选出最少的点，使得从任意点出发，可以到达这些点。则这个最小值一定为 $ y $ 。（必要性：终点本身无法到达任何点，那么不选中终点显然是不合法的。 最优性：终点既然必定选中，且选中所有终点一定合法，那么不需要再选中其它点。） 添加最少的边，使得 $ G’ $ 成为一个强连通图，则这个最小值一定为 $ \\max x,y $ 。（考虑终点向起点对应连边。） $$ - - - - \\mathcal{End} - - - - $$","link":"/2019/02/07/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"title":"悬线法","text":"有边界限制的最大子矩阵问题一般可以通过悬线法（玄线法）解决，即通过处理出每个节点可以向四周扩张的长度，来计算包含该节点的最大矩阵面积…… 一 模型1 最大子矩阵问题最大子矩阵问题，通常是指在一个$n\\times m$的矩阵中，除去若干不能被包含的点（障点），找出一个面积最大的子矩阵。 2 悬线从矩阵中的一个格点出发，到某一障点引一条竖直的线段被称作悬线。广义的悬线可以被理解为从格点到障点竖直或水平的线段。 3 定义与递推对于每个格点$(i,j)$，定义三种变量如下： $l_{i,j}$：格点$(i,j)$的向左端的悬线长度。 $r_{i,j}$：格点$(i,j)$的向右端的悬线长度。 $up_{i,j}$：格点$(i,j)$的向上的悬线长度。 这些数据可以通过递推处理出来。当$(i,j)$不是障点时（障点的悬线长度均为$0$），有以下递推式：$$ l_{i,j} = l_{i,j-1}+1 \\newline r_{i,j} = l_{i,j+1}+1 \\newline up_{i,j} = up_{i-1,j}+1 $$ 4 数据的处理通过这些数据，我们就可以得出经过格点$(i,j)$的最长宽度（$l_{i,j}+r_{i,j}-1$）和最大高度（$up_{i,j}$）。但是仅凭这些数据还不能得出正确答案。 看下面的图： 不难发现，当前包含该节点的最大子矩阵（实线框出）面积，与橙色线段和绿色线段中长度最小的那两个有关。也就是说当前得到的面积应该表示为：$$ S_{max} = up_{i,j}(\\min\\limits_{i-up_{i,j}&lt; k\\leqslant i} l_{k,j} + \\min\\limits_{i-up_{i,j}&lt; k\\leqslant i} r_{k,j} -1)$$ 其中这两个$\\min$值也是可以直接递推出来的。即当上方格点不是障点时，令$l_{i,j} = \\min l_{i,j},l_{i-1,j}$，那么实际上满足了$l_{i,j} =\\min\\limits_{i-up_{i,j}&lt; k \\leqslant i} l_{k,j} $。$r_{i,j}$同理。 那么当递推完成时，该面积为：$$ S_{max} = up_{i,j}(l_{i,j} + r_{i,j} -1)$$预处理之后，枚举每个格点，用上面的式子算面积，取最大值就好了。 二 代码总共需要有三遍递推，每遍复杂度均为$O(nm)$，总复杂度$O(nm)$。模板题目。 1234567891011121314151617181920212223242526const int CN=1e3+3;bool G[CN][CN];int n,m;int up[CN][CN],l[CN][CN],r[CN][CN];for(int i=1;i&lt;=n;i++){ //第一遍递推处理初值 for(int j=1;j&lt;=m;j++) if(G[i][j]) l[i][j] = l[i][j-1]+1; for(int j=1;j&lt;=m;j++) if(G[i][j]) up[i][j] = up[i-1][j]+1; for(int j=m;j;j--) if(G[i][j]) r[i][j] = r[i][j+1]+1; }for(int i=2;i&lt;=n;i++) //第二遍递推求出min值 for(int j=1;j&lt;=m;j++) if(G[i][j] &amp;&amp; G[i-1][j]){ l[i][j] = min(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); } int ans=0;for(int i=1;i&lt;=n;i++) //第三遍遍历求出答案 for(int j=1;j&lt;=n;j++) ans = max(ans, (l[i][j]+r[i][j]-1)*up[i][j]); 三 变形 「ZJOI2007」棋盘制作 国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。小Q找到了一张由N×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小Q找到了即将参加全国信息学竞赛的你，请编程输出可以找到的最大正方形棋盘和最大矩形棋盘的面积。 这题中没有“障点”，那么悬线应该定义为“从某一格点开始沿竖直或水平方向所能走出的最长的黑白相间的道路”。依然按照上面的方法处理即可，细节参见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN=2e3+3;int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}bool G[CN][CN];int n,m;int up[CN][CN],l[CN][CN],r[CN][CN];int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ int c=read(); G[i][j] = c ? true : false; l[i][j] = r[i][j] = up[i][j] = 1; } //preparation for(int i=1;i&lt;=n;i++){ for(int j=2;j&lt;=m;j++) if(G[i][j] != G[i][j-1]) //不同时转移 l[i][j] = l[i][j-1]+1; for(int j=m-1;j;j--) if(G[i][j] != G[i][j+1]) r[i][j] = r[i][j+1]+1; } for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(G[i][j] != G[i-1][j]) up[i][j] = up[i-1][j]+1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(G[i][j] != G[i-1][j]){ //求出min值 l[i][j] = min(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); } //solve int ans = 0; for(int i=1;i&lt;=n;i++) //正方形 for(int j=1;j&lt;=m;j++){ int a = min(up[i][j], (l[i][j]+r[i][j]-1)); //从两个边长里面取一个小的 ans = max(ans, a*a); } printf(&quot;%d\\n&quot;,ans); ans = 0; for(int i=1;i&lt;=n;i++) //矩形 for(int j=1;j&lt;=m;j++) ans = max(ans, (l[i][j]+r[i][j]-1)*up[i][j]); printf(&quot;%d&quot;,ans); return 0;}","link":"/2019/05/19/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"title":"拓扑排序","text":"对一个DAG$G=(V,E)$（$V$为点集，$E$为边集）进行拓扑排序，是将$G$中所有顶点排成一个线性序列，使得图中任意一边$(u,v)∈E$，$u$在线性序列中出现在$v$之前…… 一 概念 对一个DAG $G=(V,E)$（$V$为点集，$E$为边集）进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一边$(u,v)∈E$，$u$在线性序列中出现在$v$之前。通常，这样的线性序列称为满足拓扑次(Topological Order)的序列，简称拓扑序列。 简单来说，就是找一种排序方案，使得每条边的起点总排在终点之前。注意：一个DAG的拓扑序列不一定是唯一的。 如图，合法的拓扑序列有$4,3,6,1,2,5$或$4,3,6,5,1,2$。 二 实现1 怎么求拓扑序要使得起点排在终点之前，那么我们首先要找到起点，即入度为$0$的节点。然后我们删去这些点，即在图中删除以它们为起点的边。因为DAG的特性，那么这样操作以后，新得到的图也一定是一个DAG。于是我们可以继续找起点，删边，那么我们得到起点的顺序就是一个拓扑序。 因为DAG的性质，所以一个点不会被重复访问。 2 算法求出一有向图的一个拓扑序。 边表 12345678910111213const int CP=1e3+3;const int CE=CP*CP;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;} 排序算法 123456789101112131415161718192021222324252627282930313233343536const int CP=1e3+3;const int CE=CP*CP;int in[CP]; //记录节点入度int ans[CP]; //得到的拓扑序queue&lt;int&gt;Q; //存放入度为0的节点void tsort(){ int pos=0; for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; //统计入度 for(int i=1;i&lt;=n;i++) if(!in[i]) Q.push(i); //将起点入队 while(!Q.empty()) { int cur=Q.front(); Q.pop(); ans[++pos]=cur; //记录答案 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; //拆边，并减少终点的入度 if(!in[to]) //得到的是一个新起点，就把它入队 Q.push(to); } }} 三 建图拓扑排序的题目中，难点一般在建图，因为建图之后求拓扑序是一件极其容易的事情。讨论建图之前，我们先讨论一些基础的东西。 1 字典序字符在某一标准（一般是ASCII）中出现的先后顺序叫做字典序。类似于数字比大小，某一字符串$A$相对于字符串$B$，$A$的高位上的字符在标准中比$B$出现得早，则称$A$的字典序（相对于$B$）小。反之，则称$A$的字典序（相对于$B$）大。 若以ASCII为标准，则串$abc$比串$acb$字典序小。 设定拓扑序列中第一个元素为最高位，最后一个元素为最低位。那么字典序小的拓扑序则是高位元素的编号尽量小，字典序大的拓扑序则是高位元素的编号尽量大。 对于第一章节中的图，拓扑序列$4,3,6,1,2,5$的字典序小，拓扑序列$4,3,6,5,1,2$的字典序大。 2 怎么求一个字典序大或小的拓扑序列前文中给出的算法是以入队顺序确定拓扑序列。那么怎么求一个指定字典序大小的拓扑序列呢？只需要把上文算法中的普通队列改成优先队列即可。因为在队列中的元素总是起点，在拓扑序列中的相对位置可以调换。 具体实现（重载运算符） 123456789101112131415161718192021222324const int CP=1e3+3;const int CE=CP*CP;class node{ public: int cde; void init(int c){cde=c;} //大字典序 bool operator &lt; (const node a)const { return cde&lt;a.cde; } /* 小字典序 bool operator &lt; (const node a)const { return cde&gt;a.cde; } */};priority_queue&lt;node&gt;Q; 然后照常跑拓扑排序即可。 1234567891011121314151617181920212223242526272829303132333435363738int in[CP];void tsort(){ int pos=0; for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; for(int i=1;i&lt;=n;i++) if(!in[i]) { node temp; temp.init(i); Q.push(temp); } while(!Q.empty()) { node cur=Q.top(); Q.pop(); ans[++pos]=cur.cde; for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; if(!in[to]) { node temp; temp.init(to); Q.push(temp); } } }} 3 例题1-建图求拓扑序 「Luogu P1983」车站分级 一条单向的铁路线上，依次有编号为$ 1, 2, …, n $的$ n $个火车站。每个火车站都有一个级别，最低为 $1$ 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 $x$，则始发站、终点站之间所有级别大于等于火车站 $x$ 的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）现有 $m$ 趟车次的运行情况（全部满足要求），试推算这 $n$ 个火车站至少分为几个不同的级别。 对于任意一趟列车，经过的站点总比没有经过的级别高，我们把级别高的站点向级别低的站点依次连边。 这样处理完$m$趟列车后，我们就会得到一个DAG。接下来我们只需要对这个DAG进行拓扑排序。但还有一个问题，怎么求出最小级别数？很明显，若定义排序起点的深度为$1$，那么这个最小级别数就是图中节点的最大深度。我们只需要在广搜的时候递推记录一下节点深度就可以了。 递推式：$$\\begin{aligned}f_i&amp;=1 | i \\in S \\newline f_i&amp;=\\max f_i,f_j+1 | (j,i)\\in E \\end{aligned}$$ $S$为起点集，$E$为边集。 具体实现（仅核心算法）： 123456789101112131415161718192021222324252627const int CP=1e3+3;int f[CP];for(int i=1;i&lt;=n;i++) if(!in[i]) { f[i]=1; Q.push(i); }while(!Q.empty()){ int cur=Q.front(); Q.pop(); for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; f[to]=max(f[to], f[cur]+1); //here in[to]--; if(!in[to]) Q.push(to); }} 4 反图4-1 什么是反图？对一个有向图$G={V,E}$，若存在一个图$G_r={V,E_r}$，其中两个图的点集相同，边集相反（定义为每一条边的方向均相反），那么称$G_r$为$G$的反图。 建立反图其实是一件非常简单的事情，只需要在节点连边的时候连反向边即可。 4-2为什么要建反图? 求一个拓扑序列，使得最小的编号尽早出现。 先考虑能否用字典序解决：字典序小使得居高位的数字尽可能小；字典序大使得居高位的数字尽可能大。 于是我们发现，最小的字典序并不能保证最小数字尽可能靠前。 继续分析：最小数字尽可能靠前，那么其它数字（都比它大）要尽可能靠后。看不出什么来，那我们反过来看：最小数字尽可能靠后，那么其它数字要尽可能前。这恰好是原图中的最大字典序（无论高位怎样排布，最大字典序会使低位尽可能小，也就是最小数字尽可能靠后）。 于是我们求一个最大字典序的拓扑序列，反过来读，就是答案吗？不是。就像sort一样，一段排好序的数列，反过来读（相对于排序条件）一定是无序的。 那么怎么解决这个问题？考虑反向建图。在原图的反图中跑最大字典序的拓扑序列。这个序列看起来是不合法的，但是反过来看就exciting了。我们不难发现，反图中的每个拓扑序列，都是正图中的一个合法拓扑序列反转而形成的。继续考虑，求出反图中最大字典序的拓扑序列$K$，会使得最小数字在$K$中出现的尽量晚。然后我们把$K$反转形成$K_r$，那么最小数字在$K_r$中就会出现的尽可能早。然后$K_r$依然是正图的合法拓扑序列，完美解决。 4-3 算法实现代码依然是上面的代码改了改。 边表 12345678910111213const int CP=1e3+3;const int CE=CP*CP;class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=0;void add(int x,int y){ E[++ecnt].to=x; //反向加边 E[ecnt].nxt=hd[y]; hd[y]=ecnt;} 排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int CP=1e3+3;const int CE=CP*CP;class node{ public: int cde; void init(int c){cde=c;} bool operator &lt; (const node a)const { return cde&lt;a.cde; //大字典序 }};int in[CP];int ans[CP];prioirty_queue&lt;node&gt;Q;void tsort(){ int pos=n; //倒着记录答案，正好是正图中的拓扑序列 for(int i=1;i&lt;=n;i++) for(int k=hd[i]; k; k=E[k].nxt) in[E[k].to]++; for(int i=1;i&lt;=n;i++) if(!in[i]) { node temp; temp.init(i); Q.push(temp); } while(!Q.empty()) { node cur=Q.top(); Q.pop(); ans[pos--]=cur.cde; //记录 for(int k=hd[cur]; k; k=E[k].nxt) { int to=E[k].to; in[to]--; if(!in[to]) { node temp; temp.init(to); Q.push(temp); } } }} 5 例题2-建立反图解决拓扑问题 「HNOI2015」菜肴制作 知名美食家小A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小A准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为&lt;i,j&gt;。现在，给出若干组形如&lt;i,j&gt;的限制，酒店希望能求出一个最优的菜肴的制作顺序，使得小A能尽量先吃到质量高的菜肴 最小编号最靠前，明显是一个反图拓扑序问题。对于每组限制&lt;i,j&gt;，从j向i连边，然后求最大字典序，反着输出即可。","link":"/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"整数划分问题","text":"众所周知，整数划分问题是一类计算将正整数 $n$ 无序拆分成若干可相同的正整数之和的划分数的问题，存在一类普适性的 DP 解法以及针对划分数问题的五边形数定理…… 先来看一道小学奥数题。 给出 $n$ 个小球和 $m$ 个盒子，分别计算在以下情况中，将小球放入盒子（盒子不能是空）的方案数： 小球和盒子都有标号 小球有标号，盒子无标号 小球无标号，盒子有标号 小球和盒子都没有标号 显然，问题 1 可以通过简单容斥来求，即我们钦点有 $k$ 个盒子是空的，得到答案是 $\\sum\\limits_{k=0}^m (-1)^k \\dbinom{m}{k} (m-k)^n$。注意到这本质上是第二类斯特林数乘上盒子数的阶乘（见通项公式），即 $m!\\begin{Bmatrix}n\\newline m \\end{Bmatrix}$。 对于问题 2 ，这显然是第二类斯特林数 $\\begin{Bmatrix}n\\newline m \\end{Bmatrix}$ 的定义（组合意义？）。 对于问题 3，因为小球不可区分，所以我们考虑插板。因为盒子不空，所以答案是 $\\dbinom{n-1}{m-1}$。 至此前三个问题都在 $O(nm)$ 的时间内解决掉了，但是第四个问题呢？显然我们不能直接对 3 除一个 $m!$ 了事，一个最明显的反例就是得到的结果甚至不一定是整数！ 我们考虑 DP。 整数划分 DP问题 4 可以被如下转化： 给定正整数 $n$ ，求将 $n$ 分解为 $m$ 个正整数之和的方案数。两种方案不同当且仅当 $m$ 个正整数构成的集合不相同。$n, m\\le 5000$ 设 $f[i,k]$ 为考虑将 $i$ 划成 $k$ 个正整数的方案数。对于当前的状态，我们可以将其划成两种情况： 当前划分包含数字 1，方案是 $f[i-1,k-1]$ 当前划分不含数字 1，考虑对划分出的每个数字减 1，方案数不变，得到方案数是 $f[i-k,k]$ 因此转移：$$ f[i,k]=f[i-1,k-1]+f[i - k, k] $$ 时间复杂度 $O(nm)$。 代码： 1234memset(f, 0, sizeof(f)), f[0][0] = 1;for(int j = 1; j &lt;= n; j++) for(int i = j; i &lt;= n; i++) f[i][j] = f[i - 1][j - 1] + f[i - j][j]; 一个变形考虑这样一个问题： 给定正整数 $n$ ，求将 $n$ 分解为若干个正整数之和的方案数。两种方案不同当且仅当划分出的正整数构成的集合不相同。$Subtask1, n \\le 5000$$Subtask2,n\\le 10^5$ Subtask1 考虑 DP，注意到这本质上就是一个完全背包计数：有 $n$ 个物品 $1,2,…,n$，选出一些让和为 $n$，物品可以取多次。然后就可以 $O(n^2)$ 快乐DP了，代码略。 Subtask2 注意到我们有两种求划分数的 DP：第一类状态设计为 $f[i,k]$ 考虑将 $i$ 划成 $k$ 个正整数的方案数，复杂度是 $O(nk)$，即划分个数乘上划分值域；第二类是完全背包计数，复杂度是 $O(nV)$，即元素个数乘上划分值域。 考虑复杂度均摊，设阈值 $B$，我们把能用的数字划分为 $[1,B]$ 和 $[B+1,n]$ 两部分。第一部分一共有 $B$ 个能用的数字，跑完全背包计数，复杂度 $O(nB)$；第二部分不会选择超过 $\\frac{n}{B}$ 个，跑第一种 DP，复杂度 $O(\\frac{n^2}{B})$。最后可以模拟卷积合并 DP 结果，取 $B = \\lceil\\sqrt{n}\\rceil$，总复杂度 $O(n\\sqrt{n})$。 代码： 12345678910111213141516171819int x, y, n, P, f[CN], g[CN][400];int add(int a, int b) {return a + b &gt;= P ? a + b - P : a + b;}int work(){ int B = ceil(sqrt(n)); memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g)); f[0] = 1; for(int i = m; i &lt;= B; i++) for(int j = i; j &lt;= n; j++) f[j] = add(f[j], f[j - i]); g[0][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= min(B, i); j++) g[i][j] = add(g[i - 1][j - 1], g[i - j][j]); int ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= min(B, i); j++) if(i + j * B &lt;= n) // 每个数都 +B g[i + j * B][0] = add(g[i + j * B][0], g[i][j]); for(int i = 0; i &lt;= n; i++) // 合并状态 ans = add(ans, 1ll * f[i] * g[n - i][0] % P); return ans;} 实际上这个问题是一类经典问题，被称作整数拆分问题，另一种解法是五边形数定理。 五边形数定理 五边形数形如 $p_n = p_{n-1}+3n-2$ 的数字被称作是五边形数，通项是 $p_n=\\dfrac{n(3n-1)}{2}$。 五边形数定理指出：$$ \\phi(x) = \\prod\\limits_{k\\ge 1}(1-x^k)=\\sum\\limits_{k=-\\infty}^{+\\infty}(-1)^kx^{p_k} $$ 其中 $p_k$ 是五边形数。设 $f_n$ 为 $n$ 的拆分数，$F(x)$ 是 $f_n$ 的 OGF，有：$$ F(x)=1/\\phi(x) $$ 即：$$ (1-x-x^2+x^5+x^7-…)(1+f_1x+f_2x^2+f_3x^3+…)=1 $$ 比较系数得：$$\\begin{aligned} &amp;f_n-f_{n-1}-f_{n-2}+f_{n-5}+f_{n-7}-…=0 \\newline \\Leftrightarrow &amp;f_n=f_{n-1}+f_{n-2}-f_{n-5}-f_{n-7}\\end{aligned}$$ 其中数列 $1,2,5,7,12,15,…$ 对应广义五边形数 $p_1,p_{-1},p_2,p_{-2},…$。 然后我们就可以愉快的递推 $f[]$ 了，可以证明这样做的复杂度为 $O(n\\sqrt{n})$。 代码： 12345678910int add(int a, int b) {return a + b &gt;= P ? a + b - P : a + b;}int p(int x) {return x * (3 * x - 1) / 2;}memset(f, 0, sizeof(f)), f[0] = 1;for(int i = 1; i &lt;= n; i++) for(int j = 1; ;j++){ int k = p(j); if(k &gt; i) break; f[i] = add(f[i], j &amp; 1 ? f[i - k] : P - f[i - k]); k = p(-j); if(k &gt; i) break; f[i] = add(f[i], j &amp; 1 ? f[i - k] : P - f[i - k]); }","link":"/2020/10/19/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"},{"title":"最大子段和问题","text":"最近刷到一道三段最大子段和的问题，发现自己连一段最大子段和都写不出来。于是怒刷四道题，特此记录…… 一 单段最大子段和问题来源 给出一段长为$N$的序列$s$，选出其中连续且非空的一段使得这段和最大。$N⩽200000$ 设$f_i$为以$i$结尾（$i$必须要选）时的最大子段和大小。则有$f_i = \\max f_{i-1}+s_i, s_i$，也就是与前面的合并成一段或者新开另一段。最后一个元素不一定要选，那么答案就是$\\max\\limits_{i=1}^n f_i$。 代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int CN = 2e5+5;int n,f[CN],g[CN];/*f[i] 的意义是在必须选 i 的前提下，得到的最大字段和g[i] 的意义是考虑前 i 个元素，得到的最大子段和 */int main(){ memset(g,-0x3f,sizeof(g)); f[0] = -0x3f3f3f3f3f; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int s; scanf(&quot;%d&quot;,&amp;s); f[i] = max(f[i-1]+s,s); //另开一段，或继承前面 g[i] = max(g[i-1], f[i]); } printf(&quot;%d&quot;,g[n]); return 0;} 二 多段最大子段和问题 给定一个长为$n$的数列$s$，从中找到$m$个无交集的连续子数列使其和最大。 有一个很优秀的DP状态设计：设$f_{i,j,0/1}$表示考虑前$ i $个位置，划分$ j $段，且第$ i $个位置的数 选(最后一维为$1$) 或 不选(最后一维为$0$) 时，得到的答案。初始状态总是$f_{1,0,0} = 0,f_{1,1,1} = s_1$，其余$f$值全清成$-\\infty$。 时空复杂度都是$O(nm)$，在$m$比较小时适用。 实际上还有一种能应对$n,m$都很大的情况的贪心通解，典型题是BZOJ2288（貌似已经找不到了）。但是我太菜，理解不了，请参阅hzwer神犇的题解。 1 两段最大不相邻子段和来源 给定一个长度为$n$的整数序列$s$，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为1，并且两个连续子序列之间至少间隔一个数。 转移方程是$f_{i,j,0} = \\max\\begin{Bmatrix} f_{i-1,j,0},f_{i-1,j,1} \\end{Bmatrix}, f_{i,j,1} = \\max \\begin{Bmatrix} f_{i-1,j,1}+s_i, f_{i-1,j-1,0}+s_i \\end{Bmatrix}$。后面的方程必须满足$j&gt;0$才可以转移，因为状态$f_{i,0,1}$没有意义。 第一个方程不用解释，第二个的意思是和前面的一块组成$j$个或者自己组成第$j$个。因为两个子段不能相邻，故后面的那个不能从$f_{i-1,j-1,1}$转移（请与后面的问题对比）。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0])f[i][j][1] = max(f[i-1][j-1][0], f[i-1][j][1]) + s[i]*/LL f[CN][3][2],s[CN];int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(); memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1]+s[i], f[i-1][j-1][0]+s[i]); } } printf(&quot;%lld&quot;,max(f[n][2][0], f[n][2][1])); return 0;} 2 三段最大子段和来源 （实际上是从hzwer神犇的博客上搞来的套题，一部分题目放在了这个题组里。） 给定一个长为$n$的数列$s$，从中找到三个无交集的连续子数列使其和最大。 转移方程是$f_{i,j,0} = \\max\\begin{Bmatrix} f_{i-1,j,0},f_{i-1,j,1} \\end{Bmatrix}, f_{i,j,1} = \\max \\begin{Bmatrix} f_{i-1,j,1}+s_i,f_{i-1,j-1,1}, f_{i-1,j-1,0}+s_i \\end{Bmatrix}$。同样，后面的方程必须满足$j&gt;0$才可以转移，因为状态$f_{i,0,1}$没有意义。 第二个方程的意思是：和前面的一块组成$j$个，或者从$i-1\\to i$这个位置断成两个数列，或者自己组成第$j$个。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0])f[i][j][1] = max(f[i-1][j-1][1], f[i-1][j][1], f[i-1][j-1][0]) + s[i] */LL f[CN][4][2],s[CN];int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(); memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=3;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1], max(f[i-1][j-1][0], f[i-1][j-1][1])) + s[i]; } } printf(&quot;%lld&quot;,max(f[n][3][0], f[n][3][1])); return 0;} 三 环形双段最大子段和问题来源 给出一段长为$n$的环状序列$s$，即认为 $s_1$ 和 $s_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。 实际上就是两种情况：选两段最大子段和（类似于这样：xxx√√xx√√√x）或选三段首尾都需要选的最大子段和（类似于这样：√√√xx√√xxx√）。 第一种情况直接跑两段最大子段和就好了，第二种情况可以看成区间总和减掉一个两段最小不相邻子段和，并且这两段中不能包括$s_1$和$s_n$。其实改一改DP边界就解决了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longconst int CN = 1e6+6;const LL INF = 0x7f7f7f7f7f7f7f7f;LL read(){/*略*/}int n;/*设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 */LL f[CN][3][2],s[CN],ans = -INF,sigma = 0;int main(){ n = read(); for(int i=1;i&lt;=n;i++) s[i] = read(),sigma += s[i]; /* 双段的情况 做最大子段和 f[1][0][0] = 0 f[1][1][1] = s[1] f[else][else][else] = -INF f[i][j][0] = max(f[i-1][j][1] , f[i-1][j][0]) f[i][j][1] = max(f[i-1][j][0] , f[i-1][j][1] , f[i-1][j-1][1]) + s[i] */ memset(f,-0x7f,sizeof(f)); f[1][0][0] = 0; f[1][1][1] = s[1]; for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = max(f[i-1][j][1], max(f[i-1][j-1][1], f[i-1][j-1][0])) + s[i]; } } ans = max(ans, max(f[n][2][0], f[n][2][1])); /* 三段的情况 做最小子段和，用前缀和相减 f[2][0][0] = 0 f[2][1][1] = s[2] f[else][else][else] = INF f[i][j][0] = min(f[i-1][j][1] , f[i-1][j][1]) f[i][j][1] = min(f[i-1][j-1][0] , f[i-1][j][1]) + s[i] 选中的两个相邻的子段不能连续 且1,n都不能被选中 */ memset(f,0x7f,sizeof(f)); f[2][0][0] = 0; f[2][1][1] = s[2]; for(int i=3;i&lt;n;i++){ for(int j=0;j&lt;=2;j++){ f[i][j][0] = min(f[i-1][j][1], f[i-1][j][0]); if(j &gt; 0) f[i][j][1] = min(f[i-1][j][1],f[i-1][j-1][0]) + s[i]; } } ans = max(ans, sigma-min(f[n-1][2][0], f[n-1][2][1])); printf(&quot;%lld&quot;,ans); return 0;}","link":"/2019/08/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/"},{"title":"最小斯坦纳树","text":"众所周知，斯坦纳树问题是一类特殊的生成树问题…… 给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G=(V,E)$，使得： $S\\subseteq V$； $G$ 为连通图； $E$ 中所有边的权值和最小。 你只需要求出 $E$ 中所有边的权值和。$n\\le 100, m\\le 500, k\\le 10$ 上述问题被称作「最小斯坦纳树」问题。 设 $f[i,S]$ 表示当前在 $i$ ，$S$ 中的点已经连通的最小代价，则有转移： $$ \\begin{aligned} f[i,S] &amp;=\\min f[i,S_0]+f[i,S\\oplus S_0]\\newline f[i,S] &amp;=\\min f[j,S]+\\text{sp}(i,j) \\end{aligned} $$ 容易发现后一个转移是最短路的形式，考虑到不存在负权边，使用 Dijkstra 转移，复杂度 $O(2^k n\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int CN = 101;const int INF = 0x3f3f3f3f;int read(){ int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN * CN];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m, k, key[CN], f[CN][1 &lt;&lt; 10];class DJ {public: int id, v; bool operator &lt; (const DJ &amp; a) const {return v &gt; a.v;}};DJ make(int a, int b) {DJ c; c.id = a, c.v = b; return c;}priority_queue&lt;DJ&gt; Q; bool vis[CN];void sp(int S){ memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) if(f[i][S] &lt; INF) Q.push( make(i, f[i][S]) ); while(!Q.empty()){ int u = Q.top().id; Q.pop(); vis[u] = true; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(vis[v]) continue; if(f[v][S] &gt; f[u][S] + E[k].w){ f[v][S] = f[u][S] + E[k].w; Q.push( make(v, f[v][S]) ); } } }}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(), m = read(), k = read(); while(m--){ int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); } for(int i = 1; i &lt;= k; i++) key[i] = read(); memset(f, 0x3f, sizeof(f)); for(int i = 1; i &lt;= k; i++) f[ key[i] ][ 1 &lt;&lt; (i - 1) ] = 0; for(int i = 1; i &lt;= n; i++) f[i][0] = 0; for(int S = 1; S &lt; (1 &lt;&lt; k); S++){ for(int i = 1; i &lt;= n; i++) for(int V = S; V; V = (V - 1) &amp; S) f[i][S] = min(f[i][S], f[i][V] + f[i][S ^ V]); sp(S); } int ans = INF; for(int i = 1; i &lt;= n; i++) ans = min(ans, f[i][(1 &lt;&lt; k) - 1]); printf(&quot;%d&quot;, ans);}","link":"/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"},{"title":"最小费用最大流","text":"此页面存在相关页面。关于网络流基础，请参见「网络最大流」。 最小费用最大流（Min Cost Max Flow，MCMF，也称费用流）问题，是指在网络流图中，对于每条边在原有的基础上再增加一个限制——单位流量的费用…… 一 概念最小费用最大流（Min Cost Max Flow，MCMF，也称费用流）问题，是指在网络流图中，对于每条边在原有的基础上再增加一个限制——单位流量的费用，并且在保证流最大的情况下使得产生的费用最小。 那么在费用流问题中，一条边就可以被描述成$e=(u,v,cap,cost,flow)$，$(u,v)$是边的起点和终点，$cap$是容量限制，$cost$是单位流量所产生的费用，$flow$是当前流量。之所以强调“单位流量“，是因为这条边总产生的费用为$flow\\times cost$。 网络的最大流显然是一定的，但是最小割可能会有多个。每个割的单位流量费用不同，于是才有了费用流问题。注意：费用流是在保证流最大的前提下，使得总产生的费用最小。 二 解决1 思路网络的最大流可能是由多条增广路径共同组成。如下图，增广路$s \\to 1 \\to 4 \\to t$和$s \\to 2 \\to 3 \\to t$共同组成了网络的最大流。 那么先分析一条增广路的费用。设该费用为$p$，该增广路经过边$e_1,e_2,…,e_m$，每条边的单位流量费用分别是$c_1,c_2,…,c_m$，且该路上当前流量为$a$，那么可以得出下面的式子： $$ p = ac_1 + ac_2 + … + ac_m = a(c_1+c_2+…+c_m) $$也就是：$$ p = a \\times \\sum\\limits_{i=1}^m c_i $$ 如果能保证$p$最小且该增广路在最大流中，那么$a$一定是个定值，且等于路上的最小割。要保证$p$最小，就是要让后面的$\\sum$最小，它表示该增广路上各条边的单位费用之和。 那么我们能想到什么？最短路把$cost$这一元看作边的边权，那么这个$\\sum\\limits_{i=1}^m c_i$就表示路上的边权之和。我们要求出最小的$\\sum$，就是在求图上的最短路。 那么就有了贪心的思路：每次找出图上$s\\to t$的最短路并把它增广，那么这条路就“断”了，然后再找最短路，直到无法增广，此时网络达到最大流，且产生的费用最小。 2 代码利用spfa找最短路，每次进行单路增广，并模拟dinic中dfs增广的退栈过程来实现数据的更新（这需要记录搜索时进入每个节点的边时哪一条边）。 注意，因为反向边是反悔机制，用来抵消正向边的影响，所以反向边的单位流量费用应该是对应正向边的相反数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const int CP=5e3+3;const int CE=1e5+1e2;const int INF=0x3f3f3f2f;//快读int read(){ int s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=((s&lt;&lt;1)+(s&lt;&lt;3))+c-'0'; return s*ne;}//边表class fs{ public: int from,to,nxt,cap,cost,flow; void init(int r,int t,int n,int c,int s,int f) {from=r; to=t; nxt=n; cap=c; cost=s; flow=f;}}E[CE];int hd[CP],ecnt=1;void _add(int x,int y,int c,int s){ E[++ecnt].init(x,y,hd[x],c,s,0); hd[x]=ecnt;}void add(int x,int y,int c,int s){ _add(x,y,c,s); _add(y,x,0,-s); //反向边}//v defineint n,m,s,t;//mcmfint mincost=0,maxflow=0;int dist[CP]; //dist : 单源最短路bool ins[CP]; //ins[i] : i 是否在队列内int prv[CP]; //prv[i] : 当前最短路中进入点 i 的边 int rst[CP]; //rst[i] : s-&gt;i路上的最小割bool Augment(int _s,int _t) //spfa{ memset(ins,false,sizeof(ins)); memset(dist,0x3f,sizeof(dist)); memset(rst,0x3f,sizeof(rst)); queue&lt;int&gt;Q; Q.push(_s); dist[_s]=0; ins[_s]=true; while(!Q.empty()) { int u=Q.front(); Q.pop(); ins[u] = false; for(int k=hd[u]; k; k=E[k].nxt){ fs e=E[k]; if(e.cap-e.flow &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u]+e.cost) { dist[e.to] = dist[u]+e.cost; //松弛，边权为cost prv[e.to] = k; //记录入边 rst[e.to] = min(rst[u], e.cap-e.flow); //递推 if(!ins[e.to]){ Q.push(e.to); ins[e.to] = true; } } } } return dist[_t]&lt;INF; //没到达 _t ，则dist[_t]=INF}void update(int _s,int _t){ //更新（模拟退栈） int pos=_t; //从终点开始 while(pos != _s){ //直到起点 E[prv[pos]].flow += rst[_t]; //正向 E[prv[pos]^1].flow -= rst[_t]; //反向 pos = E[prv[pos]].from; //前往上一个节点 }}void mcmf(int _s,int _t){ //主调用函数 while(Augment(_s,_t)){ maxflow += rst[_t]; mincost += dist[_t]*rst[_t]; //单位费用 * 流量 update(_s,_t); //更新 }} 三 网络流建模1 点容量问题拆点建模一般应用在点存在容量限制的网络流问题中，因此也可以用来求解图上的最小割点集（此时点的容量均为$1$，详见「题解」奶牛的电信）。 把图上的每个非源非汇点$i$拆成$i,i+n$两个点（$n$是总点数），其中点$i$连接原图中该点的入边，点$i+n$连接原图中该点的出边，这样$i\\to i+n$这条边就能代表原图中的点$i$，对这条边设置容量限制，实际就是对该点设置容量限制。 如下图： 2 点权均衡问题原题：负载平衡问题 给定一张由$n$个点组成的环，每个点$i$有一个点权$x_i$，点权可以在相邻节点间转移。记$ \\overline x = \\sum\\limits_{i=1}^n x_i \\div n$，求最少的转移量，使得每个$x_i$都等于$\\overline x$。 可以把仓库分成两类： $x_i &gt; \\overline x$ 的仓库$i$，记为图$L$。 $x_i &lt; \\overline x$ 的仓库$i$，记为图$R$。 $x_i = \\overline x$的仓库不会影响答案，所以放在哪一类里面都行。 很明显，$L$中节点的点权需要转移到$R$中节点去。把这个点权变成边权，那么新建总源$s$和总汇$t$，连边$s\\to L$，$L \\rightleftarrows R$与$R\\to t$。具体方法如下： $s\\to L$边上的流量限制为$L$中节点点权超出$\\overline x$的部分，即$x_i - \\overline x$，转移费用为$0$。 $R\\to t$边上的流量限制为$R$中节点点权不足$\\overline x$的部分，即$\\overline x- x_i$，转移费用为$0$。 图上所有相邻节点互相连双向边，边上没有流量限制，因为可以无限转移。不过转移的费用就是$1$。 这样，当增广一条路时，$s\\to L$的边流量增大，使得$L$中节点点权变小；$R\\to t$的边流量也增大，使得$R$中节点点权变大。其实上意味着$L,R$中点的点权会更接近于平均值$\\overline x$。当网络流达到最大时，也就是说所有不等于平均值的点权都已经被增广到平均值大小，也就达到了负载平衡。 那么跑费用流，输出最小费用。 四 二分图匹配问题1 最大基数匹配二分图的不带权最大匹配问题也称最大基数匹配问题。基础部分详见：二分图基础。 新建总源$s$，总汇$t$。设二分图的左图为$L$，右图为$R$，则将$s$向$L$中的所有节点连边，$R$中的所有节点向$t$连边，并将二分图中原有的无向边转化成$L\\to R$的有向边。所有边的容量均为$1$。于是我们可以得到一张网络流图，如下： 边的容量为$1$保证了同一条边不会同时在多条增广路中，那么任意两条增广路的交点只会是$s$和$t$。此时若求出最大流，那么最大流就是该图的最大匹配，$L\\to R$中流量为$1$的边就是最大匹配中的匹配边。 代码参见飞行员配对问题。 2 最大带权匹配 若存在一种匹配方案，使得图上所有点都被匹配，则称这个匹配为二分图的完美匹配。 先考虑存在完美匹配时的情况。 依然是上面的建图思路，并把边权看作费用，$s\\to L$和$R\\to t$的边费用为$0$。那么显然可以求出最小费用最大流。 把最大边权和转化成最小费用？两种思路：每次延着最长路增广 和 使费用为边权的相反数。 但是此时最小费用其实受最大流的限制，也就是说仅当流最大时才保证费用最小，那么这样求出来的最小费用实际上是完美匹配的最小边权和。为什么呢？当存在完美匹配时，最大流一定是这个完美匹配，那么这时候最小费用才对应着图上的最小边权和，那么也就是完美匹配的最小边权和。 那么怎样求不受边数限制的最大带权匹配？ 也就是说要摆脱这个“最大流”的限制。怎么做呢？每次增广后都记录一下当前的总费用，直到当前流最大，那么所有可能的匹配的边权和我们都已经求出来了，只要把最小（如果费用是边权的相反数）的那个挑出来就好了。 建图的图解如下： 3 最大带权独立集 选出一些节点，使得这些节点都没有边相连，称其为原图的一个独立集。 那么最大带权独立集就是在点有点权的基础上，求出一个点权和最大的独立集。 还是上面的思路。新建总源$s$，总汇$t$。设二分图的左图为$L$，右图为$R$。将$s$向$L$中的所有节点连边，容量为$L$中节点的点权；$R$中的所有节点向$t$连边，容量为$R$中节点的点权。并将二分图中原有的无向边转化成$L\\to R$的有向边，容量无限。 那么有： 最大独立集 = 总点权-最小割（最大流） 割中的边一定是$s\\to L$或$R\\to t$的边。增广它们等于删掉这些边，相当于删掉$L,R$中的结点。删掉最小割一定会导致图不连通。而在原二分图中，删掉割中的节点及所连接的边，就会导致图上一条边也没有！那么剩下的节点肯定是独立集。又保证了割最小，所以求得了最大独立集。 图解：","link":"/2019/03/19/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"title":"李超线段树","text":"众所周知，李超线段树是一类在二维平面上维护最值线段的线段树，某些情况下具有着和动态凸包相类似的功用…… 看一个栗子： 要求在平面直角坐标系中维护若干线段，支持加入一条线段和查询所有线段与直线 $x=k$ （$k$ 给出）交点纵坐标的最大值。一条线段以两个端点 $(x_0,y_0),(x_1,y_1)$ 的形式给出。$q,k,x_0,y_0,x_1,y_1\\le 10^5$ 考虑用线段树维护这些斜线。方便起见，我们将线段看成解析式的形式 $f_i(x)$。对于区间 $[l,r]$，它的中点是 $m$，我们定义 $f_i(x)$ 在这个区间上比 $f_j(x)$ 更具优势，当且仅当 $f_i(m)&gt;f_j(m)$。对于线段树上的每个节点，我们只保留它的最优势线段，这样就可操作了。 剩余的是两个问题：一条当前区间的劣势线段可能是子区间的优势线段；统计 $p$ 点处的答案时，不一定 $[p,p]$ 上存的线段是最优秀的线段。 对于第二个问题，我们只需要将线段树上从根到 $[p,p]$ 的祖孙链上的所有线段都统计一遍即可；对于第一个问题，可以考虑把劣势线段下放到它和保留线段（优势线段）有交的那个子区间里，然后递归操作即可。 根据主定理，这一部分的复杂度（更新某个区间）是 $O(\\log n)$ 的，因此李超树插入的总复杂度为 $O(\\log^2 n)$，查询的总复杂度为 $O(\\log n)$，不过它的常数很小。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#define DB double#define mp make_pairconst int CN = 1e5 + 50;const DB EPS = 1e-10;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}bool equ(DB a, DB b) {return abs(a - b) &lt;= EPS;}int n, lastans;class SEG {public: int l, r, id; DB yl, yr; SEG() {l = id = 0, r = 1;} DB slp() {return (yr - yl) / (1.0 * (r - l));} DB mid() {return (yl + yr) / 2;} DB val(int x) {return l == r ? yl : yl + slp() * (x - l);} void cl(int x) {yl = val(x), l = x;} void cr(int x) {yr = val(x), r = x;}} ;SEG mk(int a, int b, int c, int d, int e){ SEG o; o.l = a, o.yl = b, o.r = c, o.yr = d, o.id = e; return o;}bool le(SEG a, SEG b) { return a.mid() &lt; b.mid() || (equ(a.mid(), b.mid()) &amp;&amp; a.id &gt; b.id);}class SGT { public: SEG d[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void upd(int l, int r, int k, SEG x){ if(x.l &lt; l) x.cl(l); if(x.r &gt; r) x.cr(r); if(le(d[k], x)) swap(d[k], x); if(l == r) return; int m = (l + r) &gt;&gt; 1; if(x.slp() &lt; d[k].slp()) upd(l, m, lc, x); else upd(m + 1, r, rc, x); } void md(int l, int r, int k, SEG x){ if(x.l &lt; l) x.cl(l); if(x.r &gt; r) x.cr(r); if(x.l == l &amp;&amp; x.r == r) return (void)(upd(l, r, k, x)); int m = (l + r) &gt;&gt; 1; if(x.l &lt;= m) md(l, m, lc, x); if(m &lt; x.r) md(m + 1, r, rc, x); } pair&lt;DB, int&gt; qu(int l, int r, int k, int p){ if(l == r) return mp(d[k].mid(), d[k].id); int m = (l + r) &gt;&gt; 1; pair&lt;DB, int&gt; ans; if(p &lt;= m) ans = qu(l, m, lc, p); else ans = qu(m + 1, r, rc, p); if(d[k].val(p) &gt; ans.first || (equ(d[k].val(p), ans.first) &amp;&amp; d[k].id &lt; ans.second)) ans.first = d[k].val(p), ans.second = d[k].id; return ans; }} D;int enc(int x, int p) {return (x + lastans - 1) % p + 1;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read(); int cnt = 0; for(int i = 1; i &lt;= n; i++){ int tp = read(), a = read(), b, c, d; if(tp){ b = read(), c = read(), d = read(); a = enc(a, 39989), b = enc(b, 1e9), c = enc(c, 39989), d = enc(d, 1e9); if(a &gt; c) swap(a, c), swap(b, d); D.md(1, 1e5, 1, mk(a, b, c, d, ++cnt)); } else a = enc(a, 39989), printf(&quot;%d\\n&quot;, lastans = D.qu(1, 1e5, 1, a).second); } return 0;} 在斜率优化中的应用看这样一个斜率优化的经典模型： 有 $n$ 个点依次排列，第 $i$ 个点有正数权值 $h_i$。你可以划一条线段连接两个点 $i,j$，费用是 $(h_i-h_j)^2$；要求你画的所有线段只能在端点处相交，且对于每个未被连接的点 $i$，需要支付 $w_i$ 的费用。现在需要把 $1$ 号点和 $n$ 号点连接，求连接的最小费用。$n\\le 2\\times 10^5, 0\\le |w_i|, h_i\\le 10^6$ 设 $f[i]$ 为连接到 $i$ 的最小费用，设 $s_i$ 是 $w_i$ 的前缀和，有 $f[i] = \\min\\limits_{j=1}^{i-1}f[j]+(h_i-h_j)^2+s_{i-1}-s_j$。 我们可以考虑将其化为斜率优化的一般形式，设 $y_j=f[j]+h^2_j-s_j,b_j=-2h_ih_j+y_j$，则可以看成有一堆点 $(h_j,y_j)$，每次给出一个斜率 $-2h_i$，求纵轴截距 $b_j$ 的最小值。由于 $h_j$ 和 $-2h_i$ 均不单调，朴素斜率优化思路需要用 Splay 维护下凸包二分，或者 CDQ 分治，但是我都不会。 换一个思路：设 $f_i(x)=k_ix+y_i$，其中 $k_i=-2h_i,y_i=f[i]+h^2_i-s_i$，则我们在求 $h^2_i+s_{i-1}+\\min\\limits_{j=1}^{i-1} f_j(h_i)$。后面那个式子直接用李超树维护即可，由于这里的线段是直线，因此复杂度 $O(n\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int CN = 1e5 + 10;const int CV = 1e6 + 10;LL read(){ LL s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int n; LL h[CN], s[CN];LL squ(LL x) {return x * x;}class SEG {public: LL k, b; SEG() {b = 1e18;} LL val(LL p) {return k * p + b;}} ;SEG mk(LL a, LL b) {SEG o; o.k = a, o.b = b; return o;}class SGT { public: SEG d[CV &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void upd(int l, int r, int k, SEG x){ int m = (l + r) &gt;&gt; 1; if(x.val(m) &lt; d[k].val(m)) swap(d[k], x); if(l == r) return; if(x.k &gt; d[k].k) upd(l, m, lc, x); else upd(m + 1, r, rc, x); } LL qu(int l, int r, int k, int p){ if(l == r) return d[k].val(p); int m = (l + r) &gt;&gt; 1; LL ans = 1e18; if(p &lt;= m) ans = qu(l, m, lc, p); else ans = qu(m + 1, r, rc, p); return min(ans, d[k].val(p)); }} D;int main(){ n = read(); for(int i = 1; i &lt;= n; i++) h[i] = read(); for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + read(); LL yi = squ(h[1]) - s[1], ki = -2 * h[1], fi; D.upd(1, 1e6, 1, mk(ki, yi)); for(int i = 2; i &lt;= n; i++){ fi = squ(h[i]) + s[i - 1] + D.qu(1, 1e6, 1, h[i]), yi = squ(h[i]) - s[i] + fi, ki = -2 * h[i], D.upd(1, 1e6, 1, mk(ki, yi)); } printf(&quot;%lld&quot;, fi); return 0;} 相关题目 「HEOI2013」Segment 「CEOI2017」Building Bridges","link":"/2020/11/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"title":"树上的动态规划","text":"对于树上的动态规划问题，一般可以分为两类：树型结构的DP问题和树形背包。两种模型都存在树型的依赖关系，前者侧重相邻节点间的制约条件，后者则更像是一个有依赖关系的背包问题…… 一 树型结构的DP问题1 模型给定$ n $个物品，且这些物品构成一个树形结构。树上的父节点与子节点间存在一些制约，通常表现为父子节点无法同时被选择。同时，每件物品还有一个权值（点权）。 这就是树形结构的DP问题的基本模型。 树形结构的DP问题通常用来求解上述模型的 最大/最小 点权和。 「luogu P1352」没有上司的晚会 某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 很明显，上司与职员的关系构成一棵树，树上的子节点与父节点无法同时被选择。 2 状态设计定义$ f_{i,k} $为考虑以$ i $为根的子树，且节点$ i $的选择状态为$ k $时求的的解（$ k=1 $表示选择节点$ i $，$ k=0 $表示不选择节点$ i $）。 因为当前节点一旦选中，子节点则全部无法选择，故转移方程一：$$ f_{i,1} = \\sum_{i,j \\in E}f_{j,0} $$（$ E $为边集） 若当前节点不被选中，子节点则可选可不选，故转移方程二：$$ f_{i,0} = \\sum_{i,j \\in E}\\max f_{j,0},f_{j,1}$$（$ E $为边集） 答案为$ \\max f_{1,0},f_{1,1} $。 3 实现因为状态的转移需要由叶向根转移，我们可以借助dfs实现状态的转移。 123456789101112131415int dp(int cur){ f[cur][1]=v[cur]; //预处理 for(int k=hd[cur]; k; k=E[k].nxt) //遍历边表 { int to=E[k].to; dp(to);//求出子节点的两个状态 f[cur][0]+=max(f[to][0], f[to][1]);//判断子节点选和不选哪个更优 f[cur][1]+=f[to][0];//sigema } return max(f[cur][0], f[cur][1]);} 二 树形背包问题1 模型给定$ n $个物品，子物品和主物品存在依赖关系，且这些关系满足树的性质，即所有物品构成一个树形结构。每个节点有点权。令在其中选出$ m $个，且对于任意一棵子树，必须先选中父节点，才可以在该子树的所有节点中选择。 这就是树形背包问题的基本模型。 树形背包通常用来求解上述模型的 最大/最小 点权和。 「Luogu P2014」选课 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 显然，先修课与后修课的关系满足树状结构。 2 状态设计定义$ f_{i,s_i} $为选中节点 $ i $，且当前节点为根的树中选择$ s_i $个节点（不含根）的解。 设$sum_i$为子树$i$的总结点数。对于节点$ i $，当固定了$s_i$的值时，它的$f$值可以分成两个部分：它的一棵子树的解（$f_{j,s_j}$）和其他子树的解之和（$ f_{i,s_i-s_j-1}$ )。因为$s_j$里面实际不包含节点$j$，所以最后还要$-1$。 那么转移方程： $ f_{i,s_i} = \\max f_{j,s_j}+f_{i,s_i-s_j-1} +c[j] | s_i\\leqslant sum_i,s_j\\leqslant sum_j,(i,j)\\in E$（$c[j]$为节点权值，$E$为边集） 2-1 小问题：为什么一棵子树不会被重复累加？我们考虑以背包的方式更新当前节点的解，则一棵子树在被累加之前不会累加在$ f_{i,s_i-s_j-1}$ 中。 3 实现因为状态转移需要知道当前的$ s_i $，且需要从叶向根转移状态，所以我们依然用dfs来实现。 统计子树节点需要一遍dfs。但是考虑任意节点，我们都可以分段的转移状态。即我们可以边统计它的节点个数，边转移状态，因为状态的转移是不存在后效性的。 1234567891011121314151617void dfs(int cur,int prv) //cur当前，prv父节点{ sum[cur]=1; for(int k=hd[cur]; k; k=E[k].nxt) //遍历边表 { int to=E[k].to; dfs(to, cur); //递归处理 sum[cur] += sum[to]; //累加节点数 for(int j=min(m, sum[cur]); j; j--) //分配给当前树的节点数 for(int k=min(j-1, sum[to]); k&gt;=0; k--) //分配给子树的节点数 f[cur][j] = max(f[cur][j], f[to][k]+f[cur][j-k-1]+c[to]); //这里要加上子节点的权值，因为f[to][k]不包含节点to的权值 }} 题中树形结构可能构成森林，故我们假设森林有一个总根$0$，调用dfs(0,0)即可解决。 因为状态定义中每个$f$不包含根，故新增总根对答案状态无影响。 答案为$f_{0,m} $","link":"/2019/02/01/%E6%A0%91%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"概率期望学习笔记","text":"众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字…… 概念随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\\times (2/3)=5/3$。 线性性根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：$$ E(\\Sigma x_i)=\\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：$$E(x+c)=E(x)+c$$ 一道简单题 有一个长度为 $n$ 的数列，一开始所有位置都未被访问。每次随机一个未被访问过的位置，将它和它之前的位置都标记为访问过，问期望操作次数。$n\\le 10^{18}$ 考虑期望的线性性，答案就等于每个位置能被访问到的概率。一个位置 $i$ 能被访问到当且仅当它在所有它后面的数之前被访问，这个概率是 $\\frac{1}{n-i+1}$，因此容易发现答案是调和级数 $H_n$，使用近似公式计算即可。 又一道简单题 有一个 $n$ 个节点的有根树，一开始所有节点都未被访问。每次随机一个未被访问过的节点，将它到根的路径上所有点都标记为访问过，问期望操作次数，对 $998244353$ 取模。$n\\le 10^7$ 仿照上题，容易发现答案是 $\\sum\\limits_{i=1}^n\\frac{1}{sz[i]}$，其中 $sz[i]$ 表示子树 $i$ 的大小，线性求逆即可。 双一道简单题 $n$ 堆石子，每堆有 $a_i$ 个，每次随机选一个石子，并取光它所在的那堆石子。问第一堆石子被取到的时间的期望。$n\\le 10^5$ 根据期望的线性性，答案等于每堆石子在 $1$ 之前取到的期望之和，即 $1+\\sum\\limits_{i=2}^n\\frac{a_i}{a_1+a_i}$，线性计算即可。 叒一道简单题 一个 $n$ 面的骰子，问每一面都被掷到的期望投掷次数。$n\\le 10^{18}$ 此类问题被称作「赠券收集问题」。设 $f[n]$ 为 $n$ 面掷出后还需投掷的次数的期望，易得 $f[i]=\\frac{i}{n}f[i]+\\frac{n-i}{n}f[i+1]+1$，整理得 $f[i]=f[i+1]+\\frac{n}{n-i}$，从而有 $f[0]=nH_n$，利用公式计算即可。 叕一道简单题 求所有 $n!$ 个 $n$ 的全排列中，逆序对数的期望，对 $998244353$ 取模。$n\\le 10^{7}$ 众所周知，$n$ 的全排列一共有 $\\dfrac{n!}{2}\\dbinom{n}{2}$ 个逆序对，即对每个二元组 $(i,j)$ 讨论一下它们是否会形成逆序对。因此答案为 $\\dfrac{\\dfrac{n!}{2}\\dbinom{n}{2}}{n!}=\\dfrac{n(n-1)}{4}$。 一道栗题 一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。求该 01 串的价值的期望。$n\\le 10^5$ 设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：$$ \\begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \\newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \\end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。 又一道栗题 给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。你需要随机一个节点的排列 $P\\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。$n\\le 10^5$, 且保证树的形态随机 根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。因为树的形态随机，所以树高是期望 $O(\\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\\sum c_v·t_v$ 即可。 容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。考虑一次累加应当是什么样子： $1\\to p_1\\to p_2\\to …\\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。则 $f_i$ 即代表考虑所有 $P\\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：$$ f_i=\\sum\\limits_d \\dbinom{i-1}{d-1}\\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\\sqrt{n})$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 6;const int P = 1e9 + 7;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int n, a[CN], fac[CN], ifac[CN], f[CN];int C(int n, int m) {return 1ll * (1ll * fac[n] * ifac[m] % P) * ifac[n - m] % P;}int stk[CN], ans = 0;void dfs(int u, int p, int dep){ stk[dep] = a[u]; for(int i = dep, j = 1; i; i--, j++) ans = (1ll * stk[i] * f[j] % P + ans) % P; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs(v, u, dep + 1); }}int main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} for(int i = 1; i &lt;= n; i++) a[i] = read(); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n] = qp(fac[n], P - 2); for(int i = n - 1; i; i--) ifac[i] = 1ll * (i + 1) * ifac[i + 1] % P; for(int i = 1; i &lt;= 5000; i++){ for(int d = 1; d &lt;= i; d++){ int prd = 1ll * C(i - 1, d - 1) * C(i, d) % P; prd = 1ll * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P; } f[i] = 1ll * f[i] * ifac[i] % P; } for(int i = 1; i &lt;= n; i++) ans = (ans + a[i]) % P; dfs(1, 0, 1), ans = 1ll * ans * fac[n] % P; printf(&quot;%d&quot;, ans);} 双一道栗题 有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。$n,k_i \\le 500$ 容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。假定 $\\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：$$\\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\\newline &amp;=k_iE_{i-1}+b_i \\end{aligned} $$ 注意到还有 $\\prod\\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\\sum k_i + n\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define DB doubleconst int CN = 550;const DB EPS = 1e-9;int n, m, id[CN]; DB k[CN], b[CN], p[CN];bool cmp(DB x, DB y) {return x &gt; y;}bool comp(int i, int j) {return k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];}int main(){ n = read(); for(int i = 1; i &lt;= n; i++){ m = read(); for(int j = 1; j &lt;= m; j++) scanf(&quot;%lf&quot;, &amp;p[j]); sort(p + 1, p + m + 1, cmp); DB prd = 1.0; if(p[1] &gt; 1.0 - EPS) {i--, n--; continue;} while(m &amp;&amp; p[m] &lt;= EPS) m--; for(int j = 1; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (1.0 - p[j]); b[i] += m * prd, id[i] = i; } sort(id + 1, id + n + 1, comp); DB ans = 0; for(int i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i]; printf(&quot;%.9lf&quot;, ans);} 叒一道栗题 有 $m$ 张牌，其中一张是王牌。现在你执行 $n$ 次如下操作：洗牌后查看第一张牌是什么。令 $x$ 为洗牌后第一张牌为王牌的次数，现在假设洗牌时 $m!$ 种牌的排列出现的概率均相等，求 $x^k$ 的期望值，对 $998244353$ 取模。$n,m\\le 998244352, k\\le 5000$ 题目等价于：有 $n$ 个相互独立的随机变量 $x_1,x_2,…x_n$，每个变量有 $\\frac{1}{m}$ 的概率为 $1$，其余情况为 $0$，求：$$E[\\left(\\sum\\limits_{i=1}^nx_i\\right)^k]$$ 根据期望的线性性，可以枚举 $d=\\sum\\limits_{i=1}^nx_i$，则有：$$\\begin{aligned} E[\\left(\\sum\\limits_{i=1}^nx_i\\right)^k] &amp;=\\sum\\limits_{d=0}^n E(d^k)\\newline &amp;= \\sum\\limits_{d=0}^n P(d)·d^k\\newline &amp;= \\sum\\limits_{d=0}^n\\dbinom{n}{d}\\left(\\frac{1}{m}\\right)^d\\left(1-\\frac{1}{m} \\right)^{n-d} ·d^k \\end{aligned}$$ 把后面的 $d^k$ 拿 Stirling 数展开，大力化一下柿子，得到：$$ \\sum\\limits_{d=0}^n\\dbinom{n}{d}\\left(\\frac{1}{m}\\right)^d\\left(1-\\frac{1}{m} \\right)^{n-d} ·d^k=\\sum\\limits_{i=0}^k \\begin{Bmatrix}k\\newline i\\end{Bmatrix} n^{\\underline{i}}\\left(\\frac{1}{m} \\right)^i $$ 就可以做了，时间复杂度 $O(k^2)$。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int P = 998244353;const int CN = 5005;int qp(int a,int b) {int r = 1; while(b) {if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P; b &gt;&gt;= 1;} return r;}int n, m, k, S[CN][CN], ans = 0;int main(){ n = read(), m = read(), k = read(), m = qp(m, P - 2); S[0][0] = 1; for(int i = 1; i &lt;= k; i++) for(int j = 1; j &lt;= i; j++) S[i][j] = (1ll * j * S[i - 1][j] % P + S[i - 1][j - 1]) % P; int fall = 1, pw = 1; for(int i = 0; i &lt;= k; i++){ int prd = 1ll * S[k][i] * fall % P; ans = (1ll * prd * pw % P + ans) % P; pw = 1ll * pw * m % P, fall = 1ll * fall * (n - i) % P; } printf(&quot;%d&quot;, ans);} 相关题目 暂无来源 暂无来源 暂无来源 「SPOJ1026」FAVDICE - Favorite Dice 暂无来源 「BZOJ4318」OSU! 暂无来源 暂无来源 「CF1278F」Cards 习题「LG-P6843」梦原「LG-P5835」线形生物","link":"/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"欧几里得与扩展欧几里得定理","text":"$$ \\gcd(a,b) = \\gcd (b,a \\text{ mod } b) $$ $$ \\begin{cases} ax_1 + by_1 = \\gcd(a,b) \\newline bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b) \\end{cases} \\Rightarrow \\begin{cases} x_1 = y_2 \\newline y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2 \\end{cases}$$ 一 欧几里得定理1 最大公约数最大公约数（Greatest Common Divisor，GCD），是指对于两个整数$a,b$，找到一个最大的整数$k$，使得$k|a$且$k|b$（“$|$”表示整除）。 2 欧几里得定理对于任意整数对$(a,b)$，它们的最大公约数都等于整数对$(b,a\\text{ mod }b)$的最大公约数。用公式表达就是这样：$$\\forall a,b\\in Z , \\gcd(a,b) = \\gcd(b, a\\text{ mod }b)$$ 证明请参照OI Wiki - gcd。 3 代码实现当$b=0$时，可知$\\gcd(a,b) = \\gcd(a,0) = a$。故递推$\\gcd(a,b) = \\gcd(b,a\\text{ mod }b)$直到$b=0$。 实现如下： 1234int gcd(int a,int b){ if(!b) return a; return gcd(b, a%b);} 甚至可以压行： 1int gcd(int a,int b) {return b ? gcd(b,a%b) : a;} 二 扩展欧几里得定理1 模型扩展欧几里得定理（EX-GCD）用于求解关于$x,y$的，形如$ax+by = \\gcd(a,b)$方程的一组可行解。该定理的基本内容如下： 设$ax_1 + bx_2 = \\gcd(a,b)$，$bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b)$，则有$x_1= y_2, y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2$。即为引言中的公式： $$ \\begin{cases} ax_1 + by_1 = \\gcd(a,b) \\newline bx_2 + (a\\text{ mod }b)y_2 = \\gcd(b,a\\text{ mod }b) \\end{cases} \\Rightarrow \\begin{cases} x_1 = y_2 \\newline y_1 = x_2- \\lfloor\\dfrac{a}{b}\\rfloor \\times y_2 \\end{cases}$$ 证明也请参见OI Wiki - exgcd。 2 代码实现当$b=0$时，$\\gcd(a,b) = \\gcd(a,0) = a$。此时$ax + by = \\gcd(a,b) = a$的一组可行解是$\\begin{cases} x = 1 \\ y = 0 \\end{cases}$。把这个作为边界条件带入gcd函数，不断向上面一样递推至$b=0$，再在回溯过程中计算答案即可。 1234567891011void exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b){ x = 1; y = 0; return; } exgcd(b,a%b,x,y); int t = x; //保存x2 x = y; //计算x1 y = t-(a/b)*y; //计算y1 } 3 解的关系设$k$为任意整数，则当$x_1,y_1$是方程$ax+by = \\gcd(a,b)$的一组解时，$x_1+kb,y_1-ka$也是该方程的一组解。 证明如下：因$ax_1 + by_1= \\gcd(a,b)$①，得$ax_1 + by_1 + k·a·b - k·a·b= \\gcd(a,b)$。变换得$ax_1 + a·kb + by_1 - b·ka = \\gcd(a,b) , a(x_1 + kb) + b(y_1 - ka) = \\gcd(a,b)$②。因①式成立，故 ② 式成立。即$x_1+kb,y_1-ka$是方程的可行解。 三 变形 「NOIP2012」同余方程 求关于 x的同余方程$ a x \\equiv 1 \\pmod {b}$的最小正整数解。 设$y·b + 1 = ax$，即$ax - by = 1$，则题目要求为找出满足上面等式的最小的正整数$x$。设$y_0 = - y$，变形为$ax + by_0 = 1$，似乎可以用exgcd处理。 考虑$\\gcd(a,b)$的定义，$ax + by_0$一定是$\\gcd(a,b)$的倍数。因$ax + by_0 = 1$，故$\\gcd(a,b)|1$。因$\\gcd(a,b) \\geqslant 1$，故$\\gcd(a,b) = 1$。那么上面的$ax + by_0 = 1$再变形为$ax + by_0 = \\gcd(a,b)$。直接用exgcd求解就好了。 答案的处理因exgcd可以求出上述方程的一组任意解，而题目要求是求出“最小正整数解”。根据解的关系，可知当$x_1$是解时，$x_1 \\pm b$也是解。那么当$x \\leqslant 0$时，另$x + b$直到$x &gt; 0$；反之同理，即可求出最小正整数解。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;#define LL long longLL read(){ LL s=0,ne=1; char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar()) if(c=='-') ne=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0'; return s*ne;}LL a0,b0,x,y;void exgcd(LL a,LL b){ if(!b) return (void)(x=1,y=0); exgcd(b, a%b); int t = x; x = y; y = t-(a/b)*y;}int main(){ a0=read(); b0=read(); exgcd(a0,b0); while(x &lt; 0) x += b0; x %= b0; //大于，直接取模 printf(&quot;%d&quot;,x); return 0;}","link":"/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"title":"模线性方程组与中国剩余定理","text":"这篇文章会比较杂乱，因为好多内容都被我搞到一块来了…先写一个内容摘要可供参考： 利用扩展欧几里得算法（exgcd）求解二元一次不定方程 利用exgcd求解单变元模线性方程 利用中国剩余定理（CRT）与扩展中国剩余定理（exCRT）求解单变元模线性方程组…… 一 求解二元一次不定方程1 理论关于$x,y$的，形如$ax+by = c$的方程被称作二元一次不定方程。在实数域中，不定方程有无限组解，因为它可以被看作一条二维平面内的直线，直线上每一个点都对应方程的一组实数解。 但是不定方程却不一定有$x,y$都为整数的解（以下通称“整数解”）。根据扩展欧几里得定理我们知道：不定方程$ax+by=\\text{gcd}(a,b)$一定存在整数解。但是推广到一般形式呢？我们不妨将$ax+by=c$两边同时除以$\\text{gcd}(a,b)$，得$a/\\text{gcd}(a,b)\\times x+b/\\text{gcd}(a,b) \\times b = c/\\text{gcd}(a,b)$。假设$x,y$均为整数，则等式左边的部分$a/\\text{gcd}(a,b)\\times x+b/\\text{gcd}(a,b) \\times b$一定是整数，故等式右边的部分$c/\\text{gcd}(a,b)$也一定是整数，可知$ax+by=c$存在整数解的条件是$\\text{gcd}(a,b)|c$（$\\text{gcd}(a,b)$是$c$的因子）。 于是我们知道了二元一次不定方程整数解存在性的判定方法，然后我们需要解这个不定方程。 将方程两边同时除以$c/\\text{gcd}(a,b)$，化为$\\dfrac{a·\\text{gcd}(a,b)}{c}\\times x+\\dfrac{b·\\text{gcd}(a,b)}{c}\\times y =\\text{gcd}(a,b)$。然后我们再建立一方程使得$ax’+by’ = \\text{gcd}(a,b)$，使得可以用exgcd求出该方程的特解$x’,y’$。于是我们获得了$\\dfrac{a·\\text{gcd}(a,b)}{c}\\times x+\\dfrac{b·\\text{gcd}(a,b)}{c}\\times y =ax’+by’$，因为一定存在$x’|x,y’|y$，于是推出$x = x’\\times\\dfrac{c}{\\text{gcd}(a,b)},y = y’\\times\\dfrac{c}{\\text{gcd}(a,b)}$。 然后我们就求出了二元一次不定方程的一组特解，通解：令$kx = b/\\text{gcd}(a,b),ky = a/\\text{gcd}(a,b)$，则$x+i\\times kx,y-i\\times ky\\text{ }(i\\in Z)$是方程的通解。 2 代码12345678910111213141516171819202122LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ //普通的exgcd if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x0,LL &amp;y0,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x0,y0); LL kc = c/g; x0 *= kc; y0 *= kc; kx = b/g; ky = a/g; return true;} 二 求解单变元模线性方程1 理论关于$x$的，形如$ax+k\\equiv b (\\text{mod }m)$的方程被称作单变元模线性方程。该方程可以被化为一般形式$ax\\equiv b(\\text{mod }m)$（注意这里的等式和上面的等式中，$b$并不表示同一个数）。 解方程$ax\\equiv b(\\text{mod }m)$需要先把它去除同余。不妨把$ax$与$b$相差的那一部分（$|ax-b|$）补齐，于是得到等式$ax=b+km$，可化为$ax-mk=b$，实际上是一个关于$x,k$的二元一次不定方程。然后就可以exgcd求解。注意，我们只关注$x$的取值，而对$k$不作要求。并且$x$应该在模$m$的情况下才有意义，所以我们关注的是$x$的最小非负整数解。 2 代码12345678910111213141516171819202122232425262728293031323334LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;} //求模线性方程 ax ≡ b(mod m)的最小非负整数解x0//化成ax-my = b //通解x = x0+i*k bool LineModEqu(LL a,LL b,LL m,LL &amp;x0,LL&amp; k){ LL y0,kx,ky; if(!ExGcd(a,m,b,x0,y0,kx,ky)) return false; k = kx; x0 %= k; x0 = (x0+k)%k; //取非负整数 return true;} 然后你不觉得这个东西可以来求逆元吗？？？ 三 中国剩余定理经过了前面的铺垫，终于可以步入正题了。 1 单变元模线性方程组把$n$个$x$系数为$1$的单变元模线性方程搞到一起，就得到了一个单变元模线性方程组。它是类似于这样的：$$ \\begin{cases} x \\equiv b_1(\\text{mod }m_1) \\newline x \\equiv b_2(\\text{mod }m_2) \\newline x \\equiv b_3(\\text{mod }m_3) \\newline …\\newline x \\equiv b_n(\\text{mod }m_n) \\end{cases} $$ 2 中国剩余定理若单变元模线性方程组的模数$m_1,m_2,m_3,…,m_n$两两互质，那么这个同余方程组可以用中国剩余定理（CRT）来求解。否则用扩展中国剩余定理（exCRT）求解，下面讲。 我们设$M = \\prod\\limits_{i=1}^n m_i,M_i = M/m_i$。对于每一个$M_i$，求出它在模$m_i$意义下的逆元$t_i$，则$x = \\sum\\limits_{i=1}^n M_i·t_i·b_i$。然后这个$x$是在模$M$情况下有意义，所以将它模$M$就求出了最小非负整数解。 3 代码1234567891011121314151617181920212223242526272829303132333435363738/*解单变元模线性方程ax ≡ b*/LL gcd(LL a,LL b){return b ? gcd(b,a%b) : a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); LL tx = x; x = y; y = tx-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;}bool LineModEqu(LL a,LL b,LL m,LL &amp;x,LL &amp;k){ LL y,kx,ky; if(!ExGcd(a,m,b,x,y,kx,ky)) return -1; k = kx; x %= k; x = (x+k)%k; return true; }/*CRT*/void CRT(int n,LL &amp;x,LL *b,LL *m){ LL M=1; for(int i=1;i&lt;=n;i++) M *= m[i]; x = 0; for(int i=1;i&lt;=n;i++){ LL Mi = M/m[i],Ti,k; LineModEqu(Mi,1,m[i],Ti,k); //求逆元 (x += b[i]*Mi*Ti) %= M; } x = (x+M)%M; //搞成非负数 } 四 扩展中国剩余定理1 理论单变元模线性方程组的模数不满足两两互质，就要使用扩展中国剩余定理合并方程。 先考虑$n=2$（仅有两个方程）的情况。类似于这样：$$ \\begin{cases} x \\equiv b_1(\\text{mod }m_1) \\newline x \\equiv b_2(\\text{mod }m_2) \\end{cases} $$ 去掉同余，我们推出$x = k_1m_1+b_1 = k_2m_2+b_2$。然后后面的部分可以变型成$k_1m_1 -k_2m_2 = b_2-b_1$，然后你发现这坨东西又可以exgcd……于是我们求出了上面那个二元一次不定方程的一组最小非负整数解$k_1,k_2$。设$x’ = k_1m_1+b_1,m’ = \\text{lcm}(m_1,m_2)$。 我们假设$k_1m_1+b_1 \\equiv k_2m_2+b_2 (\\text{mod }k)$成立，则条件是$m_1|k$且$m_2|k$。故可知最小的$k = m’$。故推出$x\\equiv x’ (\\text{mod }m’)$，也就是把两个方程合并成了一个。 最后只会剩下一个单变元模线性方程，你再exgcd一遍就解出来了。 然后你未免会发现上面的说法存在一些逻辑上的缺漏。没办法，水平有限，没法搞得太严谨，将就着理解，还是背代码更重要。 2 代码1234567891011121314151617181920212223242526272829303132333435/*解单变元模线性方程ax ≡ b*/LL gcd(LL a,LL b){return b ? gcd(b,a%b) : a;}void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); LL tx = x; x = y; y = tx-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;}/*ExCRT*/bool ExCRT(int n,LL &amp;x,LL *b,LL *m){ b[0] = 0; m[0] = 1; //x ≡ 0(mod 1) LL k0,ki,kk0,kki; for(int i=1;i&lt;=n;i++){ //合并方程 if(!ExGcd(m[0],m[i],b[i]-b[0],k0,ki,kk0,kki)) return false; //解不定方程 k0 %= kk0; b[0] += k0*m[0]; //x' = b0*k0*m0 m[0] = (m[i]*m[0])/gcd(m[i],m[0]); //m' = lcm(m0,mi) b[0] %= m[0]; //在取模意义下 b[0] = (b[0]+m[0])%m[0]; //搞成非负数 } x = b[0]; //x ≡ b0(mod 1) =&gt; x = b0 return true;} 参考资料：初等数论(1) - CDC","link":"/2019/07/22/%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"title":"欧拉路","text":"欧拉跑过的七桥古塘，让你，心驰神往…… 一 引入1 欧拉路问题 数学家欧拉在研究著名的德国哥尼斯堡(Koenigsberg)七桥问题时，发现欧拉路。流经哥尼斯堡的普雷格尔河中有两个岛，两个岛与两岸共4处陆地通过7座桥彼此相联。七桥问题就是如何能从任一处陆地出发，经过且经过每个桥一次后回到原出发点。 欧拉由此提出了著名的欧拉定理。 欧拉路问题，也称“一笔画问题”。即给定一张图（有向或无向），求出图上的一条路径，使得这条路径经过图上的所有边恰好一次。 若存在满足上述条件的道路，则这条道路被称为欧拉道路。若一条欧拉道路的起点与终点相重合，则这条道路被称为欧拉回路。若图中已判定存在欧拉回路，则从任意一点出发，均可以回到该点。 2 解的存在性存在一条欧拉道路，首先需要保证图是联通的。 对于一个联通图，定义$d_i$为节点$i$所连接的边数（也就是度）。对于图上$d_i$的值为奇数的节点，称之为奇点。定理：（蒟蒻并不会证明） 若图上没有奇点，则一定存在欧拉回路。 若图上存在两个奇点，则一定存在欧拉道路，且该道路以这两个奇点为端点。 若图上存在多于两个奇点，则不存在欧拉道路。 二 实现算法的思路很简单：先判断解的有无，然后从奇点（若不存在就从任意一点）出发，搜索整张图，并把每次走过的边删除。那么我们访问节点的先后顺序就是欧拉道路。 有一点需要注意，当使用边表存图时，删边需要把正反两条边同时删除。故边从$1$开始标号，使得$i \\text{xor} 1$总是$i$的反向边。 给出代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int CP=1e3+3;const int CE=CP*CP;const int INF=0x3f3f3f3f;//边表class fs{ public: int to,nxt;}E[CE];int hd[CP],ecnt=1; //边的标号从1开始void add(int x,int y){ E[++ecnt].to=y; E[ecnt].nxt=hd[x]; hd[x]=ecnt;}//variable defineint n,m;int d[CP]; //度//判断解的存在bool examine(){ int sum=0; for(int i=1;i&lt;=n;i++) if(d[i]%2) sum++; return (!sum) || (sum==2);}//求解bool vis[CE]; //每条边是否访问过int list[CP]; //保存答案void dfs(int u){ for(int k=hd[u]; k; k=E[k].nxt) if(!vis[k]) { vis[k]=vis[k^1]=true; //正反边同时标记 dfs(E[k].to); } list[++list[0]]=u; //记录，注意要倒序输出，因为是在回溯时记录}bool solve(){ if(!examine()) return false; int st=1; //起点默认为1 for(int i=1;i&lt;=n;i++) if(d[i]%2) //为奇点 st=i; //从奇点出发 dfs(st); return list[0]==n; //当list[0]!=n时，可以判定图不联通}","link":"/2019/02/26/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"title":"状态压缩的动态规划","text":"状态压缩的动态规划，实际上也是一种“暴力出奇迹”的做法。 一 模型 「SCOI2005」互不侵犯 在$N \\times N$的棋盘里面放$K$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共$8$个格子。 $1 \\le N \\le 9, 0 \\le K \\le N^2$ 1 暴力思路先考虑暴力解法。爆搜第一行的状态，在合法的情况下，再爆搜下一行状态，得到这两行的所有可行方案。然后递归向下一行求解。直到得到前$N$行的可行方案，且当前方案放置了$K$个国王，此时累加答案。 2 从暴力到动态规划一个国王攻击距离只有一个格子。这就是说，如果仅考虑前$i$行，那么当前求解第$i$行时，受其影响的只有第$i-1$行（下面的格子越界了不去考虑，左右的个子同在第$i$行，剩下的只在第$i-1$行）。 也就是说，第$i$行的状态可以由第$i-1$行转移过来。 然后我们灵稽一动，是不是设$f_{i,j}$表示考虑前$i$行放$j$个国王的解数，就能切了这题吗？然而并不是。当前行和上一行之间，怎么保证满足限制且能快速的计算出满足限制的解数？ 爆搜当前行和上一行的排列方案？还是不行。存在后效性：当当前行的排列方案改变的时候，$f$的值也会发生变化，不能用$f_{i,j}$一个状态一概而过。 那么就得加一维状态，也就是把爆搜放到数组的维度里。 3 把爆搜变成数组的维度不要听题目瞎扯。爆搜怎么可能变成数组的维度？！实际上，是把排列方案变成数组的维度。这个排列方案也可称作“状态”，于是就有了“状态压缩的动态规划”。 我们考虑每一行，有$N$个位置，放置国王用$1$表示，不放国王用$0$表示，那么我们会得到一个01串，如下：$$ 01101 $$这是当$N=5$时的随机一行的一种状态。虽然它不合法，但是这没有关系。它表示当前行，第一个位置没有国王，第二、三个位置有国王，第四个位置没有国王，第五个位置有国王。 那什么是“压缩”？我们把上面的01串看作二进制。 $ (01101)2 = (13)10 $ 所以我们把这个状态编号为$13$，这就是状态压缩。 有了状态压缩，我们就可以定义$f_{i,j,cur}$表示考虑前$i$行放$j$个国王，且放置状态为$cur$时的解数。解决了后效性的问题。转移方程：$ f_{i,j,cur}=1|i=1,j=sumbit(cur),j \\leqslant K,exmslf(cur) $$ f_{i,j,cur}=f_{i,j,cur}+f_{i-1,j-sumbit(cur),prv}|1&lt;i \\leqslant N,j \\leqslant K,exmslf(cur,prv),exmcpl(cur,prv) $其中，$cur$为当前行状态，$prv$为上一行状态，$sumbit$函数实现统一任意一个状态里国王放置的数量，$exmslf$函数实现检查任意一个状态是否合法（一行中是否有国王可以互相攻击），$exmcpl$函数实现检查任意两个状态是否可以相邻（上下两行是否有国王可以互相攻击）。 4 枚举状态考虑怎么枚举状态。当$N=5$时，状态最大为$(11111)_2$，最小为$(00000)_2$。$(11111)_2=(100000)_2-(1)_2$$ (100000)_2=1&lt;&lt;5=1&lt;&lt;N(=2^N) $故状态在$0$到$1&lt;&lt;N$之间（不包括$1&lt;&lt;N$）。（注：“$&lt;&lt;$”是位运算中的左移运算符） 所以只需要 for(int cur=0; cur&lt;(1&lt;&lt;N); cur++) 就好了。 二 代码实现1 sumbit函数暴力分解二进制。 1234567891011int sumbit(int s){ int sum=0; while(s) { if(s&amp;1) //如果二进制的最后一位是1 sum++; //累加 s&gt;&gt;=1; } return sum;} 2 exmslf函数原理：$a &amp; b=1$表示$a,b$二进制上的某一位同时为$1$。 则当$cur$不满足单行要求时，$cur &amp; (cur&lt;&lt;1)$与$cur &amp; (cur&gt;&gt;1)$里面至少有一者运算结果为$1$。 123bool exmslf(int s){ return !(s&amp;(s&lt;&lt;1)) &amp;&amp; !(s&amp;(s&gt;&gt;1));} 3 exmcpl函数原理同上。 123bool exmcpl(int s1,int s2){ return !(s1&amp;s2) &amp;&amp; !(s1&amp;(s2&lt;&lt;1)) &amp;&amp; !(s1&amp;(s2&gt;&gt;1));} 4 递推123456789101112131415for(int fst=0; fst&lt;(1&lt;&lt;n); fst++) if(exmslf(fst) &amp;&amp; sumbit(fst)&lt;=k) f[1][sumbit(fst)][fst]=1; for(int i=2;i&lt;=n;i++) for(int cur=0; cur&lt;(1&lt;&lt;n); cur++) for(int sum=sumbit(cur);sum&lt;=k;sum++) for(int prv=0; prv&lt;(1&lt;&lt;n); prv++) if(exmslf(cur) &amp;&amp; exmslf(prv) &amp;&amp; exmcpl(cur,prv)) f[i][sum][cur]+=f[i-1][sum-sumbit(cur)][prv];int ans=0; for(int lst=0; lst &lt; (1&lt;&lt;n); lst++) if(exmslf(lst)) ans+=f[n][k][ans];","link":"/2019/02/18/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"矩阵基础","text":"又是一个乱堆一气的文章…索引：矩阵的加减乘运算，矩阵快速幂，矩阵加速线性递推…… 一 基础知识1 概念一个$n\\times m$的数阵被称作矩阵（matrix）。举个栗子，就像下面这样：$$ \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\newline 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $$矩阵可以用大写字母表示，像这样：$$ A = \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\newline 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $$$A_{i,j}$表示矩阵第$i$行第$j$列的元素，如$A_{3,2} = 8$。 主对角线形如$A_{i,i}$的元素所组成的一条矩阵的对角线被称为矩阵的主对角线。 矩阵的阶$n$行$m$列的矩阵被称为$n\\times m$阶矩阵。如上面的$A$矩阵是$4\\times 3$阶矩阵，注意这里的$\\times$符号不表示相乘，就是说$3\\times 4$和$4\\times 3$不是同一个阶数。 2 加减运算两个阶数相同的矩阵可以进行加减法，就像这样：若$ A = \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\end{bmatrix} $，$ B = \\begin{bmatrix} 7&amp;8&amp;9 \\newline 10&amp;11&amp;12 \\end{bmatrix} $则$A+B = \\begin{bmatrix} 1+7 &amp; 2+8 &amp; 3+9 \\newline 4+10 &amp; 5+11 &amp; 6+12 \\end{bmatrix} = \\begin{bmatrix} 8 &amp; 10 &amp; 12 \\newline 14 &amp; 16 &amp; 18 \\end{bmatrix}$$A-B = \\begin{bmatrix} 1-7 &amp; 2-8 &amp; 3-9 \\newline 4-10 &amp; 5-11 &amp; 6-12 \\end{bmatrix} = \\begin{bmatrix} -6 &amp; -6 &amp; -6 \\newline -6 &amp; -6 &amp; -6 \\end{bmatrix}$ 由上也可知，矩阵的加法是满足交换律的。 3 矩阵相乘仅有形如这样的两个矩阵可以进行乘法：$n\\times k$阶矩阵$A$和$k\\times m$阶矩阵$B$。它们的乘积会是一个$n\\times m$阶矩阵。 满足相乘条件的矩阵的乘法原则是：若$C = A\\times B$，则有$C_{i,j} = \\sum\\limits_{u = 1}^k A_{i,u}·B_{u,j}$。一个例子：$$ \\begin{bmatrix} 1&amp;2&amp;3 \\newline 4&amp;5&amp;6 \\end{bmatrix} \\times \\begin{bmatrix} 1&amp;2 \\newline 3&amp;4 \\newline 5&amp;6 \\end{bmatrix} = \\begin{bmatrix} 22 &amp;28 \\newline 49&amp;64 \\end{bmatrix}$$具体的运算细节如下图： 注意：矩阵乘法是不满足交换律的！ 二 矩阵快速幂1 理论快速幂能在较短的时间内求出$a^b$的值，是因为巧妙的把$b$进行了二进制分解并划分了求$a^b$的子问题。 那么对于矩阵而言，可不可以用类似于快速幂的办法快速的求出$n\\times n$阶矩阵$A$的幂次$A^b$的值呢？注意：因为矩阵乘法的限制，只有阶数形如$n\\times n$的矩阵有幂运算。 显然是可以的，这里有一份快速幂代码： 123456789LL QuickPow(LL a,LL b){ LL base = a,rec = 1; while(b){ if(b &amp; 1) rec *= base; base *= base; b &gt;&gt;= 1; } return rec;} 我们把里面的a、base、rec假想成一个矩阵，那么rec *= base、base *= base我们都可以实现。唯一的问题是rec = 1应该怎么定义？ 抛开矩阵，”1”应该满足的条件是：对于任意非零实数$a$，有$a\\times 1 = a$。回到矩阵上来，”1”矩阵$base$应该满足的条件是：对于任意非零矩阵$A$，有$A\\times base = A$。 假如$A$为$n\\times m$阶，那么显然$base$应该是$m\\times m$阶，否则得到的积矩阵不会是$n\\times m$阶的。进一步研究发现：$base$应该是一个主对角线为$1$，其余元素都为$0$的矩阵，像这样：$\\begin{bmatrix} 1&amp;0&amp;0 \\newline 0&amp;1&amp;0 \\newline 0&amp;0&amp;1 \\end{bmatrix}$（当$m = 3$时）。 2 代码于是我们得到矩阵快速幂的代码：模板 1234567891011121314151617181920212223242526272829303132333435#define LL long longconst int CN = 101;const int R = 1e9+7; //结果对 R 取模class matrix{ //定义一个矩阵 public: LL a[CN][CN]; int n,m; //n*m阶 //matrix() {memset(a,0,sizeof(a)); n=m=0;} //matrix(int nn,int mm) {memset(a,0,sizeof(a));n = nn; m = mm;} void MakeOne(){ //构造 &quot;1&quot; 矩阵 for(int i=1;i&lt;=m;i++) a[i][i] = 1; } matrix operator *(const matrix&amp; b)const{ //重定义乘法 // n*m x b.n*b.m =&gt; n*b.m // k = m = b.n matrix rec = (matrix){{{0}},n,b.m}; //乘法运算的答案 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R) %= R; return rec; } void operator *=(const matrix&amp; b) {*this = (*this)*b;} //重定义乘法};//矩阵快速幂matrix MatrixQuickPow(matrix &amp;mr,LL k){ matrix rec = (matrix){{{0}},mr.m,mr.m}; //构造 '1' 矩阵 rec.MakeOne(); //构造 '1' 矩阵 while(k){ //类似于普通的快速幂 if(k &amp; 1) rec *= mr; mr *= mr; k &gt;&gt;= 1; } return mr = rec;} 时间复杂度大概是$O(k \\log_2 b)$，其中$k$是一次矩阵乘法的复杂度，大概是$n^3$级别（$n$是阶数）。 三 矩阵加速线性递推矩阵快速幂可以被用来优化递推。实际上并不是只能优化线性递推，一个非线性递推的例子：请在本站搜索“摆花”。 1 斐波那契数列问题众所周知的斐波那契数列（Fibonacci Sequence），它的递推式是这样的：$f_1 = f_2 = 1,f_i = f_{i-1} + f_{i-2}(i&gt;2)$。 若求$f_i$项的值，朴素的想法是$O(i)$递推。有没有什么$\\log$级别的算法呢？ 我们不妨定义一些矩阵：设矩阵$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$，有没有可能从$F(i-1)$推出$F(i)$呢？ 假设存在矩阵$base$，使$F(i-1)\\times base = F(i)$。不难发现$F(i-1)\\times base^2 = F(i+1)$，于是有一般规律$F(i)\\times base^k= F(i+k)$，即可得$F(2)\\times base^{i-2}= F(i)$。 我们知道$F(2) = \\begin{bmatrix} 1&amp;1 \\end{bmatrix}$，而在式子$F(2)\\times base^{i-2}= F(i)$中，后面的$base^{i-2}$是可以利用矩阵快速幂快速求得的。于是我们有了一种想法：假如知道$base$，我可以在$\\log$级别的时间复杂度里推出$F(i)$，进而推出$f_i$。 $base$所满足的条件是$F(i-1)\\times base = F(i)$，即$\\begin{bmatrix} f_{i-1}&amp;f_{i-2} \\end{bmatrix} \\times base=\\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$。至少$base$应该是一个$2\\times 2$阶的（请注意推广到一般形式，如果$F(i)$是$1\\times n$阶的呢？），否则两矩阵相乘得不到一个$2\\times 2$阶矩阵。 我们知道：$f_{i-1}\\times 1+f_{i-2}\\times 1 = f_i,f_{i-1}\\times 1+f_{i-2}\\times 0 =f_{i-1}$。即：$$F(i-1)\\times \\begin{bmatrix} 1\\newline 1 \\end{bmatrix} = f_i $$ $$ F(i-1)\\times \\begin{bmatrix} 1\\newline 0 \\end{bmatrix} = f_{i-1} $$故有：$F(i-1)\\times \\begin{bmatrix} 1&amp;1\\newline 1&amp;0 \\end{bmatrix} = F(i)$，即$base = \\begin{bmatrix} 1&amp;1\\newline 1&amp;0 \\end{bmatrix}$。 于是利用式子$F(2)\\times base^{i-2}= F(i)$，我们就求出$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$。再求$f_i$就简单不过了。 注意：当递推式不同时，$base$的值是会变的。 代码模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define LL long longconst int CN = 101;const LL R = 1e9+7;class matrix{ //定义矩阵 public: LL a[CN][CN]; int n,m; //matrix() {memset(a,0,sizeof(a)); n=m=0;} //matrix(int nn,int mm) {memset(a,0,sizeof(a));n = nn; m = mm;} void MakeOne(){ for(int i=1;i&lt;=m;i++) a[i][i] = 1; } matrix operator *(const matrix&amp; b)const{ // n*m x b.n*b.m =&gt; n*b.m // k = m = b.n matrix rec = (matrix){{{0}},n,b.m}; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=b.m;k++) (rec.a[i][k] += (a[i][j]*b.a[j][k])%R) %= R; return rec; } void operator *=(const matrix&amp; b) {*this = (*this)*b;}}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 matrix rec = (matrix){{{0}},mr.m,mr.m}; //构造 '1' 矩阵 rec.MakeOne(); //构造 '1' 矩阵 while(k){ if(k &amp; 1) rec *= mr; mr *= mr; k &gt;&gt;= 1; } return rec;}//主求解函数LL f(LL i){ if(i &lt;= 2) return 1; //构造初始矩阵 F = (matrix){{{0}},1,2}; //F(2) F.a[1][1] = 1; F.a[1][2] = 1; //[f2 f1] //构造base base = (matrix){{{0}},2,2}; base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; F *= MatrixQuickPow(base,i-2); return F.a[1][1]; //答案是矩阵第一行(一共只有一行...)第一个元素} 一个很有趣的结论：$ \\text{gcd}(f_a,f_b) = f_{\\text{gcd}(a,b)} $例题：LG P1306 2 推广假如现在不是斐波那契数列，而要求这么一个递推式在第$i$项的值：$f_1=f_2=f_3=1,f_x=f_{x-3}+f_{x-1} (x&gt;3)$，该怎么用矩阵加速呢？ 设矩阵$F(i) = \\begin{bmatrix} f_{i}&amp;f_{i-1}&amp;f_{i-2} \\end{bmatrix}$，则有$F(3) = \\begin{bmatrix} f_1&amp;f_2&amp;f_3 \\end{bmatrix}$。设$F(i)\\times base^k = F(i+k)$，则有$F(i) = F(3)\\times base^{i-3}$。通过上面的方法推导出$base = \\begin{bmatrix} 1&amp;1&amp;0 \\newline 0&amp;0&amp;1 \\newline 1&amp;0&amp;0 \\end{bmatrix}$（请自己手推一遍，按照上面的分别构造$f_i,f_{i-1},f_{i-2}$的方法！）。 然后求出第$i$项的值就是一个矩阵快速幂+矩阵乘法的事了。 代码模板 123456789101112131415161718192021222324#define LL long longconst int CN = 101;const LL R = 1e9+7;class matrix{ //定义矩阵 /*同上省略*/}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 /*同上省略*/}//主求解函数LL f(int i){ if(i &lt;= 3) return 1;//防止快速幂出锅(负数) //构造初始矩阵 F = (matrix){{{0}},1,3}; F.a[1][1] = F.a[1][2] = F.a[1][3] = 1; //构造base base = (matrix){{{0}},3,3}; base.a[1][1] = base.a[1][2] = base.a[2][3] = base.a[3][1] = 1; F *= MatrixQuickPow(base,i-3); return F.a[1][1]; } 3 再推广广义斐波那契数列问题： 广义的斐波那契数列是指形如$f_n=p\\times f_{n-1}+q\\times f_{n-2}$的数列。今给定数列的两系数$p$和$q$，以及数列的最前两项$f_1$和$f_2$，另给出两个整数$n$和$m$，试求数列的第$n$项$f_n$除以$m$的余数。 这个问题其实依然可以矩阵加速。设矩阵$F(i) = \\begin{bmatrix} f_i&amp;f_{i-1} \\end{bmatrix}$，有：$$ F(i-1) \\times \\begin{bmatrix} p\\newline q \\end{bmatrix} = f_i$$ $$ F(i-1) \\times \\begin{bmatrix} 1\\newline 0 \\end{bmatrix} = f_{i-1}$$ 所以就是$ F(i-1) \\times \\begin{bmatrix} p&amp;1\\newline q&amp;0 \\end{bmatrix} = F(i)$。 再套矩阵加速就跟板子一样了。 代码模板 1234567891011121314151617181920212223242526#define LL long longconst int CN = 3;LL R; //对 R 取余class matrix{ //定义矩阵 /*同上省略*/}F,base;matrix MatrixQuickPow(matrix mr,LL k){ //矩阵快速幂 /*同上省略*/}//主求解函数LL f(LL i,LL f1,LL f2,LL p,LL q){ //f_n = p·f_n-1 + q·f_n-2 if(i == 1) return f1; //特判 1 if(i == 2) return f2; //特判 2 //构造初始矩阵 F = (matrix){{{0}},1,2}; //F(2) F.a[1][1] = f2; F.a[1][2] = f1; //[f2 f1] //构造base base = (matrix){{{0}},2,2}; base.a[1][1] = p; base.a[1][2] = 1; base.a[2][1] = q; F *= MatrixQuickPow(base,i-2); return F.a[1][1]; }","link":"/2019/07/30/%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/"},{"title":"线性筛","text":"貌似今天CCF倒闭了，不过还是要把学完的东西写完。感觉数论的好多东西都被我胡乱堆……索引：唯一分解定理与积性函数 + 线性筛素数 + 线性筛因子个数 + 线性筛因子和…… 一 引入1 唯一分解定理唯一分解定理就是说这么一个东西：任意一个自然数都可以被写成若干质数的幂次之积，就像下面这样： $$\\forall n\\in N, n = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $$ 其中$p$是质数，$a_k\\in N$。 根据唯一分解定理将一个整数拆分成若干质数的次幂之积的过程，被称作分解质因数。 2 积性函数对于一个函数$f(x)$，若对任意互质的两数$a,b$，有$f(a\\times b) = f(a)\\times f(b)$，则称$f(x)$为积性函数。例如：欧拉函数$\\varphi(x)$（定义为小于$x$的与$x$互质的数的个数），莫比乌斯函数等都是积性函数。积性函数总是可以通过线性的筛法求得的。 二 线性筛素数1 理论实际上也叫欧拉筛。其实在OI模板中有一份关于筛素数的代码，实际上那个是Eratosthenes筛，这个是$O(n\\log\\log n)$，并不是严格的线性筛法。 欧拉筛的想法是：对于每个合数，只用它的一个质因数（实际上它的是最小质因子）把它筛掉。因此一个合数只会被筛一次，也就保证了严格的线性。 实际的做法是：用一个数$i$和小于$i$的且与$i$互质的所有质数（已经筛出）$\\text{prime}[j]$去筛$i\\times \\text{prime}[j]$。为什么这样做呢？前面说一个数只被它的最小质因子筛掉，而当$i$与$ \\text{prime}[j]$不互质时，假设存在一个比$\\text{prime}[j]$小的质数$\\text{prime}[k]$，那么$i\\times \\text{prime}[k]$一定是$\\text{prime}[j]$的倍数。换言之此时$\\text{prime}[j]$并不一定是$i\\times \\text{prime}[j]$的最小质因子。实际上这个这个结论是总成立的，即此时$\\text{prime}[j]$不是$i\\times \\text{prime}[j]$的最小质因子。因此只需枚举到$\\text{prime}[j]$与$i$不互质就好了。 具体的做法请见代码。 2 代码123456789101112131415161718const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN]; //标记一个数字不是素数//线性筛素数not_prime[1] = true;for(int i=2;i&lt;=n;i++){ if(!not_prime[i]) prime[++prime[0]] = i; //记录素数 for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ not_prime[i*prime[j]] = true; //筛，prime[j] 总是 i 的最小质因子 if(!(i % prime[j])) break; //欧拉筛之所以线性之处 /* i mod prime[i] = 0, 即 prime[j] 是 i 的质因子 也就说明对于其它的质数 prime[k], i*prime[k] 总会是 prime[j] 的倍数 那么就不需要继续用 prime[j] 继续往下筛了 */ }} 三 线性筛因子个数1 理论我们用$d(x)$表示$x$的因子个数。$d()$函数也是积性函数，因此可以线性筛。 若将$x$分解质因子，得$x = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $。每个质因子$p_i$可以产生$a_i+1$种不同的因子，即$p_i^0,p_i^1,…,p_i^{a_i}$。而任意若干上述“不同的因子”相乘又会得到新的因子，因此$x$共有$(a_1+1)·(a_2+1)·…·(a_k+1)$个因子，即$d(x) = (a_1+1)(a_2+1)…(a_k+1)$。 实际上可以表示成$d(x) = \\prod\\limits_{i=1}^k a_i+1$。 然后考虑如何线性筛。对于上面的欧拉筛代码，考虑在筛$i\\times \\text{prime}[j]$时求出$d(i\\times \\text{prime}[j])$。可以分类讨论： 若$i$与$\\text{prime}[j]$互质，则根据积性函数的定义可得$d(i\\times \\text{prime}[j]) = d(i)\\times d(\\text{prime}[j])$。 若$i$与$\\text{prime}[j]$不互质，首先$\\text{prime}[j]$一定是$i$的最小质因子，则根据$i = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k} $，可知$\\text{prime}[j]$会是质因数分解里面最小的那个质因子，也就是$p_1$。于是得$i\\times \\text{prime}[j] = i·p_1 = p_1^{a_1+1}\\times p_2^{a_2}\\times …\\times p_k^{a_k}$。原来的$d(i) = (a_1+1)(a_2+1)…(a_k+1)$，现在变成了$d(i) \\times \\text{prime}[j] = (a_1+2)(a_2+1)…(a_k+1)$，于是可知$d(i\\times \\text{prime}[j]) = d(i)/(a_1+1) \\times(a_1+2) $。这个最小质因子的指数$a_1$可以记录下来，设它是$m_i$，则有$d(i\\times \\text{prime}[j]) = d(i)/(m_i+1) \\times (m_i+2) $。 这个$m_i$也是可以线性推广到$m_{i\\times \\text{prime}[j]}$的。对于情况一，既然$\\text{prime}[j]$是$i\\times \\text{prime}[j]$的最小质因子，且又只乘了一个$\\text{prime}[j]$，显然有$m_{i\\times \\text{prime}[j]} = 1$；而对于情况二，从$i$变成$i\\times \\text{prime}[j]$，实际上是最小质因子又被乘了一遍，即它的指数又被加上了$1$，所以有$m_{i\\times \\text{prime}[j]} = m_i+1$。 于是我们就找到了一种线性筛因子个数的方法。 2 代码123456789101112131415161718192021222324252627const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN];int d[CN],mi[CN]; //mi[x] 记录 x 的质因数分解中最小的质因子的指数//线性筛因子个数d()not_prime[1] = true;d[1] = 1; mi[1] = 0; // 1 仅有 1 个因子，质因数分解为任意负数的零次方for(int i=2;i&lt;=n;i++){ if(!not_prime[i]){ //记录素数 prime[++prime[0]] = i; d[i] = 2; mi[i] = 1; //素数仅有两个因子，质因数分解为自身的一次方 } for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ /*prime[j] 一定是 i*prime[j] 的最小质因子*/ not_prime[i*prime[j]] = true; if(i % prime[j]){ //互质时，根据积性函数的特性推出 d[i*prime[j]] = d[i]*d[prime[j]]; mi[i*prime[j]] = 1; } else{ //不互质 d[i*prime[j]] = d[i]/(mi[i]+1) * (mi[i]+2); mi[i*prime[j]] = mi[i]+1; break; } }} 四 线性筛因子和1 理论设$D(x)$表示$x$的所有因子之和。$D()$函数同样是积性函数，可以进行线性筛。 同样，先推通项公式（貌似也可以叫它解析式…）。把$x$分解质因数，得$x = p_1^{a_1}\\times p_2^{a_2}\\times …\\times p_k^{a_k}$。$x$的所有因子应该是什么呢？同上所述，所有的形如$p_i^j (j\\in [0,a_i],i\\in [1,k])$的数都可以作为$x$的因子，但是这并不是全部。实际上，在其中任取若干个数$p_{i1}^{j1},p_{i2}^{j2},…$相乘，所得的积也会是$x$的一个因子。因此把所有可能的因子分组并根据乘法原理相乘，就得到$D(x) = (1+p_1^1+p_1^2+…+p_1^{a_1})(1+p_2^1+p_2^2+…+p_2^{a_2})…(1+p_k^1+p_k^2+…+p_k^{a_k})$。 也就是$D(x) = \\prod\\limits_{i=1}^k \\sum\\limits_{j=0}^{a_i} p_i^j$。 然后再考虑线性筛。设$\\text{prime}[j]$是$i$的最小质因子，枚举$i$，考虑$O(1)$推出$D(i\\times \\text{prime}[j])$。首先$\\text{prime}[j]$与$i$互质时显然可以直接相乘得到，不再多说。 不互质呢？观察$D(i)$和$D(i\\times \\text{prime}[j])$的通项表达式有什么区别？实际上是$D(i\\times \\text{prime}[j]) = D(i)/(1+p_1^1+p_1^2+…+p_1^{a_1}) \\times (1+p_1^1+p_1^2+…+p_1^{a_1+1})$。同样把后面的那个东西设作$w_i$，得到$D(i\\times \\text{prime}[j]) = D(i)/w_i \\times w_{i\\times \\text{prime}[j]}$。 此时实际上$w_{i\\times \\text{prime}[j]} = w_{i}\\times \\text{prime}[j] +1$；而对于互质的情况，有$w_{i\\times \\text{prime}[j]} = \\text{prime}[j] +1$。 因此我们找到了一种线性筛因子和的方法。 2 代码123456789101112131415161718192021222324252627const int CN = 1e7+7;int n,m;int prime[CN]; bool not_prime[CN];int D[CN],w[CN];//线性筛因子和D()not_prime[1] = true;D[1] = 1; w[1] = 1; for(int i=2;i&lt;=n;i++){ if(!not_prime[i]){ //记录素数 prime[++prime[0]] = i; D[i] = i+1; w[i] = i+1; //两个因子: 自身(i) + 1 } for(int j=1;j&lt;=prime[0] &amp;&amp; i*prime[j]&lt;=n;j++){ /*prime[j] 一定是 i*prime[j] 的最小质因子*/ not_prime[i*prime[j]] = true; if(i % prime[j]){ //互质时，根据积性函数的特性推出 D[i*prime[j]] = D[i]*D[prime[j]]; w[i*prime[j]] = prime[j]+1; //即最小质因子的零次方和一次方 } else{ //不互质 D[i*prime[j]] = D[i]/w[i] * (w[i]*prime[j]+1); w[i*prime[j]] = w[i]*prime[j]+1; break; } }}","link":"/2019/08/16/%E7%BA%BF%E6%80%A7%E7%AD%9B/"},{"title":"组合数学再基础","text":"之前好像写过「组合数学基础」，在这里再来堆点柿子。 此页面存在相关页面。关于组合数学基础，请参见「组合数学基础」。 1 Stirling 数1.1 定义众所周知，Stirling 数有两类，分别是： $$ \\begin{align} \\begin{bmatrix}n\\newline m \\end{bmatrix} = \\begin{bmatrix}n-1\\newline m-1 \\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\newline m \\end{bmatrix} \\newline \\begin{Bmatrix}n\\newline m \\end{Bmatrix}=\\begin{Bmatrix}n-1\\newline m-1\\end{Bmatrix}+m \\begin{Bmatrix}n-1\\newline m \\end{Bmatrix} \\end{align} \\tag1 $$ 其中 $n,m\\in \\mathbb N$，它们的边界均是 $S(0,0)=S(1,1)=1,S(1,0)=0$。 接下来介绍 Stirling 数的性质。 1.2 常幂展开一个组合意义显然的柿子： $$ \\begin{align} n^m &amp;= \\sum\\limits_{k=0}^m \\begin{Bmatrix}m\\newline k \\end{Bmatrix}k! \\dbinom{n}{k} \\tag2 \\newline &amp;= \\sum\\limits_{k=0}^m \\begin{Bmatrix}m\\newline k\\end{Bmatrix} n^{\\underline{k}} \\tag{3} \\end{align} $$ 其中 $n,m\\in\\mathbb N$，$(3)$ 式通常被称为 常幂展开。 1.3 Stirling 反演$$ f(n) = \\sum\\limits_{k=0}^n \\begin{Bmatrix}n\\newline k\\end{Bmatrix} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^{n - k} \\begin{bmatrix}n\\newline k\\end{bmatrix} f(k) \\tag{4} $$ 其中 $n\\in \\mathbb N$，$(4)$ 式通常被称为 Stirling 反演公式。 1.4 阶乘幂展开对 $(3)$ 应用 $(4)$ 式得： $$ n^{\\underline m}= \\sum\\limits_{k=0}^m (-1)^{m-k} \\begin{bmatrix}m\\newline k\\end{bmatrix} n^k \\tag{5} $$ 可以证明有： $$ n^{\\overline m}= \\sum\\limits_{k=0}^m \\begin{bmatrix}m\\newline k\\end{bmatrix} n^k \\tag{6} $$ 其中 $n,m\\in\\mathbb N$，$(5),(6)$ 两式被称作阶乘幂展开。 2 组合数2.1 定义 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但是这跟本文的主题并没有什么关系。 小葱同学擅长计算的组合数定义为： $$\\dbinom{n}{m}=\\begin{cases} 0, \\text{ }m&gt;n\\text{ or }m&lt;0\\newline \\dfrac{n^{\\underline m}}{m!},\\text{ otherwise} \\end{cases}$$ 其中 $n\\in \\mathbb R,m\\in \\mathbb Z$。当 $n,m$ 均是非负整数且 $m\\le n$ 时，它满足递推式： $$\\dbinom{n}{m} = \\dbinom{n-1}{m} + \\dbinom{n-1}{m-1}$$ 2.2 二项式定理$$(x+y)^k = \\sum\\limits_i \\dbinom{k}{i} x^i y^{k-i} \\tag{7}$$ 其中 $k\\in \\mathbb R$，$(7)$ 式被称作二项式定理。 2.3 组合恒等式组合恒等式 I在 $(7)$ 式中令 $x=y=1$ ，得： $$\\sum\\limits_i \\dbinom{k}{i} = 2^k \\tag{8}$$ 其中 $k\\in \\mathbb R$。 组合恒等式 II$$\\sum\\limits_i \\dbinom{k}{i}[2|i] =\\sum\\limits_i \\dbinom{k}{i}[2\\nmid i] = 2^{k-1} \\tag9$$ 其中 $k\\in \\mathbb R$，证明显然。 组合恒等式 III$$\\dbinom{n}{k}\\dbinom{k}{j} = \\dbinom{n}{j} \\dbinom{n-j}{k-j} \\tag{10}$$ 其中 $n,k,j\\in \\mathbb Z$，证明显然。 吸收公式$$ \\begin{align} \\dfrac{n}{m}\\dbinom{n-1}{m-1}&amp;=\\dbinom{n}{m}\\tag {11}\\newline \\newline (n-m)\\dbinom{n}{m}&amp;=n\\dbinom{n-1}{m}\\tag {12}\\end{align} $$ 其中 $n,m\\in \\mathbb Z$，证明显然。$(11),(12)$ 式被称作吸收公式。 范德蒙德卷积$$ \\sum\\limits_i \\dbinom{A}{i}\\dbinom{B}{C-i}=\\dbinom{A+B}{C} \\tag{13}$$ 其中 $A,B,C\\in\\mathbb N$，$(13)$ 式被称作范德蒙德卷积。注意它可以简单推广到多元形式。 上指标求和$$\\begin{align} \\sum\\limits_{i=m}^n \\dbinom{i}{m} &amp;= \\dbinom{n+1}{m+1} \\tag{14} \\newline\\sum\\limits_{i=0}^n \\dbinom{m+i}{i} &amp;= \\dbinom{n+m+1}{n} \\tag{15} \\end{align}$$ 其中 $n,m\\in\\mathbb N$，证明显然。$(14),(15)$ 式被称作上指标求和公式，$(15)$ 式又被称作平行求和公式。 上指标反转$$\\begin{align} \\dbinom{n}{m}&amp;=(-1)^m \\dbinom{m-n-1}{m} \\tag {16}\\newline \\dbinom{-1}{m}&amp;=(-1)^m\\dbinom{m}{m}=(-1)^m \\tag {17}\\end{align}$$ 其中 $n,m\\in\\mathbb Z$。证明只需要考虑把 $-1$ 的系数均摊到分子下降幂上。$(16)$ 式被称作上指标反转，$(17)$ 式是 $(16)$ 式对于 $n=-1$ 的特殊情况。 $(8)\\text{~}(17)$ 式通常被称作组合恒等式。 2.4 二项式反演形式 I$$ f(n) = \\sum\\limits_{k=0}^n (-1)^k\\dbinom{n}{k} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k} f(k) \\tag{18} $$ 形式 II$$ f(n) = \\sum\\limits_{k=0}^n\\dbinom{n}{k} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=0}^n (-1)^{n-k} \\dbinom{n}{k} f(k) \\tag{19} $$ 形式 III$$ f(n) = \\sum\\limits_{k=n}^m\\dbinom{k}{n} g(k) \\Leftrightarrow g(n) = \\sum\\limits_{k=n}^m (-1)^{k-n} \\dbinom{k}{n} f(k) \\tag{20} $$ 其中 $n,m\\in\\mathbb N$，$(18),(19),(20)$ 式被称作二项式反演公式。 2.5 第二类 Stirling 数通项对 $(2)$ 式应用 $(19)$ 式得： $$ \\begin{Bmatrix}n\\newline m \\end{Bmatrix}m! = \\sum\\limits_{k=0}^m (-1)^k \\dbinom{m}{k} (m-k)^n \\tag{21} $$ 其中 $n,m\\in\\mathbb N$，$(21)$ 式被称为第二类 Stirling 数通项公式。 3 相关题目「bzoj2839」集合计数「bzoj3622」已经没有什么好害怕的了「CF932E」 Team Work「2018 雅礼集训」方阵「TJOI / HEOI2016」求和「LOJ #6716.」 自然数幂之和「2020联考A卷」组合数问题「各种数数题」…","link":"/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/"},{"title":"组合数学基础","text":"此页面存在相关页面。关于反演与组合恒等式，请参见「组合数学再基础」。 排列组合 + 二项式定理 + 卢卡斯（lucas）定理…… 一 排列组合1 概念从$n$个不同元素中取$m(m\\leqslant n)$个形成一个排列，所得到的排列的总数被称作排列数，记作$A_n^m$。从$n$个不同元素中取$m(m\\leqslant n)$个形成一个集合，所得到的集合的个数被称作组合数，记作$C_n^m$。 2 公式通项公式$$ A_n^m = \\dfrac{n!}{(n-m)!} $$$$ C_n^m = \\dfrac{n!}{m!(n-m)!} $$ 推导式$$C_n^m = \\dfrac{A_n^m}{m!}$$ 递推式$$ C_n^m = C_{n-1}^m+C_{n-1}^{m-1} $$ 对称性$$ C_n^m = C_n^{n-m} $$组合数具有对称性。假设你现在有一张$C_1^1\\text{~} C_n^m$的组合数表，那么这张表的第$i$横行应该是以$i/2$为轴呈左右对称的。 二 二项式定理其实组合数、杨辉三角、二项式定理都可以看成一个东西…… 二项式定理用于求$(x+y)^n$的展开式。定理的内容如下（公式表示）：$$ (x+y)^n = \\sum\\limits_{k=0}^n C_n^kx^ky^{n-k} $$ 有一个比较有意思的地方：当$p$是素数时，$ (x+y)^p \\equiv x^p+y^p (\\text{mod }p)$。 因为$ \\sum\\limits_{k=0}^p C_p^kx^ky^{p-k} $可以拆成$x^p+y^p + \\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}$，后面的$\\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}$中，每一项都有一个$C_p^k(k\\in [1,p-1] )$。用通项公式，那么$C_p^k$可以变成$\\dfrac{p!}{k!(p-k)!}$，分子部分的$p!$含有$p$这一项，故$p!\\equiv 0 (\\text{mod }p)$；同时$p$这一项不会被约分掉（因为$p$是质数），故$\\dfrac{p!}{k!(p-k)!}\\equiv 0 (\\text{mod }p)$，故$C_p^k\\equiv 0 (\\text{mod }p,k\\in [1,p-1])$，故$\\sum\\limits_{k=1}^{p-1} C_p^kx^ky^{p-k}\\equiv 0 (\\text{mod }p)$，故得证。 三 卢卡斯定理1 理论卢卡斯（lucas）定理用来求$ C_n^m \\text{ mod } p$的值，其中$p$为素数。题外话：当$p$不是素数的时候要用扩展卢卡斯（ex-lucas），貌似还要用CRT，真是吓死我了…… 定理的内容：$$ C_n^m \\text{ mod } p = (C_{n \\text{ mod } p}^{m \\text{ mod } p}\\times C_{\\lfloor n/p\\rfloor}^{\\lfloor m/p\\rfloor}) \\text{ mod } p $$ 根据乘法取余的运算原则，可以拆出$C_{\\lfloor n/p\\rfloor}^{\\lfloor m/p\\rfloor} \\text{ mod } p$这一项。这个可以继续用lucas递归求。 剩下部分是$C_{n \\text{ mod } p}^{m \\text{ mod } p}\\text{ mod } p$，可知$n,m$都不会超过或等于$p$，那么尝试暴力求。 当$p$一定时，显然可以打一个阶乘取余的表，不再多说。如果不打表，用通项公式求的极限复杂度大约是$O(p)$（忽略了常数），实际上可以再优化一下常数。当组合数有意义（即$m\\leqslant n$）时，$n!$中实际上包含了$m!$。于是通项公式可以变形为：$$C_{n}^{m} \\text{ mod } p = \\dfrac{n(n-1)(n-2)…(m+1)}{(n-m)!} \\text{ mod } p $$这个式子涉及到除法的取余，所以需要引入$(n-m)!$在模$p$意义下的逆元$\\text{inv}[(n-m)!]$。$p$是个质数，用费马小定理就好了。最终变形为：$$C_{n}^{m} \\text{ mod } p =n(n-1)(n-2)…(m+1)·\\text{inv}[(n-m)!] \\text{ mod } p $$ 然后根据组合数的对称性，$ C_n^m = C_n^{n-m} $，那么我们在$m,n-m$挑一个小的代入式子求组合数就好了。极限复杂度大概是严格的$O(p)$。 考虑到多组数据的话，该算法适用数据范围大约是$p\\leqslant 10^5$。 2 代码模板 12345678910111213141516171819202122232425262728#define LL long longLL QuickPow(LL a,LL b,LL r){ //快速幂取余 LL base = a%r,rec = 1; while(b){ if(b &amp; 1) (rec *= base) %= r; (base *= base) %= r; b &gt;&gt;= 1; } return rec % r;}int C(int n,int m,int p){ //计算组合数 if(m &gt; n) return 0; if(m &gt; n-m) m = n-m; //这里用到对称性 LL s1 = 1,s2 = 1; for(int k=m+1;k&lt;=n;k++) (s1 *= k) %= p; for(int k=2;k&lt;=n-m;k++) (s2 *= k) %= p; LL inv = QuickPow(s2,p-2,p); //求逆元 return (s1*inv) % p;}int lucas(int n,int m,int p){ //主求解函数，返回C(n,m) mod p的值 if(!m) return 1; //边界 return (C(n%p,m%p,p)*lucas(n/p,m/p,p)) % p;} 时间复杂度大概是$O(t·p\\log_pn)$，$t$是数据组数。","link":"/2019/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"title":"终点","text":"在联合省选 Day2 爆炸，爬去卷了三个月的 whk 之后，我终于还是以 D 类的身份去了 NOI2021。 在这样一个宁静的夜晚，我得以平静下来去记录一下这场本应决定我的命运的比赛，同时也记录一下我几年来所走过的漫漫 OI 长路… 头图取自西北某高校在 NOI2021 做宣讲时的课件。 var ap = new APlayer({ element: document.getElementById(\"aplayer-aKrGfhAS\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"ニリンソウ\", author: \"Key Sounds Label\", url: \"/pictures/bgm2.mp3\", pic: \"/pictures/bgm2.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 7 月的第 1 周，期末考试结束，我的高二一年正式迎来终结。狂卷三个月之后，期末最终取得了年级 rk40+ 的成绩，还算说得过去，但是跟高一时曾经达到的水平比，已经不知道差到哪里去了。 然后是四天的放假，基本上是颓了整整四天，OI 一点没碰。而此时距离报到日仅有不到一周了，我甚至连 NOI Linux 都不会用… 7.19 返校，此时终于开始停课复健训练，唯一的感受是啥也不会，不仅新学的东西基本全忘了，而且码力下降也很大。于是选择了重点练码力（flag），毕竟省选吃过大亏（D2T1 gem）。 然后来到了喜闻乐见的报到日（7.23）。因为某些众所周知的原因，行程突然变化，导致到余姚的时候已经晚上八点多了，而且雨还下的很大。去报到处领了衣服和胸牌，再去找宿舍，全身都 tm 淋得湿透透的… 7.24 是理论报到日，但是并没有事情做。由于我是老年退役选手，所以我选择躺平，于是颓了一上午的 MC…下午突然通知考笔试，然后好几道题不在题库里面，于是因为某些 zz 原因扣了 1pt。出来发现 sls 已经阿克了，然后同宿舍的高一队爷 fqt 因为丢失密码条扣几分的那道题扣了一分… “丢失密码条扣五分，不知道‘丢失密码条扣五分’扣一分” 7.25 理论开幕式，因为台风直接取消了，在宿舍颓了一天的 MC。 Day 1 / 7.26第一天考试，因为台风的原因晚开考了一个小时。 9:00 准时开题，T1 是个数据结构，果然练码力是对的。读完发现这是个经典模型，处理方法大概就是把树重链剖分，然后重边的状态可以简单地用线段树维护，轻边的状态只需要在父亲和儿子节点分别打修改时间戳，然后就可以做到 $O(n\\log^2n)$。马上开写，写了一个半小时终于写好了，发现第二个大样例死活过不了。果断写拍，搞到 11:20 的时候终于拍上了，测一发大样例全部过掉。 然后开 T2，发现是个计数，于是就觉得不会做。去读 T3，发现又是一个有向图上加边乱搞的问题。因为省选在这上面吃过亏，于是直接打了两个题的最低档暴力走人。 还剩不到一个小时，发现 T1 的最大的大样例很水，自己随了几组大数据发现跑到了 1.5s 左右。于是大力卡常，卡到了 1.3s 左右，还是觉的不稳。 出场发现一堆人 AK 了，然后人均切 T2，觉得自己药丸。但是 D 类没有什么完不完的，心态瞬间平和了。 下午出分，T1 卡过了，100+20+28=148。 晚上听讲题，T2 是个伪数数 / 真行列式定义题，人傻了。T3 好像也不是那么难，果然老年退役选手只会打暴力，还打的很慢。。。 7.27 没有什么事，接着在宿舍颓 MC，下午的嘉年华也没有去，好耶。 Day 2 / 7.288:00 准时开考。 先花 1h 读完题，发现什么也不会。T3 的部分分做法好像已经在样例解释中写出来了，于是决定倒开。发现算方案的时候有 $2^4$ 种情况，于是大力分讨，到最后花 1.5h 才调出来这个容斥。。+=20pts T2 是个连分数，我还在《具体数学》上读到过，但是那一节我觉得没用就没仔细看。。好家伙，基础不牢的报应来了。想了想就算是计算答案都没法快速处理，直接打完 $O(n^2)$ 暴力走人。 T1 一看就是个乱搞题，可以我不擅长乱搞，但是 苏松松 特别擅长淦翻这种题，觉得我要完了。用四个 long long 手动实现了一个 bitset，写了个 $O(n^2/8)/O(256m\\log n)$ 的数据分治（后面是 k=1），卡常发现第一个大数据跑到 13s，觉得没戏。 这时候就差不多结束了。我的 OI 生涯的最后几秒是盯着大屏幕上的时间度过的。 下午出分发现 T1 的 k=1 貌似写挂了，其他还好，于是 24+20+20=64。发现同宿舍一车 80+ 的，觉得我要完了。 然后讲题，由于某些众所周知的原因只讲了 T1 和 T3，发现 T1 是比较简单分块乱搞，觉得我真的老了。 然后高校宣讲，不过和我这个老年退役夏令营选手并没有什么关系。 晚上出分了，99+100+20+28+24+20+20=311，擦线上了 Ag 线。好家伙，现在暴力都能 Ag 了，SD 有朝一日也终于卷到了进队比拿 Ag 难的一天。 同宿舍的 fqt 比我高四分，高一就拿到了银牌，祝贺他。 hehezhou 705pts 成功 AK NOI 捧杯，tql，膜拜。 第二天闭幕式，因为要返程所以没去。 回头想一想，我的 OI 生涯也就如此结束了。 向前看，曾经 lcr，yym，hyd 如愿或未能如愿走过的路，我今天也走到这一步了。回顾这段旅程，我不认为有遗憾了。 向后看，下一届 dysy 的 hws，dyx，还有 OI 路上认识的神峰，神 qyc，都是 SD 的希望，祝他们有光明的前途。 今天我在这里正式退役了，成为了时代的眼泪。但是我的路并没有走完。面对 11 个月之后的高考，我仍旧要踏上征程。只愿那时，我不要再出现失误。 再见了，OI，你好，whk！","link":"/2021/07/29/%E7%BB%88%E7%82%B9/"},{"title":"网络最大流","text":"此页面存在相关页面。关于费用流，请参见「最小费用最大流」。 任意一条网络流边可以描述为$x=(u,v,cap,flow)$。其中$u$为边的起点，$v$为边的终点，$cap$为流量限制，$flow$为当前流量…… 网络流简介 （来自OI Wiki） 一 基础内容任意一条网络流边可以描述为$x=(u,v,cap,flow)$。其中$u$为边的起点，$v$为边的终点，$cap$为流量限制，$flow$为当前流量。 反向边：对于任意一条有向边$e=(i,j,cap,flow)$，定义$e’=(j,i,0,-flow)$ 为它的反向边。注意，反向边在网络流图中是不真实存在的，它其实是一个反悔机制，因此它的流量限制为$0$。定义反向边的当前流量与其对应的正向边的当前流量互为相反数。 反向边图解，图片来自网络：图中，选择$u\\to v$和$p\\to v\\to u\\to q$两条增广路径，实际上等同于选择$u\\to q$和$p\\to v$两条增广路径。因为路径$u\\to v$和它的反向边$v\\to u$的流量之和总为$0$，同时被选中，则意味着这条边对实际流量其实是没有贡献的（这两条边的贡献等于流量之和，等于$0$）。实际上就变成了这两条边同时不被选中。 残量网络：对于图上的任意一条边（包括反向边），定义它们的流量限制与当前流量之差为其残量。一张网络流图上所有边的残量构成残量网络。 增广路：一条从原点（$s$）到汇点（$t$）的路径，并且这条路径上每条边（包括反向边）的残量均大于$0$。设$f_i$为这条路上最小的残量，那么这条增广路可以使得当前流量增加$f_i$。 增广路定理：一张网络流图的流量达到最大流当且仅当残量网络中不存在增广路。 最大流最小割定理：一张网络流图的最大流永远等于该图的最小割的总容量（蒟蒻的我不会证明）。对于割的定义，可以参考割点。 二 Edmond Karp算法1 流程于是我们可以得出最朴素的最大流算法（Edmond Karp，EK算法）。 从原点开始，每次找一条到汇点的增广路径，并进行一次增广。 从原点出发向汇点搜索，设$m_i$为$s\\to i$这条路上的最小残量$i$，$cap_e$为当前入边（$e$）的流量限制，$flow_e$为当前入边的当前流量，可以得到递推式如下：$$ m_i = \\min m_j,cap_e-flow_e | e=(j,i),e \\in E $$ 每次到达汇点，将答案增广$m_t$，一直到残量网络中不存在增广路。于是就可以达到最大流。 注意反向边的储存。边表存图时，定义正向边编号为偶数，它的下一条边就是它的反向边。编号从$0$开始，则$i \\text{xor} 1$总为$i$的对应边（正向边对应到反向，反向边对应到正向）。 2 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int from,to; //起点，终点 int cap,flow; //cap容量上限，flow当前流量量 void init(int f,int t,int c,int fl){ from=f; to=t; cap=c; flow=fl; }}E[CE];vector&lt;int&gt; cde[CP]; //节点i的第j条边在E中的序号int ecnt=0;void add(int f,int t,int c){ E[ecnt].init(f,t,c,0); E[++ecnt].init(t,f,0,0); //反向边 ++ecnt; cde[f].push_back(ecnt-2); cde[t].push_back(ecnt-1); //反向边}int n,m,s,t;//edmonds karp int imp[CP]; //从起点出发的最小残量int p[CP]; //搜索树上进入节点的边的编号 int Augment(int s,int t){ memset(imp,0,sizeof(imp)); queue&lt;int&gt;Q; Q.push(s); imp[s]=INF; while(!Q.empty()) { int cur=Q.front(); Q.pop(); for(int k=0; k&lt;cde[cur].size(); k++) //遍历边表 { fs e=E[ cde[cur][k] ]; if(!imp[e.to] &amp;&amp; e.cap &gt; e.flow) { p[e.to]=cde[cur][k]; imp[e.to] = min(imp[cur], e.cap-e.flow); //满足比起点的残量小 Q.push(e.to); } } } return imp[t];}int ek(int s,int t){ int maxf=0; int aug=0; while(aug=Augment(s,t)) //增广到无法增广为止 { for(int cur=t; cur!=s; cur=E[p[cur]].from) //倒着搜索图 { E[p[cur]].flow += aug; E[p[cur]^1].flow -= aug; //反向边 } maxf+=aug; } return maxf;}int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,c; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;c); add(x,y,c); } printf(&quot;%d&quot;,ek(s,t)); return 0;} 三 Dinic算法在稠密图中，dinic算法的复杂度要比EK高到不知道哪里去了。 1 思想dinic的主要思想是把一张网络流图分层，每次只往更深一层寻找增广路，以避免在同一层中绕圈子（这多半是无意义的）。每当分层图中找不到增广路，这意味着当前图中至少有一条边的流量已经达到限制。也就是说这条边“断了”。而一条断了的边会改变图的分层情况，所以这时重新分层，并继续寻找增广路。直到图上找不到一条$s\\to t$的可行路径。也就是说所有道路都断了。此时会在图上会表现为找不到汇点的所在层级，因为根本没有到达汇点。说的更透彻一点，此时实际上是最小割被完全切断（最大流最小割定理）。 使用bfs完成图的分层，利用dfs寻找增广路径。 2 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int to,nxt; //终点和下一条边的编号 int cap,flow; //cap限制，flow当前流 fs() {cap=flow=to=0; nxt=-1;} //初始化为-1，因为边的下标从0开始 void init(int t,int n,int c,int f){ to=t; nxt=n; cap=c; flow=f; }}E[CE];int hd[CP],ecnt;void E_init(){ memset(hd,-1,sizeof(hd)); ecnt=0;}void _add(int x,int y,int z){ E[ecnt].init(y,hd[x],z,0); hd[x]=ecnt++;}void add(int x,int y,int z){ _add(x,y,z); _add(y,x,0); //反向建边}//variable defineint n,m,s,t;//dinicint dep[CP]; //节点深度bool build(int s,int t) //bfs{ memset(dep,0,sizeof(dep)); //首先清零 dep[s]=1; //原点深度为1 queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) //广搜 { int u=Q.front(); Q.pop(); for(int k=hd[u]; k!=-1; k=E[k].nxt) //遍历边表 { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; !dep[e.to]) //当前边没有断，且终点没被分层 { Q.push(e.to); dep[e.to]=dep[u]+1; //那么就给终点分层 } } } return dep[t]&gt;0; //判断汇点的深度是不是初始值}int Augment(int u,int t,int rst) //dfs :u 节点编号，rst 找到的最小残量{ if(u == t) //已经到了汇点 return rst; //直接返回找到的最小残量 for(int k=hd[u]; k!=-1; k=E[k].nxt) //遍历边表 { fs e=E[k]; if(e.cap-e.flow&gt;0 &amp;&amp; dep[u]==dep[e.to]-1) //还有残量，并且在下一层 { int f=Augment(e.to,t, min(rst, e.cap-e.flow)/*从两个残量里面选一个小的*/); if(f) //能增广则增广，因为反向边保留了退路 { E[k].flow+=f; E[k^1].flow-=f; //反向边 return f; //继续向上层递归返回增广量 } } } return 0; //增广失败}int dinic(){ int max_flow=0,f; while(build(s,t)) //直到所有路径被切断 while(f=Augment(s,t,INF)) //直到不能增广（此处赋值语句兼用作判断真值），注意这里最小残量的初始值 max_flow+=f; //加上增广得到的解 return max_flow;}int main(){ E_init(); scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); } printf(&quot;%d&quot;,dinic()); return 0;} 3 优化3-1 多路增广上文中的代码一次搜索仅找出一条增广路，这样可能会在搜索时走很多重复的道路，造成一些常数负担。 所以每次在一条路上增广时，同时寻找多条增广路，直到干路的最小残量被用完或到达汇点时为止。这样可以避免重复走一条干路。也就是说，一次dfs搜索所有的增广路。 3-2 当前弧优化多路增广后，一条仍有残量却已经被增广的边是不可能继续被增广的，因为它所有的增广可能性已经被全部枚举了。所以继续dfs时，不需要再考虑这些边。所以设$cur_i$为新的边表表头，即以$i$为起点且没有被增广过的第一条边的编号，每次增广后更新$cur_i$即可。注意，每次重新构造分层图后，$cur_i$需复原，因为此时对于 任意一条边 的 任意一种增广可能性 都没有考虑。 3-3 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int CP=1e4+4;const int CE=2e5+5;const int INF=0x7f7f7f3f;//边表class fs{ public: int to,nxt,cap,flow; fs() {to=cap=flow=0; nxt=-1;} void init(int t,int n,int c,int f){ to=t; nxt=n; cap=c; flow=f; }}E[CE];int hd[CP],ecnt=0;int cur[CP]; //当前弧优化，用来保存从i出发未增广的第一条边在边表中的下标void E_init(){ memset(hd,-1,sizeof(hd)); ecnt=0;}void _add(int x,int y,int z){ E[ecnt].init(y,hd[x],z,0); hd[x]=ecnt++;}void add(int x,int y,int z){ _add(x,y,z); _add(y,x,0); //反向边}//variable defineint n,m,s,t;void copy(int* a,int* b,int lenth){ //复制a[]到b[]中 for(int i=0;i&lt;=lenth;i++) b[i]=a[i];}//dinicint dep[CP];bool build(int s,int t) //构造分层图{ memset(dep,0,sizeof(dep)); dep[s]=1; queue&lt;int&gt;Q; Q.push(s); while(!Q.empty()) { int u=Q.front(); Q.pop(); for(int k=hd[u]; k!=-1; k=E[k].nxt) { fs e=E[k]; if(!dep[e.to] &amp;&amp; e.cap-e.flow&gt;0) { dep[e.to]=dep[u]+1; Q.push(e.to); } } } return dep[t]&gt;0;}int Augment(int u,int t,int rst) //多路增广{ if(u == t) //到达汇点 return rst; //返回最小残量 int used=0; //已经得到的增广量 for(int k=cur[u]; k!=-1; k=E[k].nxt) //当前弧优化 { cur[u]=k; //重新记录第一条边，赋值为k是因为这条边目前为止还未增广 fs e=E[k]; if(dep[e.to]==dep[u]+1 &amp;&amp; e.cap-e.flow&gt;0) { int f=Augment(e.to,t, min(rst-used, e.cap-e.flow)); if(f) { used+=f; //累加增广量 E[k].flow+=f; E[k^1].flow-=f; if(used == rst) //增广路的残量用完了 return used; //返回增广量 } } } return used; //搜索完毕，返回增广量}int dinic(){ int max_flow=0; while(build(s,t)) { copy(hd,cur,n); //复制cur的初始边 max_flow += Augment(s,t,INF); //一次完成所有增广 } return max_flow; }int main(){ E_init(); scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); while(m--) { int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); } printf(&quot;%d&quot;,dinic()); return 0;}","link":"/2019/02/23/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"title":"虚树","text":"众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树…… 定义给定点集 $V_k$ 代表有效点，我们定义一颗树 $T=(V,E)$ 是建立在 $V_k$ 上的虚树，当且仅当： $V_k\\subseteq V$ $\\forall x\\in V, x\\in V_k \\text{ or } \\exists u,v\\in V, \\text{s.t. } \\text{LCA}(u,v)=x$ $\\forall (u,v)\\in E, \\text{LCA}(u,v)=u\\text{ or }v$ 一句话来讲：虚数是关键点以及关键点的 LCA 构成的，保证原树的祖孙关系不变的重构树。 构建模仿笛卡尔树的构建，虚树的构建可以使用单调栈在 $O(|V_k|\\log |V|)$ 的时间内完成，其中 $\\log V$ 的复杂度是倍增 LCA 的复杂度。如果使用 $O(n)-O(1)$ 的 RMQ-LCA，则可以降至 $O(|V_k|\\log |V_k|)$，基本可以视作线性。这种方法一般被称为「单调栈维护右链」。 顾名思义，这种构建方法的本质就在于使用单调栈去维护虚数最靠右边的树链。容易得出这份代码： 1234567891011121314151617181920212223242526#include&lt;algorithm&gt;using std :: sort;const int CN = 1e5 + 5;class fs{} E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x, int y, int z) {}int lca(int u, int v) {}int a[CN], stk[CN], top = 0, dfn[CN];bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];} // 按 dfs 序排序void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(a[i], stk[top]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);} 一道栗题 $n$ 个点的树，边有边权。$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少边能使得关键点都不与 $1$ 号节点联通，最小化切断的边的边权。$n,q,\\sum k_i\\le 10^5$ 如果只有一次询问，则可以通过树上 DP 简单求出。注意到 DP 的过程中有效的点只有关键点和它们的 LCA，因此直接建出虚树 DP 即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 3e5 + 5;const int INF = 0x3f3f3f3f3f3f3f3f;class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, m, mn[CN], dep[CN], fa[CN][21], dfn[CN], idx = 0;void dfs(int u, int p){ // 预处理 fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) mn[v] = min(mn[u], E[k].w), dfs(v, u);}}int lca(int x, int y){ // 倍增 LCA if(dep[x] &lt; dep[y]) swap(x, y); for(int k = 20; k + 1; k--) if(dep[ fa[x][k] ] &gt;= dep[y]) x = fa[x][k]; if(x ^ y){ for(int k = 20; k + 1; k--) if(fa[x][k] ^ fa[y][k]) x = fa[x][k], y = fa[y][k]; x = fa[x][0]; } return x;}int a[CN], stk[CN], top = 0;bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}void bd(){ // 建立虚树 sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; // 小心翼翼的初始化 for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; // 小心翼翼的初始化 } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);}int f[CN]; bool is[CN];void dp(int u, int p){ // DP f[u] = mn[u]; int sum = 0; // 小心翼翼的初始化 for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dp(v, u), sum += f[v]; } if(!is[u]) f[u] = min(f[u], sum);}signed main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);} mn[1] = INF, dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; memset(hd, 0, sizeof(hd)), ecnt = 0; m = read(); while(m--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(), dp(1, 0), printf(&quot;%lld&quot;, f[1]), puts(&quot;&quot;); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; // 小心翼翼的清空标记 }} 又一道栗题 $n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少点能使得关键点互不相连，无解输出 -1。$n,q,\\sum k_i\\le 10^5$ 依然沿用上题的思路，只不过在树上 DP 的时候细节较多。可以维护一个 $g[u]$ 表示子树 $u$ 中是否还存在与 $u$ 相连的关键点，在转移时分类讨论即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int CN = 1e5 + 5;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, q;int dep[CN], fa[CN][21], dfn[CN], idx = 0;void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) dfs(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}int stk[CN], top = 0, a[CN];bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = 1, hd[1] = 0, ecnt = 0; for(int i = 1; i &lt;= a[0]; i++){ if(a[i] == 1) continue; int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top]), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top]), stk[top] = l; else add(l, stk[top]), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1]);}int f[CN], g[CN]; bool is[CN];bool dp(int u, int p){ f[u] = g[u] = 0; int cnt = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v == p) continue; if(!dp(v, u)) return false; f[u] += f[v], cnt += g[v]; if(is[u] &amp;&amp; is[v] &amp;&amp; dep[v] - dep[u] &lt;= 1) return false; // 无解 } if(is[u]) f[u] += cnt, g[u] = 1; // 讨论 u 的决策 else if(cnt &gt; 1) f[u]++; else if(cnt == 1) g[u] = 1; return true; // 有解}int main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v), add(v, u);} dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(); if(dp(1, 0)) printf(&quot;%d&quot;, f[1]), puts(&quot;&quot;); else puts(&quot;-1&quot;); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; }} 双一道栗题 $n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问关键点之间的两两距离和，距离最小值和距离最大值。$n,q,\\sum k_i\\le 10^5$ 距离最大 / 最小都可以简单维护，对于“距离和”这个问题，有一个常用方法是考虑每条边对答案的贡献。这就跟边有关系了，因此在建立虚树时不能再固定以 $1$ 号节点为根，简单维护一下树根即可，时间复杂度 $O(\\sum k_i\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;#define int long longconst int CN = 1e6 + 6;const int INF = 0x3f3f3f3f3f3f3f3f;class fs {public: int to,nxt,w; void init(int t,int n,int d) {to = t, nxt = n, w = d;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}int n, q;int fa[CN][21], dep[CN], dis[CN], dfn[CN], idx = 0;void dfs(int u, int p){ fa[u][0] = p, dep[u] = dep[p] + 1, dfn[u] = ++idx; for(int k = hd[u]; k; k = E[k].nxt) {int v = E[k].to; if(v ^ p) dis[v] = dis[u] + E[k].w, dfs(v, u);}}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];}int stk[CN], top = 0, a[CN], rt; // rt 维护树根void bd(){ sort(a + 1, a + a[0] + 1, cmp); stk[top = 1] = a[1], hd[ a[1] ] = 0, ecnt = 0; for(int i = 2; i &lt;= a[0]; i++){ int l = lca(stk[top], a[i]); if(l ^ stk[top]){ while(dfn[ stk[top - 1] ] &gt; dfn[l]) add(stk[top - 1], stk[top], 0), top--; if(l ^ stk[top - 1]) hd[l] = 0, add(l, stk[top], 0), stk[top] = l; else add(l, stk[top], 0), top--; } hd[ a[i] ] = 0, stk[++top] = a[i]; } rt = stk[1]; for(int i = 1; i &lt; top; i++) add(stk[i], stk[i + 1], 0);}int mn[CN], mx[CN], sz[CN], amn, amx, ans, tmp1[4], tmp2[4]; bool is[CN];void dp(int u, int p){ if(!hd[u]) return (void)(mn[u] = mx[u] = 0, sz[u] = 1); mn[u] = INF, mx[u] = sz[u] = 0; int Mn = INF, pMn = INF, Mx = 0, pMx = 0; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to, d = dis[v] - dis[u]; if(v == p) continue; dp(v, u); mn[u] = min(mn[u], mn[v] + d), tmp1[0] = mn[v] + d, mx[u] = max(mx[u], mx[v] + d), tmp2[0] = mx[v] + d; sz[u] += sz[v]; ans += d * (a[0] - sz[v]) * sz[v]; // 计算距离和 tmp1[1] = Mn, tmp1[2] = pMn, tmp2[1] = Mx, tmp2[2] = pMx; sort(tmp1, tmp1 + 3), sort(tmp2, tmp2 + 3, greater&lt;int&gt;()); Mn = tmp1[0], pMn = tmp1[1], Mx = tmp2[0], pMx = tmp2[1]; } amn = min(amn, Mn + pMn), amx = max(amx, Mx + pMx); // 计算距离最大 最小 if(is[u]) sz[u]++, amn = min(amn, Mn), mn[u] = 0;}signed main(){ n = read(); for(int i = 1; i &lt; n; i++) {int u = read(), v = read(); add(u, v, 1), add(v, u, 1);} dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ a[0] = read(); for(int i = 1; i &lt;= a[0]; i++) a[i] = read(), is[ a[i] ] = true; bd(), amn = INF, amx = ans = 0; if(a[0] == 1) ans = amn = amx = 0; dp(rt, 0), printf(&quot;%lld %lld %lld&quot;, ans, amn, amx), puts(&quot;&quot;); for(int i = 1; i &lt;= a[0]; i++) is[ a[i] ] = false; }} 相关题目 「SDOI2011」消耗战 「CF613D」Kingdom and its Cities 「HEOI2014」大工程 习题「HNOI2014」世界树","link":"/2020/09/11/%E8%99%9A%E6%A0%91/"},{"title":"考前的小知识积累","text":"快考试了，整理一下最近学到的细碎的东西。东西很杂，也有一些叫不上名字来，简单写写吧…… max+ 矩阵乘法定义一类新矩阵乘法：$$ C= A * B\\Leftrightarrow C_{i,j}=\\max\\limits_{i,j,k}A_{i,k}+B_{k,j} $$ 为矩阵的 max+ 乘法。注意到这类乘法是满足结合律的，因此可以快速幂优化。这类乘法的本质类似于一轮 Floyd 传递闭包。 相关题目：Hamsters max+ 卷积定义一类新的序列卷积：$$ C=A*B\\Leftrightarrow C_k=\\max\\limits_{i+j=k}A_i+B_j $$ 这类卷积很难做到低于 $O(n^2)$ 的复杂度内计算，但是如果 $A,B$ 都是离散意义下的凸函数的话，可以做到 $O(n\\log n)$ 计算，方法如下： 把序列 $A,B$ 分别排序后差分，把得到的增量合并到一个序列中降序排序，这会得到一个长度为 $2n-2$ 的新序列，记为 $\\text{d}$。注意到必然有 $C_0=A_0+B_0$，我们下一步需要按从大到小的顺序把增量加进去，即有 $C_1=C_0+\\text{d}_0, C_i=C_{i-1}+\\text{d}_{i - 1}$，于是就还原出了卷积后的结果 $C$，时间复杂度只有排序的 $O(n\\log n)$。 这种做法的正确性在于：对于凸函数而言，增量 $\\text{d}$ 的可取范围与其大小是相应变化的。那么如果做凹函数的 min+ 卷积的时候，也可以适用类似的做法。 斜率优化有一种普适性的在亚线性时间复杂度内，解决一类距离最值问题的方法，通俗的叫法好像叫做斜率优化。 这类问题的一般模型是：定义一类新的距离 $\\text{dist}(i,j)=A_i+B_j+C_iD_j$，求 $\\min\\limits_{i,j}\\text{dist}(i,j)$。注意到关于 $i, j$ 的下标运算是二次的，因此无法拆开来简单维护。 考虑枚举 $i$，转化为求如下式的值：$p + \\min\\limits_{1\\le j\\le n} B_j+kD_j$，设有 $l_j=B_j+kD_j$，得到 $B_j=-kD_j+l_j$，这是一条过定点 $(D_j, B_j)$，斜率为 $-k$ 的直线，而我们要最小化的东西是这条直线的截距 $l_j$。 那么现在等价于给出一堆点 $(D_1,B_1),(D_2,B_2),…,(D_n,B_n)$ 和一个斜率 $-k$，让我们求一条直线使得截距最小。显然，所求点必然在这些点形成的下凸壳上，那么维护出下凸壳二分即可。有时斜率给出的性质特殊，则可以单调维护；当点的选取范围有要求时，可以结合单调栈 / 线段树。 给出一个示例：求 $\\min\\limits_{i,j}a_i+b_j+(i-j)^2$。 1234567891011121314151617stk[++top] = 1; for(int i = 2; i &lt;= n; i++){ int u, v; while(top &gt; 1){ u = stk[top], v = stk[top - 1]; if(1ll * (b[u] - b[v]) * (i - u) &lt; 1ll * (b[i] - b[u]) * (u - v)) break; top--; } stk[++top] = i;}int p = 1, ans = 0x3f3f3f3f;for(int i = 1; i &lt;= n; i++){ int u = stk[p], v = stk[p + 1]; while(p &lt; top &amp;&amp; b[v] - 2 * i * v &lt; b[u] - 2 * i * u) p++, u = v, v = stk[p + 1]; u = stk[p], ans = min(ans, a[i] + b[u] - 2 * i * u);} 相关题目：Thief 常幂展开在贡献法中的应用看一道好题： 给出简单无向图 $G=(V,E)$，设 $S=(V_S,E_S)$ 为 $G$ 的某个导出子图，求 $\\sum\\limits_{S\\subseteq G}|E_S|^k$。$|V|,|E|\\le 10^5, 1\\le k\\le 3$ 显然，当 $k=1$ 时，我们可以运用贡献法考虑每条边对答案的贡献，因此得到答案即是 $|E|2^{|V|-2}$。 但是当 $k\\ge 2$ 时，因为乘幂运算的缘故，直接使用贡献法是不可以的。根据常幂展开公式，我们可以这样给柿子变形：$$ \\begin{aligned}\\sum\\limits_{S\\subseteq G}|E_S|^k= \\sum\\limits_{i=0}^k \\begin{Bmatrix}k\\newline i\\end{Bmatrix}i!\\sum\\limits_{S\\subseteq G}\\dbinom{|E_S|}{i} \\end{aligned} $$ 注意到这是求和，因此贡献法又适用了，那我们可以考虑求后面的 $\\sum\\limits_{S\\subseteq G}\\dbinom{|E_S|}{i}$。考虑这个柿子的意义，我们可以等价于在原图中任意钦点 $i$ 条边出来，统计所有情况下包含 $i$ 条边的导出子图的数量。即我们考虑钦点一个组合数选出来的东西，然后考虑它的贡献，即它被选到的次数。 我们分类讨论。设边数为 $m$，点数为 $n$，对于 $k=2(i=(0),1,2)$ 的情况，可以这样分类： $i=1$，即选一条边，显然是 $m2^{n-2}$； $i=2$，即选两条边。注意到两条边可以共用一个端点，或者有四个独立的端点。我们只需要对这两种情况分别统计“方案数x被导出子图包含的次数”即可。 $k=3$ 的情况也可以类似的进行分类，于是就可以完成了。复杂度的瓶颈在于 $k=3$ 时的三元环计数，因此复杂度 $O(m^{1.5})$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_backconst int P = 1e9 + 7;const int CN = 1e5 + 50;const int i2 = 5e8 + 4;const int i3 = 333333336;int read(){ int s = 0, ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') {if(c == '-') ne = -1; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int C(int x) {return 1ll * (1ll * x * (x - 1) % P) * i2 % P;}int n, m, k, pw[CN], du[CN]; namespace sub1 {void work(){printf(&quot;%lld&quot;, 1ll * m * pw[n - 2] % P);}}namespace sub2 {void work(){ int ans = 1ll * m * pw[n - 2] % P, s1 = 0, s2 = 0; // i = 1 for(int i = 1; i &lt;= m; i++){ int x = read(), y = read(); du[x]++, du[y]++; } for(int i = 1; i &lt;= n; i++) s1 = add(s1, C(du[i])); s2 = add(C(m), P - s1); if(n &gt;= 3) s1 = 1ll * s1 * pw[n - 3] % P; else s1 = 0; if(n &gt;= 4) s2 = 1ll * s2 * pw[n - 4] % P; else s2 = 0; s1 = add(s1, s2); ans = add(ans, add(s1, s1)); printf(&quot;%d&quot;, ans);}}namespace sub3 {int X[CN], Y[CN], col[CN]; vector&lt;int&gt; G[CN];bool le(int i, int j) {return du[i] ^ du[j] ? du[i] &lt; du[j] : i &lt; j;}void work(){ int ans = 0, cnt1 = 1ll * m * pw[n - 2] % P, cnt2 = 0, cnt3 = 0; for(int i = 1; i &lt;= m; i++){ int x = read(), y = read(); du[x]++, du[y]++, X[i] = x, Y[i] = y; } int s1 = 0, s2 = 0, s3 = 0, s4 = 0; /* cnt2 */ for(int i = 1; i &lt;= n; i++) s1 = add(s1, C(du[i])); s2 = add(C(m), P - s1); if(n &gt;= 3) s1 = 1ll * s1 * pw[n - 3] % P; else s1 = 0; if(n &gt;= 4) s2 = 1ll * s2 * pw[n - 4] % P; else s2 = 0; cnt2 = add(s1, s2); /* cnt3 */ s1 = s2 = s3 = s4 = 0; for(int i = 1; i &lt;= m; i++){ int u = X[i], v = Y[i]; if(le(u, v)) G[v].pb(u); // v &gt; u : v -&gt; u else G[u].pb(v); } for(int i = 1; i &lt;= n; i++){ for(int l = G[i].size(), j = 0; j &lt; l; j++) col[G[i][j]] = i; for(int l = G[i].size(), t = 0; t &lt; l; t++){ int j = G[i][t]; for(int ll = G[j].size(), tt = 0; tt &lt; ll; tt++) if(col[G[j][tt]] == i) s1++; } } for(int i = 1; i &lt;= m; i++) s2 = add(s2, 1ll * (du[X[i]] - 1) * (du[Y[i]] - 1) % P); s2 = add(s2, P - (3ll * s1 % P)); for(int i = 1; i &lt;= n; i++) s3 = add(s3, 1ll * C(du[i]) * (m - du[i]) % P); s3 = add(s3, P - add(3ll * s1 % P, 2ll * s2 % P)); for(int i = 1; i &lt;= n; i++){ int cur = 1ll * C(du[i]) * (du[i] - 2) % P; cur = 1ll * cur * i3 % P; s2 = add(s2, cur); } s4 = 1ll * C(m) * (m - 2) % P, s4 = 1ll * s4 * i3 % P; s4 = add(s4, P - add(add(s1, s2), s3)); if(n &gt;= 3) s1 = 1ll * s1 * pw[n - 3] % P; else s1 = 0; if(n &gt;= 4) s2 = 1ll * s2 * pw[n - 4] % P; else s2 = 0; if(n &gt;= 5) s3 = 1ll * s3 * pw[n - 5] % P; else s3 = 0; if(n &gt;= 6) s4 = 1ll * s4 * pw[n - 6] % P; else s4 = 0; cnt3 = add(add(s1, s2), add(s3, s4)); /* answer */ cnt2 = 6ll * cnt2 % P, cnt3 = 6ll * cnt3 % P; ans = add(cnt1, add(cnt2, cnt3)), printf(&quot;%d&quot;, ans);}}int main(){ n = read(), m = read(), k = read(); pw[0] = 1; for(int i = 1; i &lt;= n; i++) pw[i] = add(pw[i - 1], pw[i - 1]); if(k == 1) sub1 :: work(); if(k == 2) sub2 :: work(); if(k == 3) sub3 :: work(); return 0;} Lorem Ipsum一个新的技巧： 众所周知，将 $m$ 划分为 $n$ 个非负整数有 $\\dbinom{m+n-1}{n-1}$ 种方案。对于任意方案 $P$，我们定义 $val_k(P)$ 表示该划分中第 $k$ 大的数（降序排序后的第 $k$ 个）。设 $S$ 为总方案集，现在给定 $m,n,k$，请求出 $\\sum\\limits_{P\\in S}val_k(P)$。$n,m\\le 5000$ 设 $f[k,l]$ 表示一个划分中至少有 $k$ 个数字 $\\ge l$ 的划分的数量。首先有等式：$$ \\sum\\limits_{P\\in S} val_k(P) =\\sum\\limits_{l=1}^mf[k,l] $$ 这个可以这样理解：我们考虑对于任意一个方案中第 $k$ 大的数，设它是 $p$，那么对于 $\\forall l\\le p$ 的 $f[k,l]$，$p$ 都会在 $f[k,l]$ 中被累加一次，一共累加 $p$ 次，因此这样是正确的。 那么现在的问题是求出“至少有 $k$ 个数字 $\\ge l$ 的划分数”，这是一个“至少”限制，因此不可以直接选出来。可以这样理解：直接拿组合数选出来的是“钦定某 $k$ 个数字 $\\ge l$ 的划分数”，而我们要求的是“有任意至少 $k$ 个数字 $\\ge l$ 的划分数”。 形式化的说，设 $g[k,l]$ 为“恰好 $k$ 个数字 $\\ge l$ 的划分数”，$h[k,l]$ 为“钦定 $k$ 个数字 $\\ge l$ 的划分数”，$f[k,l]$ 为“至少有 $k$ 个数字 $\\ge l$ 的划分数”，那么有：$$ \\begin{align} h[k,l]&amp;=\\dbinom{n}{k}\\dbinom{m-kl+n-1}{n-1}\\newline &amp;=\\sum\\limits_{j=k}^n\\dbinom{j}{k}g[j,l] \\newline \\Leftrightarrow g[k,l]&amp;=\\sum\\limits_{j=k}^n(-1)^{j-k}\\dbinom{j}{k}\\dbinom{n}{k}\\dbinom{m-kl+n-1}{n-1} \\end{align}$$ 即是二项式反演，注意到这里实现了“钦定”到“恰好”的转化。“恰好”到“至少”的转化也可以类似的表示：$$ \\begin{align} f[k,l]&amp;=\\sum\\limits_{j=k}^n g[j,l]\\newline \\Leftrightarrow g[k,l]&amp;=f[k,l]-f[k+1,l] \\end{align} $$ 总结来说，二项式反演联系了“钦定”与“恰好”限制，前/后缀和和差分联系了“至少”和“恰好”限制。 用 set 维护线段覆盖看这样一个问题： 给出 $n$ 条线段 $[l_1,r_1],…[l_n,r_n]$，$q$ 次询问编号在 $[a,b]$ 内的线段覆盖的总长度是多少。$n,q\\le 10^5, l_i, r_i \\le 10^9$ 首先离线询问，把每个询问挂在询问区间的右端点上。考虑枚举询问的右端点 $b$，并用数据结构来维护每个 $i(i\\le b)$ 的答案。 考虑怎样能快速地维护。如果对数轴上的每一个点维护一下它最后一次被覆盖是在什么时候（没覆盖就是 0），那么可以发现数轴会被划分成若干值相同的连续段。注意到同一时刻连续段的数量只有 $O(n)$ 种，那么我们考虑用 set 去维护这个东西。 具体来说，我们可以维护一个二元组 $(r,t)$，其中 $r$ 是当前连续段的分界点（右端点），$t$ 是当前连续段最晚被覆盖的时间。我们考虑新加入一个段 $(r_i,i)$，那么首先所有与其有交的连续段都会受到影响。具体来说，会有一些连续段被完全覆盖，即等价于删除，还有至多两个连续段会被分裂成两部分，其中一部分被保留，另一部分被替代。 我们考虑如果删除了一个连续段 $(r’,t’)$，它的长度是 $l$，那么左端点在 $[t’+1,i]$ 内区间的答案都会被加上 $l$，因为当前连续段的影响从 $t’$ 扩大到了 $i$。那么我们需要一个数据结构，支持区间加和单点求值，那么套一个 BIT 就可以解决了。时间复杂度是 $O(n\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define iter set&lt;PAIR&gt; :: iteratorconst int CN = 1e5 + 50;int read(){ int s = 0, ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') {if(c == '-') ne = -1; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class PAIR { public: int x, y; bool operator &lt; (const PAIR &amp;o) const {return x ^ o.x ? x &lt; o.x : y &lt; o.y;}};PAIR mp(int a, int b) {PAIR o; o.x = a, o.y = b; return o;}set&lt;PAIR&gt; S; vector&lt;PAIR&gt; Q[CN];int n, m, L[CN], R[CN], ans[CN];class BIT { public: int d[CN]; void add(int p, int x) {while(p &lt;= n) d[p] += x, p += p &amp; (-p);} void md(int l, int r, int x) {add(l, x), add(r + 1, -x);} int qu(int p) {int r = 0; while(p) r += d[p], p -= p &amp; (-p); return r;}} D;int main(){ n = read(), m = read(); for(int i = 1; i &lt;= n; i++) L[i] = read(), R[i] = read(); for(int i = 1; i &lt;= m; i++){ int l = read(), r = read(); Q[r].pb(mp(l, i)); } S.insert(mp(1e9, 0)); for(int i = 1; i &lt;= n; i++){ int l = L[i], r = R[i], fst = -1, prv = l - 1; iter it = S.lower_bound(mp(l, 0)); while(1){ if(it == S.end()) break; int cur = (*it).x, p = (*it).y, len; if(fst &lt; 0) fst = p; len = min(cur, r) - prv, D.md(p + 1, i, len); if(cur &lt;= r){ prv = cur; iter pit = it; it++, S.erase(pit); } else break; } if(l &gt; 1) S.insert(mp(l - 1, fst)); S.insert(mp(r, i)); for(int l = Q[i].size(), j = 0; j &lt; l; j++) ans[Q[i][j].y] = D.qu(Q[i][j].x); } for(int i = 1; i &lt;= m; i++) printf(&quot;%d&quot;, ans[i]), puts(&quot;&quot;); return 0;}","link":"/2020/10/16/%E8%80%83%E5%89%8D%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"title":"置换群学习笔记","text":"置换群的相关内容主要用于解决一类“充满对称性”的计数问题。基于轨道-稳定子群定理的 Burnside 引理和引申出的 Pólya 计数原理是我们解决这类问题的有力工具…… 群对于一个非空集合 $S$ 和该集合上定义的二元运算 $·$，当该运算满足一些性质时，我们称它们构成一个群，记作 $(S,·)$。运算需要满足的性质是： 封闭性：$\\forall x,y\\in S, x·y\\in S$ 结合性：$\\forall x,y,z\\in S,(x·y)·z=x·(y·z)=x·y·z$ 存在单位元：$\\exists e\\in S, \\text{s.t. }\\forall y\\in S, e·y=y$ 存在逆元：$\\forall y\\in S,\\exists x\\in S,\\text{s.t. } x·y=e$ 这是群论的基本定义，在 OI 界，更加常用的是置换群。 置换和置换群 置换：一个从某个排列到某个排列的双射称作置换，记作 $p:f\\to g$，其中 $f\\to g$ 指代某种双射。 乘法：两个置换 $u,v$ 的乘法定义为它们对排列先后作用得到的结果，记作 $v·u$。 置换群：根据群论的基本概念，置换构成的集合和建立在置换上的乘法构成置换群。 然后是一些有关于计数的概念。 染色：给序列中的每个元素分配一个“颜色”从而得到的不同序列的过程称作染色。形式化地，可以用序列 $c$ 表示一个染色，其中 $c[i]$ 表示 $i$ 这个位置上的颜色。所有染色组成染色全集 $\\mathcal{C}$。 置换对染色的作用：对于一个置换 $g$，其作用于某个染色 $c$ 可以得到一个新的染色，记作 $g·c$。 置换群对染色的作用（轨道）：对于一个置换群 $G$ 和一个染色 $c$，将所有 $g\\in G$ 作用于 $c$ 得到的集合称作 $c$ 在 $G$ 下的轨道，记作 $G·c=\\begin{Bmatrix}g·c\\text{ | }g\\in G \\end{Bmatrix}$。 Burnside 引理与 Pólya 计数原理用于解决在某种置换群 $G$ 作用下染色集合 $X\\subseteq \\mathcal{C}$ 共有多少本质不同的元素，即轨道数 $|X/G|$。 Burnside 引理设 $X\\subseteq \\mathcal{C}$ 是某个染色集合， $G$ 是作用在 $X$ 上的置换群，我们记 $X/G$ 为在 $G$ 作用下 $X$ 的轨道集合，即 $X/G=\\begin{Bmatrix} gc\\text{ | } c\\in X, g\\in G\\end{Bmatrix}$。 不动点（稳定子）：置换 $g\\in G$ 作用在 $X$ 上的不动点为 $X$ 中在 $g$ 作用下不发生变化的元素，组成的集合即 $\\begin{Bmatrix}c\\in X\\text{ | }gc=c\\end{Bmatrix}$，记作 $X^g$。 Burnside 引理指出，轨道数 $|X/G|$ 等于 $G$ 中所有置换对应的不动点个数的平均值，即有： $$ |X/G|= \\dfrac{1}{|G|}\\sum\\limits_{g\\in G}|X^g| $$ Pólya 计数原理 置换的循环表示：简单来讲，如果把置换的双射看成图上的有向边，那么置换显然是成环的。我们可以据此把一个置换拆分成若干置换（轮换）的乘积，这称作置换的循环表示。 循环数：某一个置换 $g$ 具有的轮换的个数称作循环数，记作 $\\chi(g)$。 Pólya 原理指出，如果对于所有染色序列 $c\\in X$ ，如果 $c$ 的所有位置可分配的颜色集合 $S$ 相同，那么不动点个数恰等于色数的循环数次方，即 $|X^g|=|S|^{\\chi(g)}$。 根据 Burnside 引理，可以进一步得到一个常见的计数公式： $$|X/G|=\\dfrac{1}{|G|}\\sum\\limits_{g\\in G}|S|^{\\chi(g)}$$ 一道栗题 $n(n+1)/2$ 个格子形成一个 $n$ 层的三角形，我们要给每个格子涂上黑白两种颜色。三角形可以沿中线翻转或顺/逆时针旋转，问一共有多少种本质不同的涂色方式。$n\\le 20$ 显然，旋转的置换一共有三种 $\\sigma^0,\\sigma^1,\\sigma^2$，翻转的置换题目给出了一种。考虑到置换群需要满足自闭性，那么先翻转再旋转的置换也应当位于置换群中，这等价于沿着一条斜着的中线翻转。因此翻转的置换也共有三种。 然后需要求出某种置换的循环数。$\\sigma^0$ 显然是 $n(n+1)/2$，$\\sigma^1,\\sigma^2$ 容易发现是 $\\lceil n(n+1)/6 \\rceil$，翻转的循环数显然是 $(n(n-1)/2-\\lceil n/2\\rceil)/2+\\lceil n/2\\rceil$，从而答案是 $\\dfrac{1}{6}(2^{\\binom{n+1}{2}}+2^{\\lceil n(n+1)/6 \\rceil+1}+3·2^{(\\binom{n+1}{2}-\\lceil n/2\\rceil)/2+\\lceil n/2\\rceil})$。 又一道栗题 给定三个整数 $A,B,C$ 和由 $m$ 个置换形成的置换群 $G=\\begin{Bmatrix}p_1, p_2, …, p_m\\end{Bmatrix}$。需要给 $n=A+B+C$ 个格子涂三种颜色，满足三种颜色的格子各有 $A,B,C$ 个，问在 $G$ 作用下共有多少不同的涂色方案。$A,B,C\\le 20,m\\le 60$ 考虑如何求在某个置换作用下的不动点个数。把每个置换循环分解，一个轮换上的点显然只能涂同一种颜色。然后看上去就可以背包一下，DP 把方案数计出来，套一个 Burnside 引理就可以算了。 朴素的复杂度大概是 $O(mnA^3)$，可能还能进一步优化。 双一道栗题 现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\\text{ ~ }m-1$ 之一。环可以旋转，旋转得到的环视为相同的环，问有多少种本质不同的染色方案。$ n,m\\le 10^9 $ 考虑先写出置换群 $G$ 来。我们设 $\\sigma$ 为一次顺时针旋转（转动一个单位），则有 $G=\\begin{Bmatrix} \\sigma ^{x} \\text{ | }x\\ge 0\\end{Bmatrix}$。注意到旋转 $n$ 次等价于不旋转，则 $|G|=n$。 根据 Pólya 原理，在 $\\sigma^{i}$ 下的不动元素数 $|X|^{\\sigma ^i}=m^{\\chi(\\sigma^i)}$。把 $\\chi(\\sigma^i)$ 写成循环表示的形式，即 $\\sigma^i=(1,i,2i,…)(2,i+1,2i+1,…)…$，容易发现循环数为 $(i,n)$，这里的小括号特指两个数的最大公因数（Greatest Common Divisor, GCD）。 从而答案是 $\\dfrac{1}{n}\\sum\\limits_{i=1}^n m^{(i,n)}$。 注意到 $(i,n)|n$，化一下柿子变成：$$\\begin{aligned}&amp;\\dfrac{1}{n}\\sum\\limits_{i=1}^n m^{(i,n)}\\newline =&amp; \\dfrac{1}{n}\\sum\\limits_{d|n}m^d \\sum\\limits_{i=1}^n[(i,n)=d]\\newline =&amp;\\dfrac{1}{n}\\sum\\limits_{d|n}m^d \\sum\\limits_{d|i,i\\le n}[(i/d,n/d)=1]\\newline =&amp;\\dfrac{1}{n}\\sum\\limits_{d|n}m^d \\varphi(n/d)\\end{aligned}$$ 直接做就是 $O(d(n)\\sqrt{n})$。 叒一道栗题 现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\\text{ ~ }m-1$ 之一。有两类置换： 将环旋转若干次 给环上每个点的编号 $+1$ 再模 $m$。 问共有多少种本质不同的染色方案。$n,m\\le 10^{18}$ 设 $G_1=\\begin{Bmatrix}\\sigma^0,\\sigma^1,…,\\sigma^{n-1} \\end{Bmatrix}$ 是旋转操作 $\\sigma$ 的置换群， $G_2=\\begin{Bmatrix}\\tau^0,\\tau^1,…,\\tau^{m-1} \\end{Bmatrix}$ 是加法操作 $\\tau$ 的置换群，则本题中作用在环上的置换群 $G=G_1\\times G_2$，其中 $\\times$ 表示笛卡尔积。 分析一下不动点的个数，得到的柿子是：$$\\begin{aligned}&amp;\\dfrac{1}{nm}\\sum\\limits_{i=1}^n\\sum\\limits_{k=1}^m [k\\text{ is legal}]m^{(n,i)} \\newline =&amp;\\dfrac{1}{nm}\\sum\\limits_{i=1}^nm^{(n,i)}\\sum\\limits_{k=1}^m [m|\\dfrac{kn}{(n,i)}]\\newline =&amp;\\dfrac{1}{nm}\\sum\\limits_{i=1}^nm^{(n,i)}(m,n/(n,i))\\end{aligned}$$ 第一个柿子里的 $[k\\text{ is legal}]$ 这个条件一看就很吓人。但是冷静分析一下，就可以注意到我们实际上是需要轮换上相邻数字之差在模 $m$ 意义下恰好为 $k$，那么只需要判断是否能填充一个合法的轮换，即是否存在 $m|lk$，其中 $l$ 是轮换长，满足 $l=n/(n,i)$。 化一下变成：$$\\begin{aligned} =&amp;\\dfrac{1}{nm}\\sum\\limits_{d|n}m^d(m,n/d)\\sum\\limits_{i=1}^{n/d}[(i,n/d)=1]\\newline =&amp; \\dfrac{1}{nm}\\sum\\limits_{d|n}m^d(m,n/d)\\varphi(n/d)\\end{aligned}$$ 直接做是 $O(d(n)\\sqrt{n})$，加个 Pollard-Rho 强行降成 $O(d(n)n^{1/4})$。 相关资料参考： 《浅谈群论在信息学竞赛中的简单应用》虞皓翔，IOI中国国家候选队论文2020 相关题目： 「AHOI2002」黑白瓷砖 「HNOI2008」Cards 「LG-P4980」Pólya 定理 暂无来源 进阶指南丧命指南： 群论计数/Archieve, xyix’s Blog 拉格朗日反演/Archieve, xyix’s Blog","link":"/2020/11/26/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"迭代加深搜索","text":"迭代加深搜索（Iterative Deepening Depth First Search,IDDFS），是朴素深度优先搜索（Depth First Search,DFS）的一种改进。它的核心思想是：控制当前搜索的深度上限$mxd$，初始化为$1$并令其不断递增，在这个深度限制上进行DFS…… 一 引入1 概念迭代加深搜索（Iterative Deepening Depth First Search,IDDFS），是朴素深度优先搜索（Depth First Search,DFS）的一种改进。它的核心思想是：控制当前搜索的深度上限$mxd$，初始化为$1$并令其不断递增，在这个深度限制上进行DFS。 2 优势迭代加深搜索是状态空间搜索（即隐式图的搜素）中比较常用的搜索方式之一，适用于解决搜索树（即状态树）的深度的广度看似都没有明显上限的状态空间搜索问题。与其类似的算法还有IDA*（Iterative Deepening A-Star）算法，在状态空间搜索问题中也比较常用。 最常见的两种搜索方式（或称搜索顺序）即是深度优先搜索和广度优先搜索（Breadth First Search），前者优先遍历当前节点的一棵子树，后者优先遍历当前节点的所有子节点。但是如果有一棵看似非常庞大的搜索树，如下图（请把它想得再庞大一点），这两种搜索方式劣势明显。如图，无论使用DFS还是BFS，从初始状态到达目标状态都要消耗不少的时间，因为该搜索树无论在深度上还是在广度上都是看似无限大的（请人为脑补）。 但是目标状态只有一个且是确定的。这时不妨先控制每次DFS的深度，并且通过最大深度对当前所有子状态进行可行性剪枝，也就是限制广度，那么我们只需要花费一定的时间就可以到达目标状态。如下图，即是IDDFS的搜索方法。注意在DFS的深度扩大的同时，广度也是在不断扩大的。 二 应用 「UVa12558」埃及分数 在古埃及，人们用若干单位分数（形如1/a，a是有理数）的和表示一切有理数。例如，2/3=1/2+1/6，但不允许2/3=1/3+1/3，因为加数不允许相同。对于一个分数a/b，有多种表示方法，其中加数少的比加数多的好，若加数个数相同，则最小的分数越大越好。例如，19/45=1/5+1/6+1/18是最优方案。输入整数a/b，计算最佳表达式，加数从大到小排列。 1 分析此题显然可以用搜索来解决，但是它的解答树是及其庞大的。你既无法预估它的深度（加数个数），也无法预估当前深度下解答树的广度（加数大小）。此时只能通过IDDFS来求解。 2 思路设当前最大深度限制为$mxd$，定义DFS函数为$\\text{dfs}(d,c,a,b)$，其中$d$为当前深度，$a/b$为当前剩余的分数，$c$为满足$1/c \\leqslant a/b$的最小$c$。DFS的流程如下： 123456789检查是否到达深度限制T -&gt; 检查剩余分数(a/b)是否为埃及分数，并返回true/falseF -&gt; 1. 确定c的值，并循环i : from c to INFTY 2. 检查1/i*(mxd-d+1)&lt;=a/b（可行性剪枝），若否，跳出循环 3. 计算新的剩余分数(a/b-1/i)，向下一层递归 4. 检查递归结果，若为ture，跳出循环并返回ture 5. repeat 1. fin. 循环结束，返回false 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;#define LL long longconst int CN = 1e5+5;int t;LL gcd(LL a,LL b){ //最大公约数 return b ? gcd(b,a%b):a;}//IDDFSint mxd;LL ans[CN],cur[CN];/*返回getfirst(a,b)=c,使得1/c&lt;=a/b且c的值最大*/LL getfirst(LL a,LL b){ if(b % a) return (b/a)+1; return b/a;}/*检查当前的到的答案和之前得到的答案那个更优*/bool better(int pos){ for(int i=pos;i;i--) if(cur[i] != ans[i]) return ans[i]==-1 || cur[i]&lt;ans[i]; return false;}/*把f数组赋值到t中，长度为sz*/inline void copy(LL* f,LL* t,int sz){ for(int i=1;i&lt;=sz;i++) t[i] = f[i];}/*当前深度d 当前分数1/c 剩余分数a/b*/bool dfs(int d,LL c,LL a,LL b){ if(d == mxd){ //最后一个分数是1/(a/b)，即b/a if(b%a) return false; //检查它是不是埃及分数 cur[d] = b/a; //记录答案 if(better(d)) copy(cur,ans,d); //维护答案 return true; } bool flag = false; c = max(c, getfirst(a,b)); //找到c值 for(LL i=c;;i++){ //枚举 if((mxd-d+1)*b &lt;= a*i) break; //可行性剪枝 cur[d] = i; //记录答案 /*计算a/b - 1/i = a1/b1*/ LL a1 = a*i-b,b1 = b*i； LL g = gcd(a1,b1); //便于约分 if(dfs(d+1,i+1, a1/g, b1/g)) flag = true; } return flag;}int main(){ ... //scan bool found = false; for(mxd=1; !found; mxd++){ //主求解代码 memset(ans,-1,sizeof(ans)); found = dfs(0,getfirst(fa,fb),fa,fb); } ... //print return 0;}","link":"/2019/06/25/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2/"},{"title":"除夕闲扯","text":"此页面存在相关页面。关于另一个集合贴，请参见「OI模板梳理」。 此页面中的索引截至 2020.1.24，其中的某些条目可能已经失效。 文化课真好系列。 为了证明 bn 还没入坟，他决定闲的没事瞎bb几句。 所以他对之前的 post 们搞了一个整理，以备后人之用自己欣赏。 图论最短路 Dijkstra：OI模板梳理 2.1.1 SPFA: OI模板梳理 2.1.3 Floyd: Floyd本质探究-「题解」灾后重建 树 最小生成树(MST)：OI模板梳理 2.2，变形-CFR599D 0-1 MST 树的重心，树的直径 LCA: 倍增法-最近公共祖先，树链剖分法-树链剖分 3.1 树上类RMQ问题：树链剖分 连通性 强连通分量/SCC 双连通分量/BCC 割点和桥：双连通分量 2 2-SAT：2019.10 JN 总结.pdf 网络 最大流-最小割：网络最大流 最小费用最大流 二分图 最大匹配：匈牙利算法-二分图匹配，费用流法-最小费用最大流 4.1 最大点全覆盖集：最小费用最大流 4.2 最大独立集：最小费用最大流 4.3 欧拉图：欧拉路 拓扑：拓扑排序 数论线性筛 高斯消元：OI模板梳理 4.3 乘法逆元 费马小定理法-逆元 exgcd法-模线性方程组与中国剩余定理 2 线性求逆元-逆元 2.3 欧几里得系列：欧几里得与扩展欧几里得定理 中国剩余定理系列：模线性方程组与中国剩余定理 矩阵系列：矩阵基础 概论系列：概率与期望 组合学系列：组合数学基础 数据结构单调栈：音乐会的等待 单调队列，对DP的优化-「题解」Watching Fireworks is Fun 堆：OI模板梳理 1.3，或pq一行完成 并查集：OI模板梳理 1.4 树状数组 线段树，线段覆盖-「题解」Atlantis 数列差分 DP背包，变式-「题解」硬币购物 树形DP，变式-「题解」重建道路 状压DP 优化：单调队列优化-「题解」Watching Fireworks is Fun，矩阵乘法优化-「题解」摆花 其他DP内容，请参见标签：DP 其它字符串：KMP-KMP学习笔记 关于本博客的内容，顺便还有之前的Icarus魔改教程，教你一步步走向深渊。 顺便一说，bn 的 luogu 还没有掉蓝（珂怕）。 以上 祝各位新春快乐。 qwq","link":"/2020/01/24/%E9%99%A4%E5%A4%95%E9%97%B2%E6%89%AF/"},{"title":"逆元","text":"若有$a\\times b \\equiv 1(\\text{mod } m)$，则称$b$是$a$在模$m$意义下的逆元…… 一 引入1 定义若有$a\\times b \\equiv 1(\\text{mod } m)$，则称$b$是$a$在模$m$意义下的逆元（inv）。逆元只在取模意义下是有意义的，因此逆元应该小于模数（虽然大于模数对上面的同余方程成立并没有影响）。 2 应用若要求$(a\\div b) \\text{ mod } m$，直接计算会遇到精度问题。 设$c$是$b$的逆元，因为存在$cb\\equiv 1(\\text{mod }m)$，故$\\dfrac{a}{b} \\equiv \\dfrac{a}{b}\\times 1 \\equiv \\dfrac{a·b·c}{b}( \\text{mod } m)$。故可知$a\\div b\\equiv ac( \\text{mod } m)$。 这样计算就避免了精度问题。 二 逆元的求法1 费马小定理 费马小定理：对于整数$a$和质数$p$，若$a,p$互质，则总存在$a^{p-1} \\equiv 1(\\text{mod }p)$ 于是不难发现：若要求$a$在模$p$意义下的逆元，且$p$是质数时，一定有 $a^{p-1} \\equiv a\\times a^{p-2} \\equiv 1 (\\text{mod m})$。故当$p$是质数且$a,p$互质时，$a$在模$p$意义下的逆元为$a^{p-2}$。 用快速幂取模运算$a^{p-2}$就好了。 代码： 1234567891011121314#define LL long longLL QuickPow(LL a,LL b,int m){ //快速幂取模 (a^b)%m LL base = a%m,rec = 1; while(b){ if(b &amp; 1) (rec *= base) %= m; (base *= base) %= m; b &gt;&gt;= 1; } return rec;}LL QueryInv(LL x,int m){ //求x在mod m意义下的逆元 return QuickPow(x,m-2,m);} 2 扩展欧几里得当$a,m$不互质时呢。此时需要解一个单变元模线性方程$ab\\equiv 1(\\text{mod } m)$，具体解法在后面的博文里面会提到，这里只给出代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344LL a,m;LL gcd(LL a,LL b){ return b ? gcd(b,a%b):a;}//用ExGcd求不定方程 ax+by = c的一组特解(x0,y0)//通解: x=x0+i*kx,y=y0-i*ky (i = 0,±1, ±2, ...)void _exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(!b){ x = 1; y = 0; return; } _exgcd(b,a%b,x,y); int t = x; x = y; y = t-(a/b)*y;}bool ExGcd(LL a,LL b,LL c,LL &amp;x,LL &amp;y,LL &amp;kx,LL &amp;ky){ LL g = gcd(a,b); if(c % g) return false; //无解 _exgcd(a,b,x,y); LL kc = c/g; x *= kc; y *= kc; kx = b/g; ky = a/g; return true;} //求模线性方程 ax ≡ b(mod m)的最小非负整数解x0//化成ax-my = b //通解x = x0+i*k bool LineModEqu(LL a,LL b,LL m,LL &amp;x,LL&amp; k){ LL y,kx,ky; if(!ExGcd(a,m,b,x,y,kx,ky)) return false; k = kx; x %= k; x = (x+k)%k; //取非负整数 return true;}//求a的逆元b ab ≡ 1(mod m)LL inv(LL a,LL m){ LL b,k; if(!LineModEqu(a,1,m,b,k)) return -1; return b;} 3 线性递推求逆元若要求$[1,n]$内所有的数在模$m$意义下的逆元，显然可以求$n$次快速幂取模，复杂度$O(nlog_2 n)$。那么有没有办法可以在$O(n)$的时间内求出所有的逆元呢？ 首先一定有$\\text{inv}[1]=1$恒成立，那么就可以用到下面这个递推式：$$\\text{inv}[i] = (m-\\lfloor\\dfrac{m}{i}\\rfloor)\\times \\text{inv}[m\\text{ mod }i]\\text{ }\\text{ }(\\text{mod }m)$$ 推导：设$a = \\lfloor\\dfrac{m}{i}\\rfloor,b= m\\text{ mod }i$，则有$m = a\\times i +b$由$m = a\\times i +b \\Rightarrow ai+b \\equiv 0(\\text{mod }m)\\Rightarrow b\\equiv -ai(\\text{mod }m)$同余号两边同除以$i\\times b$，得$-a\\div b \\equiv 1\\div i (\\text{mod }m)$ 引入$b$的逆元$\\text{inv}[b]$和$i$的逆元$\\text{inv}[i]$，得 $-a\\times\\text{inv}[b] \\equiv \\text{inv}[i]$ $(\\text{mod }m)$代入$a = \\lfloor\\dfrac{m}{i}\\rfloor,b= m\\text{ mod }i$，得 $-\\lfloor\\dfrac{m}{i}\\rfloor·\\text{inv}[m\\text{ mod }i] \\equiv \\text{inv}[i]$ $(\\text{mod }m)$ 又因$m\\equiv 0(\\text{mod }m)$，故$m-\\lfloor\\dfrac{m}{i}\\rfloor\\equiv -\\lfloor\\dfrac{m}{i}\\rfloor (\\text{mod }m)$。所以有$\\text{inv}[i] = (m-\\lfloor\\dfrac{m}{i}\\rfloor)\\times \\text{inv}[m\\text{ mod }i] \\text{ }\\text{ }(\\text{mod }m)$。 为什么不用$-\\lfloor\\dfrac{m}{i}\\rfloor$ ，而用$(m-\\lfloor\\dfrac{m}{i}\\rfloor)$ 呢？因为$-\\lfloor\\dfrac{m}{i}\\rfloor &lt; 0$，那么求出来的逆元也可能是个负数，而我们规定逆元总为正数。 代码： 12345678int n,p;int inv[CN];n = read(); p = read(); inv[1] = 1; for(int i=2;i&lt;=n;i++) inv[i] = (LL)(p-p/i)*inv[p%i]%p;","link":"/2019/07/18/%E9%80%86%E5%85%83/"},{"title":"OI模板梳理","text":"明天自招考试！花点时间把一些老博客上的一些板子转移过来，顺便也复习一下。 此页面存在相关页面。关于本站的目录，请参见「除夕闲扯」。 1 图论最大流此处采用多路增广的 Dinic 算法，并加入了当前弧优化。注意，该算法的复杂度为 $O(n^2m)$，对于存在一个边的容量均是 1 的割边集的图，该算法的复杂度为 $O(n\\sqrt{m})$。 12345678910111213141516171819202122232425262728293031323334353637383940414243namespace DINIC { class fs{ public: int to, nxt, cap, fl; void init(int t, int n, int c, int f) {to = t, nxt = n, cap = c, fl = f;} } E[CN * 10]; int hd[CN], cur[CN], ecnt; void clr() {memset(hd, 0, sizeof(hd)), ecnt = 1;} void adde(int x, int y, int z) { E[++ecnt].init(y, hd[x], z, 0), hd[x] = ecnt; E[++ecnt].init(x, hd[y], 0, 0), hd[y] = ecnt; } int dep[CN]; queue&lt;int&gt; Q; bool bd(int s, int t){ memset(dep, 0, sizeof(dep)), dep[s] = 1, Q.push(s); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int k = hd[u]; k; k = E[k].nxt){ fs e = E[k]; if(e.cap &gt; e.fl &amp;&amp; !dep[e.to]) dep[e.to] = dep[u] + 1, Q.push(e.to); } } return dep[t]; } int aug(int u, int t, int rst){ if(u == t) return rst; int usd = 0; for(int k = cur[u]; k; k = E[k].nxt){ fs e = E[k]; cur[u] = k; if(e.cap &gt; e.fl &amp;&amp; dep[e.to] == dep[u] + 1){ int add = aug(e.to, t, min(rst - usd, e.cap - e.fl)); if(add){ E[k].fl += add, E[k ^ 1].fl -= add, usd += add; if(usd == rst) return usd; } } } return usd; } int mf(int s, int t){ int res = 0; while(bd(s, t)) memcpy(cur, hd, sizeof(hd)), res += aug(s, t, INF); return res; }} 最小费用流此处采用在稠密图上效率更高的 ZKW 费用流，该算法的复杂度为 $O(n^2m)$。关于最短路增广实现的费用流，请参考站内相关博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace ZKW{ class fs { public: int to, nxt, cap, fl, w; void init(int t, int n, int c, int f, int ww) { to = t, nxt = n, cap = c, fl = f, w = ww; } } E[CN &lt;&lt; 2]; int hd[CN], ecnt = 1; void adde(int x, int y, int z, int c){ E[++ecnt].init(y, hd[x], z, 0, c), hd[x] = ecnt; E[++ecnt].init(x, hd[y], 0, 0, -c), hd[y] = ecnt; } int cst, mf, d[CN]; bool vis[CN]; bool bd(int t){ if(vis[t]) return 1; int del = INF; for(int i = 2; i &lt;= ecnt; i++){ int u = E[i ^ 1].to, v = E[i].to; if(vis[u] &amp;&amp; !vis[v] &amp;&amp; E[i].cap &gt; E[i].fl) del = min(del, d[u] + E[i].w - d[v]); } if(del == INF) return 0; for(int i = 1; i &lt;= n; i++) if(vis[i]) d[i] -= del; return 1; } int aug(int u, int t, int rst){ vis[u] = 1; if(u == t) return rst; for(int k = hd[u]; k; k = E[k].nxt){ fs e = E[k]; if(e.cap &gt; e.fl &amp;&amp; !vis[e.to] &amp;&amp; d[u] + e.w == d[e.to]){ int add = aug(e.to, t, min(rst, e.cap - e.fl)); if(add) return E[k].fl += add, E[k ^ 1].fl -= add, add; } } return 0; } void mcmf(int s, int t){ memset(d, 0, sizeof(d)), cst = mf = 0; do{ memset(vis, 0, sizeof(vis)); int add = aug(s, t, INF); mf += add, cst -= add * d[s]; } while(bd(t)); printf(&quot;%d %d\\n&quot;, mf, cst); }} 其它 以下内容请在本站搜索相应文章。 树链剖分 \\ LCA 树的重心 \\ 树的直径 强连通分量（缩点） \\ 双连通分量 倍增LCA 二分图匹配（匈牙利） k 短路问题（A* 寻路，请参阅这篇文章） 2 数论素数筛Eratosthenes 筛法，此筛法非严格的线性。有关线性筛，请见另一篇博文。 1234567891011const int CN = 1e7 + 7;bool isp[CN]; int prime[CN];void GetPrime(int n){ memset(isp, 1, sizeof(isp)); for(int i = 2; i &lt;= n; i++){ if(isp[i]){ prime[++prime[0]] = i; for(int k = 2; i * k &lt;= n; k++) isp[i * k] = 0; } }} 分解质因数试除法，复杂度$O(\\sqrt{x})$。注：一个数的质因数数量是$\\log$级别。 1234567891011#define LL long longconst int CN = 101;int cnt = 0; LL p[CN], a[CN]; void Div(LL x){ for(LL i = 2; i * i &lt;= x; i++){ if(x % i) continue; p[++cnt] = i; while(!(x % i)) {a[cnt]++; x /= i;} } if(x &gt; 1) p[++cnt] = x,a[cnt] = 1;} 高斯消元12345678910111213141516171819202122232425#define DB doublebool equ(){ int p = 1; // 最后一个确定主元的方程+1 for(int i = 1; i &lt;= n; i++){ int q = -1; for(int j = p; j &lt;= n; j++){ if(fabs(a[j][i]) &lt; EPS) continue; if(q == -1 || fabs(a[j][i]) &gt; fabs(a[q][i])) q = j; // 精度优化 } if(q == -1) continue; swap(a[p], a[q]), p++; for(int j = 1; j &lt;= n; j++){ // 消元成对角矩阵 if(fabs(a[j][i]) &lt; EPS || j == p - 1) continue; DB t = a[j][i] / a[p - 1][i]; for(int k = i; k &lt;= n + 1; k++) a[j][k] -= t * a[p - 1][k]; } } if(p &lt;= n){ // 不满秩则不可能解出所有变量 for(int i = p; i &lt;= n; i++) if(fabs(a[i][n + 1]) &gt; EPS) return puts(&quot;-1&quot;), 0; return puts(&quot;0&quot;), 0; } for(int i = 1; i &lt;= n; i++) // 解对角矩阵 printf(&quot;x%d=%.2lf\\n&quot;, i, a[i][n + 1] / a[i][i]); return 1;} 扩展欧几里得算法扩展欧几里得算法用于求解形如 $ax+by=c$ 的二元不定方程的整数解。根据裴蜀定理，该不定方程有解当且仅当 $(a,b)|c$。容易发现，若 $(x,y)$ 是解，则 $(x+kb, y-ka), k\\in \\mathbb{Z}$ 也是解。 123456789int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}void exgcd(int a, int &amp;x, int b, int &amp;y){ if(!b) return (void)(x = 1, y = 0); exgcd(b, x, a % b, y); int t = x; x = y, y = t - (a / b) * y;}bool solve(int a, int &amp;x, int b, int &amp;y, int c){ int g = gcd(a, b); if(c % g) return false; return exgcd(a, x, b, y), c /= g, x *= c, y *= c, true;} 类欧几里得算法 类欧几里得算法仅适用于处理斜率和截距非负的线段。当斜率为负时，需要通过对称变换使得斜率为正；当截距为负时，需要通过平移坐标轴使截距为正。 求解： $$f(n,A,B,C)=\\sum_{i=0}^n\\left\\lfloor \\frac{Ai+B}{C} \\right\\rfloor$$ 其中满足 $A,B,C \\ge 0$。它的几何意义是：在第一象限内，一条斜率和截距非负的线段下方的整点的数量。 实数版： 12345678#define LL long longLL s2(LL n) {return n * (n + 1) / 2;}LL f(LL n, LL a, LL b, LL c){ if(!a) return (b / c) * (n + 1); if(a &gt;= c || b &gt;= c) return s2(n) * (a / c) + (n + 1) * (b / c) + f(n, a % c, b % c, c); LL m = (a * n + b) / c; return n * m - f(m - 1, c, c - b - 1, a);} 取模版： 123456789#define LL long longconst int P = 998244353;int s2(LL n) {return (n * (n + 1) / 2) % P;}int f(LL n, LL a, LL b, LL c){ if(!a) return (b / c) * (n + 1) % P; if(a &gt;= c || b &gt;= c) return (s2(n) * (a / c) % P + (n + 1) * (b / c) % P + f(n, a % c, b % c, c)) % P; LL m = (a * n + b) / c; return (n * m % P - f(m - 1, c, c - b - 1, a) + P) % P;} BSGS1234567891011121314151617181920int mul(int x, int y, int P) {return (long long)x * y % P;}int qp(int a, int b, int P){ int r = 1; for(; b; a = mul(a, a, P), b &gt;&gt;= 1) if(b &amp; 1) r = mul(r, a, P); return r;}int B; map&lt;int, int&gt; vis;void bd(int a, int P){ B = ceil(sqrt(P)), vis.clear(); int t = qp(a, B, P); for(int i = 1, p = t; i &lt;= B; i++, p = mul(p, t, P)) if(!vis.count(p)) vis[p] = i * B;}int qu(int a, int b, int P){ int ans = 2e9; for(int i = 0, p = 1; i &lt; B; i++, p = mul(p, a, P)){ int cur = mul(b, p, P); if(vis.count(cur)) ans = min(ans, vis[cur] - i); } return ans &lt; int(2e9) ? ans : -1;} Cipolla’s Algorithm12345678910111213141516171819202122232425262728class COMP {public: int x, y;}; int w;COMP mk(int a, int b) {COMP o; o.x = a, o.y = b; return o;}COMP mul(COMP a, COMP b, int p){ COMP r; r.x = (1ll * a.x * b.x % p + 1ll * a.y * b.y % p * w % p) % p; r.y = (1ll * a.x * b.y % p + 1ll * a.y * b.x % p) % p; return r;}int qp(int a, int b, int p){ int r = 1; for(; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if(b &amp; 1) r = 1ll * r * a % p; return r;}COMP qp(COMP a, int b, int p){ COMP r = mk(1, 0); for(; b; b &gt;&gt;= 1, a = mul(a, a, p)) if(b &amp; 1) r = mul(r, a, p); return r;}bool ck(int n, int p) {return qp(n, (p - 1) / 2, p) == 1;}int sqrt(int n, int p){ n %= p; if(p == 2) return n; if(!n) return 0; if(!ck(n, p)) return -1; int a = rand() % p; while(!a || ck((1ll * a * a % p - n + p) % p, p)) a = rand() % p; COMP x = mk(a, 1); w = (1ll * a * a % p - n + p) % p; return qp(x, (p + 1) / 2, p).x;} 其它 以下内容请在本站搜索相应文章。 矩阵快速幂（矩阵加速递推） lucas（组合数取模） gcd（最大公约数） \\ exgcd（关于其求解不定方程的模板，请参阅CRT&amp;exCRT） 逆元 CRT &amp; exCRT（同余方程组） 3 多项式有关多项式的总结请参见多项式学习笔记。 FFT / 快速傅里叶变换12345678910111213141516171819202122232425262728293031323334353637class COMP{ public: LDB x, y; COMP operator + (const COMP &amp;o) const{ COMP r = *this; r.x += o.x, r.y += o.y; return r; } COMP operator - (const COMP &amp;o) const{ COMP r = *this; r.x -= o.x, r.y -= o.y; return r; } COMP operator * (const COMP &amp;o) const{ COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x; return r; }} ;COMP mk(LDB a, LDB b) {COMP o; o.x = a, o.y = b; return o;}int rev[CN &lt;&lt; 2];void cg(COMP t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]);}void fft(COMP t[], int n, int tp){ cg(t, n); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; COMP gn = mk(cos(2 * PI / (LDB)w), sin(2 * tp * PI / (LDB)w)); for(int i = 0; i &lt; n; i += w){ COMP g = mk(1, 0); for(int j = i; j &lt; i + l; j++){ COMP u = t[j], v = t[j + l] * g; t[j] = u + v, t[j + l] = u - v, g = g * gn; } } } if(tp ^ 1){ for(int i = 0; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n; }} NTT / 快速数论变换123456789101112131415161718192021int qp(LL a, LL b){ LL r = 1; for(; b; b &gt;&gt;= 1, a = a * a % P) if(b &amp; 1) r = r * a % P; return r;}void cg(int t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]);} void ntt(int t[], int n, int tp){ cg(t, n); int G = 3, iG = qp(G, P - 2); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; LL gn = qp(tp ? G : iG, (P - 1) / w), g = 1; for(int i = 0; i &lt; n; g = 1, i += w) for(int j = i; j &lt; i + l; j++){ LL u = t[j], v = g * t[j + l]; t[j] = (u + v) % P, t[j + l] = (u - v) % P, g = g * gn % P; } } for(int i = 0; i &lt; n; i++) t[i] = (t[i] + P) % P; if(!tp) {LL iv = qp(n, P - 2); for(int i = 0; i &lt; n; i++) t[i] = iv * t[i] % P;}} FWT / 快速沃尔什变换按位异或卷积 12345678910void fwt(int t[], int n, int tp){ for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; for(int i = 0; i &lt; n; i += w) for(int j = i; j &lt; i + l; j++){ int u = t[j], v = t[j + l]; t[j] = add(u, v), t[j + l] = add(u, P - v); if(!tp) t[j] = 1ll * t[j] * i2 % P, t[j + l] = 1ll * t[j + l] * i2 % P; } }} 按位或卷积 123456789void fwt(int t[], int n, int tp){ for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; for(int i = 0; i &lt; n; i += w) for(int j = i; j &lt; i + l; j++){ if(tp) t[j + l] = add(t[j + l], t[j]); else t[j + l] = add(t[j + l], P - t[j]); } }} 按位与卷积 123456789void fwt(int t[], int n, int tp){ for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; for(int i = 0; i &lt; n; i += w) for(int j = i; j &lt; i + l; j++){ if(tp) t[j] = add(t[j], t[j + l]); else t[j] = add(t[j], P - t[j + l]); } }} 求逆 / 指对运算相当于多项式全家桶了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int rev[CN &lt;&lt; 2];void cg(int t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]);}void ntt(int t[], int n, int tp){ cg(t, n); int og = 3, ig = invx(og); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1, gn = qp(tp ? og : ig, (P - 1) / w); for(int i = 0; i &lt; n; i += w){ int g = 1; for(int j = i; j &lt; i + l; j++){ int u = t[j], v = 1ll * t[j + l] * g % P; t[j] = add(u, v), t[j + l] = add(u, P - v), g = 1ll * g * gn % P; } } } if(!tp){ ig = invx(n); for(int i = 0; i &lt; n; i++) t[i] = 1ll * t[i] * ig % P; }}int c[CN &lt;&lt; 2];void inv(int a[], int b[], int n){ for(int i = 0; i &lt; (n &lt;&lt; 1); i++) b[i] = c[i] = 0; b[0] = invx(a[0]); for(int w = 2; w &lt; (n &lt;&lt; 1); w &lt;&lt;= 1){ for(int i = 0; i &lt; w; i++) c[i] = a[i]; ntt(b, w &lt;&lt; 1, 1), ntt(c, w &lt;&lt; 1, 1); for(int i = 0; i &lt; (w &lt;&lt; 1); i++) b[i] = 1ll * b[i] * add(2, P - (1ll * c[i] * b[i] % P)) % P; ntt(b, w &lt;&lt; 1, 0); for(int i = w; i &lt; (w &lt;&lt; 1); i++) b[i] = 0; } for(int i = n; i &lt; (n &lt;&lt; 1); i++) b[i] = 0;}int ia[CN &lt;&lt; 2];void ln(int a[], int b[], int n){ int N = 1; while(N &lt; (n &lt;&lt; 1)) N &lt;&lt;= 1; for(int i = 0; i &lt; N; i++) ia[i] = b[i] = 0; inv(a, ia, n); for(int i = 0; i &lt; N; i++) c[i] = 0; for(int i = 0; i &lt; n - 1; i++) c[i] = 1ll * (i + 1) * a[i + 1] % P; ntt(ia, N, 1), ntt(c, N, 1); for(int i = 0; i &lt; N; i++) c[i] = 1ll * c[i] * ia[i] % P; ntt(c, N, 0); for(int i = 1; i &lt; n; i++) b[i] = 1ll * c[i - 1] * invx(i) % P; b[0] = 0; for(int i = n; i &lt; (n &lt;&lt; 1); i++) b[i] = 0;}int lnb[CN &lt;&lt; 2];void exp(int a[], int b[], int n){ for(int i = 0; i &lt; (n &lt;&lt; 1); i++) b[i] = lnb[i] = 0; b[0] = 1; for(int w = 2; w &lt; (n &lt;&lt; 1); w &lt;&lt;= 1){ ln(b, lnb, w); for(int i = 0; i &lt; w; i++) lnb[i] = add(a[i], P - lnb[i]); lnb[0] = add(lnb[0], 1); ntt(b, w &lt;&lt; 1, 1), ntt(lnb, w &lt;&lt; 1, 1); for(int i = 0; i &lt; (w &lt;&lt; 1); i++) b[i] = 1ll * b[i] * lnb[i] % P; ntt(b, w &lt;&lt; 1, 0); for(int i = w; i &lt; (w &lt;&lt; 1); i++) b[i] = 0; } for(int i = n; i &lt; (n &lt;&lt; 1); i++) b[i] = 0;} 任意模数卷积拆系数fft，细节参考毛啸（myy）的论文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define LDB long doubleclass COMP{ public: LDB x, y; COMP operator + (const COMP &amp;o) const{ COMP r = *this; r.x += o.x, r.y += o.y; return r; } COMP operator - (const COMP &amp;o) const{ COMP r = *this; r.x -= o.x, r.y -= o.y; return r; } COMP operator * (const COMP &amp;o) const{ COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x; return r; }} ;COMP mk(LDB a, LDB b) {COMP o; o.x = a, o.y = b; return o;}COMP conj(COMP o) {o.y = -o.y; return o;}int rev[CN &lt;&lt; 2];void cg(COMP t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]);}void fft(COMP t[], int n, int tp){ cg(t, n); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; COMP gn = mk(cos(2 * PI / (LDB)w), sin(2 * tp * PI / (LDB)w)); for(int i = 0; i &lt; n; i += w){ COMP g = mk(1, 0); for(int j = i; j &lt; i + l; j++){ COMP u = t[j], v = t[j + l] * g; t[j] = u + v, t[j + l] = u - v, g = g * gn; } } } if(tp ^ 1){ for(int i = 0; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n; }}COMP p[CN &lt;&lt; 2], q[CN &lt;&lt; 2], x[CN &lt;&lt; 2], y[CN &lt;&lt; 2], z[CN &lt;&lt; 2], w[CN &lt;&lt; 2];void conv(int a[], int b[], int n){ // a = a * b int B = (1 &lt;&lt; 15) - 1, N = 1; while(N &lt; (n &lt;&lt; 1)) N &lt;&lt;= 1; for(int i = 0; i &lt; n; i++) p[i] = mk(a[i] &gt;&gt; 15, a[i] &amp; B); // k1 r1 for(int i = 0; i &lt; n; i++) q[i] = mk(b[i] &gt;&gt; 15, b[i] &amp; B); // k2 r2 fft(p, N, 1), fft(q, N, 1); for(int i = 0; i &lt; N; i++){ int j = (N - 1) &amp; (N - i); COMP k1, r1, k2, r2; k1 = (p[i] + conj(p[j])) * mk(0.5, 0); r1 = (p[i] - conj(p[j])) * mk(0, -0.5); k2 = (q[i] + conj(q[j])) * mk(0.5, 0); r2 = (q[i] - conj(q[j])) * mk(0, -0.5); x[i] = k1 * k2, y[i] = r1 * r2, z[i] = k1 * r2, w[i] = k2 * r1; } for(int i = 0; i &lt; N; i++) p[i] = x[i] + y[i] * mk(0, 1); for(int i = 0; i &lt; N; i++) q[i] = z[i] + w[i] * mk(0, 1); fft(p, N, -1), fft(q, N, -1); for(int i = 0; i &lt; N; i++){ LL X = (LL)(0.5 + p[i].x), Y = (LL)(0.5 + p[i].y), Z = (LL)(0.5 + q[i].x), W = (LL)(0.5 + q[i].y); X = (X % P + P) % P, Y = (Y % P + P) % P, Z = (Z % P + P) % P, W = add((W % P + P) % P, Z); a[i] = add((X &lt;&lt; 30) % P, add((W &lt;&lt; 15) % P, Y)); }} 4 字符串KMP有关 KMP 的总结请参见KMP学习笔记。 12345678910int k = 0; nxt[1] = 0, nxt[0] = -1;for(int i = 2; i &lt;= m; i++){ while(k ^ -1 &amp;&amp; t[k + 1] != t[i]) k = nxt[k]; nxt[i] = (k += 1);}k = 0;for(int i = 1; i &lt;= n; i++){ while(k ^ -1 &amp;&amp; t[k + 1] != s[i]) k = nxt[k]; if((k += 1) == m) printf(&quot;%d&quot;, i - m + 1), puts(&quot;&quot;);} ACAM / AC 自动机有关AC自动机的总结请参见KMP学习笔记。 12345678910111213141516171819202122const int CN = 1e6 + 6;class ACAM { public: int son[CN][26], fail[CN], e[CN], idx; queue&lt;int&gt; Q; void ins(char s[]){ // 建立 tire 结构 int u = 0; for(int i = 0; s[i]; i++){ if(!son[u][s[i] - 'a']) son[u][s[i] - 'a'] = ++idx; u = son[u][s[i] - 'a']; } e[u]++; } void bd(){ // 建立 fail 指针 for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(son[0][i]); while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int i = 0; i &lt; 26; i++){ if(son[u][i]) nxt[son[u][i]] = son[nxt[u]][i], Q.push(son[u][i]); else son[u][i] = son[nxt[u]][i]; } } }} D; SA / 后缀数组后缀数组通过将后缀按字典序排序来获得一些优美的性质。 1234567891011121314151617181920212223242526272829303132333435int rk[CN &lt;&lt; 1], sa[CN], ht[CN];/* rk[] 将 s[i:] 映射到排序后的排名 rk[i]，有类似于离散化的作用 */namespace SA{ int prk[CN &lt;&lt; 1], id[CN], px[CN], cnt[CN]; void sort(char a[], int n){ int m = max(n, 300); for(int i = 1; i &lt;= n; i++) rk[i] = a[i]; for(int i = 1; i &lt;= n; i++) cnt[ rk[i] ]++; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ rk[i] ]-- ] = i; // id[i] = i for(int w = 1; w &lt; n; w &lt;&lt;= 1){ memset(cnt, 0, sizeof(cnt)); for(int i = 1; i &lt;= n; i++) id[i] = sa[i]; for(int i = 1; i &lt;= n; i++) cnt[ px[i] = rk[id[i] + w] ]++; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memset(cnt, 0, sizeof(cnt)); for(int i = 1; i &lt;= n; i++) id[i] = sa[i]; for(int i = 1; i &lt;= n; i++) cnt[ px[i] = rk[id[i]] ]++; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = n; i; i--) sa[ cnt[ px[i] ]-- ] = id[i]; memcpy(prk, rk, sizeof(rk)), m = 0; for(int i = 1; i &lt;= n; i++) if(prk[sa[i]] == prk[sa[i - 1]] &amp;&amp; prk[sa[i] + w] == prk[sa[i - 1] + w]) rk[ sa[i] ] = m; else rk[ sa[i] ] = ++m; if(m == n) break; } for(int p = 0, i = 1; i &lt;= n; i++){ if(p) p--; while(a[i + p] == a[sa[rk[i] - 1] + p]) p++; ht[ rk[i] ] = p; } }} SAM / 后缀自动机后缀自动机可以将字符串的每一个子串双射在有向单词无环图（DAWG）上，从而获得一系列优美的性质。 1234567891011121314151617const int CN = 1e6 + 6;class SAM{ public: int len[CN &lt;&lt; 1], nxt[CN &lt;&lt; 1], last, sz; int son[CN &lt;&lt; 1][26]; SAM() {memset(son, 0, sizeof(son)), len[0] = 0, nxt[0] = -1, sz = 1, last = 0;} void extend(int c){ int u = sz++, p = last; last = u, len[u] = len[p] + 1; while(p != -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return (void)(nxt[u] = 0); int d = son[p][c]; if(len[d] == len[p] + 1) return (void)(nxt[u] = d); int v = sz++; len[v] = len[p] + 1, nxt[v] = nxt[d], nxt[u] = nxt[d] = v; memcpy(son[v], son[d], sizeof(son[d])); while(p != -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; }}; 广义后缀自动机先建立 Tire 树的结构，再在 Tire 树上建立 Parent 树和 DAWG 即可。注意在 SAM 的结构建立完成后，原有的 Tire 结构会被破坏。 12345678910111213141516171819202122232425262728293031323334class PAIR {public: int x, y;};PAIR mp(int x, int y) {PAIR o; o.x = x, o.y = y; return o;}class SAM { public: int nxt[CN &lt;&lt; 1], son[CN &lt;&lt; 1][26], len[CN &lt;&lt; 1], idx; queue&lt;PAIR&gt; Q; SAM() {nxt[0] = -1;} int et(int p, int c){ // 在 SAM 结构上的 p 节点后扩展出字符 c int u = son[p][c]; if(len[u]) return u; len[u] = len[p] + 1, p = nxt[p]; while(p ^ -1 &amp;&amp; !son[p][c]) son[p][c] = u, p = nxt[p]; if(p == -1) return u; int d = son[p][c]; if(len[d] == len[p] + 1) return nxt[u] = d, u; int v = ++idx; len[v] = len[p] + 1, nxt[v] = nxt[d], nxt[d] = nxt[u] = v; for(int i = 0; i &lt; 26; i++) if(len[son[d][i]]) son[v][i] = son[d][i]; while(p ^ -1 &amp;&amp; son[p][c] == d) son[p][c] = v, p = nxt[p]; return u; } void ins(char ch[]){ int u = 0; for(int i = 1; ch[i]; i++){ if(!son[u][ch[i] - 'a']) son[u][ch[i] - 'a'] = ++idx; u = son[u][ch[i] - 'a']; } } void bd(){ for(int i = 0; i &lt; 26; i++) if(son[0][i]) Q.push(mp(0, i)); while(!Q.empty()){ int u, x = Q.front().x, y = Q.front().y; Q.pop(); u = et(x, y); for(int i = 0; i &lt; 26; i++) if(son[u][i]) Q.push(mp(u, i)); } }} ; Manacher众所周知，Manacher 是一种优雅的暴力。 12345678910cin &gt;&gt; (s + 1); n = strlen(s + 1); c[0] = '$', c[1] = '#';for(int i = 1; i &lt;= n; i++) c[i &lt;&lt; 1] = s[i], c[i &lt;&lt; 1 | 1] = '#';n = n &lt;&lt; 1 | 1, c[n + 1] = '.';int k, i0 = 1; r[1] = 1;for(int i = 2; i &lt;= n; i++){ k = min(i0 + r[i0] - i, r[(i0 &lt;&lt; 1) - i]); while(c[i + k] == c[i - k]) k++; r[i] = k; if(i + r[i] &gt; i0 + r[i0]) i0 = i;} PAM / 回文自动机12345678910111213141516int n; char ch[CN];class PAM{ public: int len[CN], nxt[CN], son[CN][26], idx, lst; PAM() {len[0] = nxt[0] = -1, idx = lst = 1;} void et(int r){ int p = lst; while(ch[r - len[p] - 1] ^ ch[r]) p = nxt[p]; if(!son[p][ch[r] - 'a']){ son[p][ch[r] - 'a'] = ++idx, len[idx] = len[p] + 2; int pp = nxt[p]; while(pp ^ -1 &amp;&amp; ch[r - len[pp] - 1] ^ ch[r]) pp = nxt[pp]; nxt[idx] = pp ^ -1 ? son[pp][ch[r] - 'a'] : 1; } lst = son[p][ch[r] - 'a']; }} ; Lyndon Factorize &amp; Runs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int P = 191011109, B = 39; int pB[CN], ha[CN];int get(int l, int r) {return add(ha[r], P - (1ll * ha[l - 1] * pB[r - l + 1] % P));}int LCP(int l1, int r1, int l2, int r2){ if(ch[l1] != ch[l2]) return 0; int l = 1, r = min(r1 - l1 + 1, r2 - l2 + 1); while(l &lt; r){ int mid = (l + r + 1) &gt;&gt; 1; if(get(l1, l1 + mid - 1) == get(l2, l2 + mid - 1)) l = mid; else r = mid - 1; } return l;}int LCS(int l1, int r1, int l2, int r2){ if(ch[r1] != ch[r2]) return 0; int l = 1, r = min(r1 - l1 + 1, r2 - l2 + 1); while(l &lt; r){ int mid = (l + r + 1) &gt;&gt; 1; if(get(r1 - mid + 1, r1) == get(r2 - mid + 1, r2)) l = mid; else r = mid - 1; } return l;}bool le(int l1, int r1, int l2, int r2){ if(l1 == l2) return r1 &lt; r2; int l = LCP(l1, r1, l2, r2); if(l1 + l &gt; r1 || l2 + l &gt; r2) return r1 - l1 &lt; r2 - l2; return ch[l1 + l] &lt; ch[l2 + l];}class PAIR{ public: int l, r, p; bool operator &lt; (const PAIR &amp;o) const{ return l ^ o.l ? l &lt; o.l : (r ^ o.r ? p &lt; o.p : r &lt; o.r); } bool operator == (const PAIR &amp;o) const{ return l == o.l &amp;&amp; r == o.r; }} ;PAIR mp(int a, int b, int c) {PAIR o; o.l = a, o.r = b, o.p = c; return o;}vector&lt;PAIR&gt; runs; int stk[CN], ed[CN], top;void lyndon(){ top = 0; for(int i = n; i; i--){ stk[++top] = i; while(top &gt; 1 &amp;&amp; le(i, stk[top], stk[top] + 1, stk[top - 1])) top--; ed[i] = stk[top]; } for(int i = 1; i &lt;= n; i++){ int j = ed[i], lcs = LCS(1, i - 1, 1, j), lcp = LCP(i, n, j + 1, n), l, r; l = i - lcs, r = j + lcp; if((r - l + 1) / (j - i + 1) &gt; 1) runs.pb(mp(l, r, j - i + 1)); }}void bd(){ lyndon(); for(int i = 1; i &lt;= n; i++) ch[i] = 'a' + 'z' - ch[i]; lyndon(), sort(runs.begin(), runs.end()); int len = unique(runs.begin(), runs.end()) - runs.begin();}","link":"/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/"},{"title":"「杂题选做」八月口胡合集","text":"众所周知，做题的关键在于口胡出解法，而我还是什么都不会…… 本篇 Blog 多以口胡为主，杂题居多。 1 Hunger Game 有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。不能操作的输，求先手必胜还是后手必胜。$1\\le N\\le 1e5, 0\\le a[i]&lt;10^9$ Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\\oplus a_2\\oplus … \\oplus a_n = 0$。 回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。 因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。 2 Minimum Value of Equation 给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\\sum |k[i]x+b[i]|$，其中$1\\le i\\le j$。对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。$1\\le n\\le 10^5 , |k[i]|\\le 1000$ 提一下公因式变成 $\\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。 3 DFS Count 给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。$n \\le 13$ 直接搜？？？（雾设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：$$ f[v,T_v \\And S]·f[u,S-(T_v \\And S)] \\to f[u, S] | (u,v)\\in E$$其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。 4 XOR Product 给定序列 $a_1,…,a_n$ ，求：$$ \\sum\\limits_{i&lt;j&lt;k}(a_i\\oplus a_j)·(a_j \\oplus a_k) $$ 把 $j$ 提出来，拆一下柿子：$$ \\sum\\limits_j(\\sum\\limits_{i&lt;j}a_i\\oplus a_j)(\\sum\\limits_{j&lt;k}a_j \\oplus a_k) $$考虑求 $\\sum\\limits_{i&lt;j}a_i\\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。预处理是 $O(n\\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\\log)$ 的，最后统计答案也是 $O(n)$ 的。 5 SUMXOR 给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：$$ \\bigoplus\\limits_{i,j}a_i+b_j $$ 依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\\sum[(a_i+b_j)\\text{ mod } 2^{w+1} \\ge 2^w] \\text{ mod }2$。令 $a_i\\gets a_i\\text{ mod }2^{w+1},b_i\\gets b_i\\text{ mod }2^{w+1} $，有两种情况： $a_i + b_j \\ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\\ge 2^w$，移项得 $a_i+b_j\\ge 2^w+2^{w+1}$ $a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\\le a_i+b_j&lt; 2^{w+1}$ 于是转化成序列上的查询问题，Two-Pointers 扫即可。 6 The Hanged Man 有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。$n\\le 50, m\\le 5000$ $O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。 资料：乱搞，重链剖分 附一个 $O(nm^2)$ 的 DP： 12345678910111213141516int n, m, vi[CN], wi[CN], f[CN][5005][2];void dfs(int u, int p){ for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v ^ p) dfs(v, u); } f[u][ vi[u] ][1] = wi[u]; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(v == p) continue; for(int V = m; V; V--) for(int Vp = 0; Vp &lt;= V; Vp++){ if(V - Vp &gt;= vi[u]) f[u][V][1] = max(f[u][V][1], f[v][Vp][0] + f[u][V - Vp][1]); f[u][V][0] = max(f[u][V][0], max(f[v][Vp][0], f[v][Vp][1]) + f[u][V - Vp][0]); } }} 7 Anton and Ira 给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。$n\\le 1000$ 设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\\sum|i-to[i]|$，从而 $s=\\sum|i-to[i]|/2$。 8 Increasing Shortest Path 有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？$T$组数据（$T\\le 100$）。$n ≤ 150, m, q ≤ 5000.$ $n$ 比较小，那么考虑 DP。边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。 设 $f[u,v,m]$ 表示 $u\\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：$$ f[s,u,k]+w\\to f[s,v,k+1] $$这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。 复杂度 $O(T(m\\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。 代码： 12345678sort(G + 1, G + m + 1), memset(f, 0x3f, sizeof(f));for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt;= n; k++) f[i][i][k] = 0; for(int s = 1; s &lt;= n; s++) for(int i = 1; i &lt;= m; i++){ int u = G[i].u, v = G[i].v, w = G[i].w; for(int k = 0; k &lt; n; k++) f[s][v][k + 1] = min(f[s][u][k] + w, f[s][v][k + 1]); } 9 Increasing Number 一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。$n ≤ 10^{18}, m ≤ 500.$ 显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\\times 10^n+k)\\text{ mod }m]\\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\\log n)$ 的，看上去也不太行。 一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\\sum\\limits_{i=1}^9\\dbinom{i+n-1}{n-1}=\\dbinom{n+9}{n}-1$。 10 Little Elephant and Colored Coins 给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。$n ≤ 30, v_i ≤ 2\\times 10^5,s\\le 10^{18}$ 对于这种题目，一般来说技巧是取 $w=\\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\\log w)$ 转移状态。 对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\\gets f[i+1,(k+v_i)\\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。 给出大致的代码： 12345678910111213141516171819202122n = read();for(int i = 1; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];memset(f, 0x3f, sizeof(f)), f[0][0] = 0;for(int i = 1; i &lt;= n; i++) for(int j = n - 1; j + 1; j--) for(int k = 0; k &lt; w; k++) f[j + 1][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + 1][(k + v[i]) % w]);for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) for(int k = 0; k &lt; w; k++) f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]); q = read();while(q--){ int s = read(), sw = s % w; bool flag = false; for(int i = n; i &amp;&amp; !flag; i--) if(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) printf(&quot;%d&quot;, i), puts(&quot;&quot;), flag = true; if(!flag) puts(&quot;-1&quot;);} 11 Balance 一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。$n\\le 10^4, k\\le 10$ 整数划分问题。容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：$$ \\begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \\text{ }\\text{ }| \\text{ }\\text{ }i\\ge n + 1 \\end{aligned}$$复杂度 $O(nk^2)$。 代码： 12345678910memset(f, 0, sizeof(f)), N = 0;for(int i = n - K + 1; i &lt;= n; i++) N += i;for(int i = 1; i &lt;= n; i++) f[i][1] = 1;for(int k = 2; k &lt;= K; k++) for(int i = 1; i &lt;= N; i++) f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - 1]) % p : 0, f[i][k] = i &gt; n ? (f[i][k] - f[i - n - 1][k - 1] + p) % p : f[i][k];int ans = 0;for(int w = 1; w &lt;= N; w++) for(int j = 1; j &lt; K; j++) ans = (1ll * f[w][j] * f[w][K - j] % p + ans) % p;for(int w = 1; w &lt;= N; w++) for(int j = 1; j &lt; K - 1; j++) ans = (1ll * f[w][j] * f[w][K - j - 1] % p + ans) % p; 12 Arrangement Count 求有多少个排列 $A\\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。$n\\le 1000$ 设 $f[i,j,0/1]$ 表示考虑 $A\\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移： $f[i,j,0]·j\\to f[i+1,j-1,0]$ $f[i,j,0]·2\\to f[i+1, j + 1, 1], f[i,j,1]·2\\to f[i+1, j, 1]$ $f[i,j,0/1]·(i-j-1)\\to f[i+1,j,0]$ 复杂度 $O(n^2)$。 13 Cut Tree $n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。$n \\le 10^5$ 考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。 但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。 于是可以做到不漏算答案，时间复杂度 $O(n)$。 14 Number Game Alice 和 Bob 又双叒叕在玩游戏。Bob 每次会想一个 $0\\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。$n \\le 10^5, a_i\\le 9$ 本人只会 $O(n^3)$ 的辣鸡 DP…… 设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：$$ f[l,r]=\\min\\limits_k a_k+ \\max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。 15 Distributs 小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。$n,m \\le 1000$ 容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：$$ \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k}\\sum\\limits_j \\dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。 16 Solutions of the Equation 有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。$n \\le 1000$ 容斥简单题，如果不考虑限制答案是 $\\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：$$ \\sum\\limits_{k=0}^n (-1)^k \\dbinom{n}{k}\\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。 17 Bohater 在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。$1≤n,z≤10^5，0≤d_i,a_i≤10^5$ 考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。 复杂度 $O(n\\log n)$。 18 Swap Space 你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。求最小的额外储存设备容量。$1≤n≤10^6,1≤a_i,b_i≤10^9$ 考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为： 给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。 这就是上题模型，复杂度 $O(n\\log^2n)$，看上去有点卡。 实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\\log n)$。 19 Maximum Value of Linear Function 现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。$n\\le 10^6$ 容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。 这个题也可以类比一下「国王游戏」那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\\Pi/b_i+(a_i·\\Pi)/b_j &gt; \\Pi/b_j+(a_j·\\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。 20 Kuglarz $n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。问最少花费多少代价才能求出每个杯子中是否有小球。$n\\le 1000$ 看上去很像 DP，但我的做法假掉了……建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。时间复杂度 $O(n^2)$。 21 OSU! 一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。求该 01 串的价值的期望。$n\\le 10^5$ 考察期望的定义，和应用用贡献法计算每一位的价值期望。设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：$$ \\begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \\newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \\end{aligned}$$ 于是可以做到 $O(n)$。注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。 代码： 123for(int i = 1; i &lt;= n; i++) l[i] = a[i] * (l[i - 1] + 1);for(int i = 1; i &lt;= n; i++) l2[i] = a[i] * (l2[i - 1] + 2 * l[i - 1] + 1);for(int i = 1; i &lt;= n; i++) f[i] = f[i - 1] + a[i] * (3 * l2[i - 1] + 3 * l[i - 1] + 1);","link":"/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"},{"title":"同余数论乱讲","text":"对最近学的数论知识做一些总结，内容比较杂乱，包括但不限于中国剩余定理、欧拉定理、阶和原根、二次剩余。 想不到一写又是 4k 字，害怕害怕…… 线性同余方程先从不定方程开始扯。给出一个形式化的定义：我们称关于 $x,y$ 的，形如 $ax+by=c$ 的方程为二元一次不定方程。 （裴蜀定理）关于 $x,y$ 的，形如 $ax+by=(a,b)$ 的不定方程总存在整数解。 可以简单推广出一个普遍性的结论：对于不定方程 $ax+by=c$，它存在整数解的充要条件是 $(a,b)|c$，证明如下： （充分性）$ax+by=c\\Rightarrow ax/(a,b)+by/(a,b)=c/(a,b)$ （必要性）根据裴蜀定理，可以构造 $x’,y’$ 使得 $ax’+by’=(a,b)$，那么有 $x=cx’/(a,b),y=cy’/(a,b)$ 显然一个线性同余方程 $ax\\equiv b\\text{ }(\\text{mod }p)$ 可以看作不定方程 $ax+tp=b$，其中 $x,t$ 是未知量。根据上面的推导，可以得到该方程存在解的充要条件是 $(a,p)|b$。注意这个条件的本质实际上是 $(a,p)|(b,p)$。 这个条件启发我们，如果 $ax\\equiv b\\text{ }(\\text{mod }p)$有解，那么它可以被改写作 $ax/(a,p)\\equiv b/(a,p)\\text{ }(\\text{mod } p/(a,p))$。 逆元如果存在一个 $x\\in \\mathbb F_p$，使得 $ax\\equiv 1\\text{ }(\\text{mod }p)$，那么称 $x$ 是 $a$ 在 $\\mathbb F_p$ 下的逆元，记作 $x= a^{-1}\\bmod p$。 根据上面的推导，$a$ 在 $\\mathbb F_p$ 下的逆元存在当且仅当 $(a,p)=1$，即 $a,p$ 互质。 考虑模合数的剩余系下，只有一些数字存在逆元，因此在 OI 中，需要求模合数的逆元的情况比较少见。这一类情况需要用到扩展欧几里得算法，相关资料可以在博客中找到。 对于模质数的逆元，会在下面进一步讨论。 中国剩余定理中国剩余定理给出了一组线性同余方程的解在某种意义下的近似，其中“某种意义”特指对所有方程的模数的 LCM 取模。 形式化地，对于 $n$ 条关于 $x$ 的线性同余方程，第 $i$ 条形如 $a_ix\\equiv b_i\\text{ }(\\text{mod }p_i)$，那么中国剩余定理给出了如下求解 $x$ 的方法： 令 $P=\\prod\\limits_{i=1}^n p_i$，记 $k_i=P/p_i,k^{-1}_i=k_i^{-1}\\bmod p_i$，计算 $x=\\prod\\limits_{i=1}^n k_ik^{-1}_i\\bmod P$。需要特别注意的是，这里模数的变化是很关键的。 欧拉定理欧拉定理指出，如果 $(a,p)=1$，那么有： $$a^{\\varphi(p)}=1\\text{ }(\\text{mod }p)$$ 特别的，如果 $p$ 是质数，那么 $\\varphi(p)=p-1$，有 $a^{p-1}=1\\text{ }(\\text{mod }p)$，这样就得到了费马小定理。这可以用来求逆元：$a·a^{p-2}\\equiv 1\\text{ }(\\text{mod }p)$。 通过欧拉定理可以简单得到，如果 $(a,p)=1$，那么对任意 $n\\in \\mathbb N$，存在： $$a^n\\equiv a^{n\\bmod \\varphi(p)}\\text{ }(\\text{mod }p)$$ 这指出了在剩余系下，与模数互质的数的幂次是成环的。这个环将会在下面对阶和原根的讨论中反复出现。 注意上面的柿子还有一个推广形式，即对 $(a,p)&gt;1,n&gt;\\varphi(p),n\\in \\mathbb N$，存在： $$a^n\\equiv a^{n\\bmod \\varphi(p)+\\varphi(p)}\\text{ }(\\text{mod }p)$$ 这意味着只有当 $n$ 足够大的时候，它才会进入一个环。 阶和原根 （阶）对于 $(a,p)=1$，必然存在至少一个 $c\\in \\mathbb N^+$，使得 $a^c\\equiv 1\\text{ }(\\text{mod }p)$。我们称满足条件的最小的 $c$ 为 $a$ 模 $p$ 的阶，记作 $c=\\text{ord}_pa$。 考虑阶的实际意义：欧拉定理指出了一个与模数互质的数的幂次会成环，并且给出了环长的上界，而阶更精确地确定了这个环长是多少。 （原根）对于 $g\\in \\mathbb F_p$，如果 $\\text{ord}_pg=\\varphi(p)$，则称 $g$ 是模 $p$ 的原根。 原根的特殊之处在于，原根的环是该剩余系下一个数的幂次可以得到的最大的环，原根的幂次可以填充整个简化剩余系。或者说我们可以用原根定义离散对数，即设 $\\log_g x=t$，其中 $t\\in \\mathbb F_p$，是唯一的满足 $g^t\\equiv x\\text{ }(\\text{mod }p)$ 的数。 注意原根不能填充整个剩余系。这意味着对于非质数模数，即便是正数的离散对数也可能不存在。 更加深刻的取理解阶和原根，可以发现一个数 $a$ 的幂次形成的环，实际上就是原根以 $(\\log a,\\varphi(p))$ 为步长走过的环上的点。形式化的，对于 $(a,p)=1$，$a^n\\bmod p,n\\in\\mathbb N$ 的所有取值是： $$g^{kt},t=(\\log a,\\varphi(p)),k\\in[0, \\text{ord}_pa)$$ 也可以简单归纳出阶的一些性质： $$\\begin{aligned} &amp;\\text{ord}_pa|\\varphi(p)\\newline&amp;\\text{ord}_pa^k=\\dfrac{\\text{ord}_pa}{(\\text{ord}_pa,k)} \\end{aligned}$$ 计算阶和原根注意到 $\\text{ord}_pa|\\varphi(p)$，因此直接暴力枚举 $\\varphi(p)$ 的因数，就可以做到 $O(\\sqrt p)-O(d(\\varphi(p)))$ 计算阶，实现的好就是 $O(p^{1/4})-O(d(\\varphi(p)))$。 可以证明，一个数 $m$ 存在原根的充要条件是 $m=2,4,p^\\alpha,2p^\\alpha$，其中 $p$ 是奇素数，$\\alpha\\in \\mathbb N^+$ 。 可以证明，如果一个数存在原根，那么这个数的最小原根是 $m^{1/4}$ 级别。 原根有着这样的一个判定方法，即 $g$ 是原根等价于 $\\forall i,g^{\\varphi(p)/\\rho_i}\\not\\equiv 1\\text{ }(\\text{mod }p)$，其中 $\\rho_i$ 是 $\\varphi(p)$ 的质因子。 因此直接暴力枚举判断就可以找到最小原根，期望复杂度 $O(p^{1/4}\\log^2 p)$。 可以证明，设 $g$ 是 $p$ 的一个原根，那么集合 $\\begin{Bmatrix}g^s\\bmod p\\text{ | }s\\in\\mathbb N,(s,\\varphi(p))=1\\end{Bmatrix}$ 给出了 $p$ 的所有原根。 BSGS北上广深（Baby Step Giant Step, BSGS）算法是一个可以在 $O(\\sqrt p)$ 的时间内，求解模任意 $p\\in \\mathbb N^+$ 的离散对数的算法。形式化地，即解这样一个方程： $$a^x\\equiv b\\text{ }(\\text{mod }p)$$ 可以设阀值 $B$，令 $x=kB-r$，有 $(a^B)^k\\equiv ba^r\\text{ }(\\text{mod }p)$。我们用哈希表预处理 $a^{kB}$ 的所有可能取值以及对应的 $k$，那么只需要枚举 $r$，查找一个 $k$ 即可。 注意 $a^{kB}\\equiv ba^r\\text{ }(\\text{mod }p)$ 是 $a^{kB-r}\\equiv b(\\text{mod }p)$ 的必要不充分条件，因此还需要检验一下得到的解是否可行。特别地，当 $p$ 是质数时，转化有充分性，可以不进行特判。 注意 $a^{kB}\\to k$ 是单射，因此理论上需要记录前两个值，但是毛估一下会发现只记录一个值的错误概率很低。 欧拉定理给出了 $x$ 的上界即 $2\\varphi(p)$，取 $B=\\lceil\\sqrt {2p}\\rceil$，可以得到最优复杂度 $O(\\sqrt p)$。 代码可以在模板梳理中找到。 二次剩余 （二次剩余）对于一个数 $n$ 满足 $p\\nmid n$，如果存在一个 $x\\in \\mathbb F_p$ 使得 $x^2\\equiv n\\text{ }(\\text{mod }p)$，那么称 $n$ 是模 $p$ 的二次剩余；否则，则称 $n$ 是模 $p$ 的非二次剩余。 可以证明，如果不考虑 $0$，那么一个数的二次剩余和非二次剩余各有恰 $\\dfrac{p-1}{2}$ 个。 （勒让德符号）定义一个数 $n$ 模 $p$ 的勒让德符号 $(\\frac{n}{p})$ 是一个在 $-1,0,1$ 之间的整数。定义当 $p|n$ 时 $(\\frac{n}{p})=0$，当 $n$ 是模 $p$ 的二次剩余时 $(\\frac{n}{p})=1$，否则 $(\\frac{n}{p})=-1$。 （欧拉判别准则）$\\left(\\dfrac{n}{p}\\right)\\equiv n^{(p-1)/2}\\text{ }(\\text{mod }p)$ 以上三条给出了二次剩余的定义以及判定方法。如果以及判定了 $n$ 是二次剩余，这意味着 $x^2=n\\text{ }(\\text{mod }p)$ 将会有解，接下来我们讨论解这个同余二次方程。 首先考虑解的数量。假设存在任意多的解，取其中不相等的两个 $x_0,x_1$，那么有： $$\\begin{aligned} &amp;x_0^2\\equiv x_1^2 &amp;\\text{ }(\\text{mod }p)\\newline \\Leftrightarrow &amp;(x_0-x_1)(x_0+x_1)\\equiv0&amp;\\text{ }(\\text{mod }p)\\end{aligned}$$ 考虑 $x_0\\neq x_1$，那么必然有 $x_0+x_1\\equiv 0\\text{ }(\\text{mod }p)$，也就是说互不相同的两个解必然互为相反数。这同时可以说明，这个方程至多有两个解。 Cipolla 算法可以在模质数的前提下求出其中的一个解。 Cipolla’s Algorithm设 $p$ 是一个质数，考虑找到一个数 $a$，使得 $a^2-n$ 是模 $p$ 的二次非剩余。由于随机一个数有 $1/2$ 的概率是二次非剩余，那么只需要期望两次操作就可以找到。 定义虚数单位 $\\text i$ 为满足 $\\text i^2=a^2-n$ 的数，在模意义下建立一个类复数域，有 $x\\equiv (a+\\text i)^{(p+1)/2}\\text{ }(\\text{mod }p)$，证明如下： $$\\begin{aligned} (a+\\text i)^{(p+1)/2}&amp;\\equiv [(a+\\text i)(a+\\text i)^p]^{1/2} &amp;\\text{ }(\\text{mod }p)\\newline &amp;\\equiv [(a+\\text i)(a^p+\\text i^p)]^{1/2}&amp;\\text{ }(\\text{mod }p)\\newline &amp;\\equiv [(a+\\text i)(a-\\text i)]^{1/2}&amp;\\text{ }(\\text{mod }p)\\newline &amp;\\equiv (a^2-\\text i^2)^{1/2}\\equiv n^{1/2}&amp;\\text{ }(\\text{mod }p)\\end{aligned}$$ 这是因为有 $a^p\\equiv a·a^{p-1}\\equiv a\\text{ }(\\text{mod }p)$，并且 $i^p\\equiv i(i^2)^{(p-1)/2}\\equiv i(a^2-n)^{(p-1)/2}\\equiv -i\\text{ }(\\text{mod }p)$，并且 $(a+b)^p\\equiv a^p+b^p\\text{ }(\\text{mod }p)$。 那么只需要实现一个复数类，做快速幂即可，复杂度 $O(\\log p)$。代码可以在模板梳理中找到。 高次剩余在模质数的意义下，求解形如 $x^a\\equiv n\\text{ }(\\text{mod }p)$ 有一类简单且普适性的 $O(\\sqrt p)$ 求解方法。具体如下： 因为是模质数，所以简化剩余系下只有 $0$ 没有被覆盖。如果 $x=0$，那么已经做完了，否则 $x$ 的离散对数一定存在。此时可以认为 $n\\neq 0$，对两边同时取离散对数，我们可以得到： $$a\\log x\\equiv \\log n\\text{ }(\\text{mod }\\varphi(p))$$ 实则是一个不定方程，可以直接求解。因此复杂度只有计算离散对数的 $O(\\sqrt p)$。如果 $p$ 很小，也可以直接预处理离散对数，那么回答的复杂度应该不会高于 $\\log p$。 一道栗题 给定一个数字 $n$，判断其是否为完全平方数。 $n\\le 10^{1000000}$ 直接大力高精度开根，存在 $O(n\\log n)$ 的牛顿迭代做法，但是细节太多。比较容易理解的是 $O(n\\log^2 n)$ 做法，即朴素牛迭，不过要借助 $O(n\\log n)$ 高精度整除的科技。这都不太好做。 考虑随机一个质数 $P$，如果 $P\\nmid n$，那么 $n$ 是完全平方等价于 $n$ 是模 $p$ 的二次剩余，使用欧拉准则判断即可。由于不一定满足 $P\\nmid n$，所以多随机几个即可。 又一道栗题 给定一个长度为 $n$ 的序列 $\\left\\langle a\\right\\rangle$。有 $q$ 次操作，分为两种类型： 修改操作每次给定区间 $[l,r]$，令这一段区间内的每个元素执行操作 $a’_i\\gets c^{a_i}\\bmod p$，其中 $c,p$ 在所有操作开始前给出。 询问操作给出区间 $[l,r]$，你需要求出 $[l,r]$ 内所有 $a_i$ 的和对 $p$ 取模的值。 $n,q\\le 5\\times 10^4, p\\le 10^8$ 一般来说这种奇怪数据结构题都可以直接做。 考虑构造一个序列，满足 $b_0=a_i,b_j=c^{b_{j-1}}(j&gt;0)$。根据欧拉定理，第 $j$ 项的值可以这样算出来：计算 $d_0=b_0\\bmod\\varphi_j(p)$，然后带入第一项计算 $d_1=c^{d_0}\\bmod \\varphi_{j-1}(p)$，然后带入第二项计算 $d_2=c^{d_1}\\bmod \\varphi_{j-2}(p)$… 其中 $\\varphi_1(p)=\\varphi(p),\\varphi_j(p)=\\varphi(\\varphi_{j-1}(p))(j&gt;1)$。容易发现当 $j$ 达到 $\\log p$ 的级别的时候，会存在一个分界点，使得从这里往后的 $\\varphi_j(p)$ 总等于 $1$。 因此只需要大力维护连续段即可，考虑到快速幂的复杂度，用线段树维护就是 $O(n\\log n\\log ^2p)$，并查集的话就是 $O(n\\alpha(n)\\log^2p)$。这里我用线段树实现的，常数大的一匹… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define lc k &lt;&lt; 1#define rc k &lt;&lt; 1 | 1const int CN = 5e4 + 10;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}void write(int x) {if(x &gt; 9) write(x / 10); putchar('0' + x % 10);}int P, d[101]; bool flag;int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int qp(int a, int b, int p){ int r = 1; bool fla = a &gt;= p; a %= p; for(; b; b &gt;&gt;= 1){ if(b &amp; 1){ flag |= fla; if(1ll * r * a &gt;= p) flag |= 1; r = 1ll * r * a % p; } if(1ll * a * a &gt;= p) fla |= 1; a = 1ll * a * a % p; } return r;}int n, q, c, a[CN], len[CN], fac[50];int varphi(int x){ fac[0] = 0; int t = x; for(int d = 2; d * d &lt;= x; d++){ if(t % d) continue; fac[++fac[0]] = d; while(!(t % d)) t /= d; } if(t ^ 1) fac[++fac[0]] = t; int res = x; for(int i = 1; i &lt;= fac[0]; i++) res = res / fac[i] * (fac[i] - 1); return res;}int sum[CN &lt;&lt; 2], cnt[CN &lt;&lt; 2]; void pu(int k) {sum[k] = add(sum[lc], sum[rc]), cnt[k] = cnt[lc] + cnt[rc];}void bd(int l, int r, int k){ if(l == r) return (void)(cnt[k] = 1, sum[k] = a[l]); int m = (l + r) &gt;&gt; 1; bd(l, m, lc), bd(m + 1, r, rc), pu(k);}void upd(int l, int r, int k){ if(!cnt[k]) return; if(l == r){ len[l]++; if(len[l] == d[0]) cnt[k]--; int alp = a[l] % d[len[l]]; flag = a[l] &gt;= d[len[l]]; for(int p = len[l] - 1; p; p--){ if(!flag) alp = qp(c, alp, d[p]); else alp = qp(c, alp + d[p + 1], d[p]); } sum[k] = alp; return; } int m = (l + r) &gt;&gt; 1; upd(l, m, lc), upd(m + 1, r, rc), pu(k);}void md(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return upd(l, r, k); int m = (l + r) &gt;&gt; 1; if(s &lt;= m) md(l, m, lc, s, t); if(m &lt; t) md(m + 1, r, rc, s, t); pu(k);}int qu(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return sum[k]; int m = (l + r) &gt;&gt; 1, res = 0; if(s &lt;= m) res = add(res, qu(l, m, lc, s, t)); if(m &lt; t) res = add(res, qu(m + 1, r, rc, s, t)); return res;}int main(){ n = read(), q = read(), P = read(), c = read(); d[d[0] = 1] = P; while(d[d[0]] ^ 1) d[d[0] + 1] = varphi(d[d[0]]), d[0]++; d[++d[0]] = 1; for(int i = 1; i &lt;= n; i++) len[i] = 1, a[i] = read(); bd(1, n, 1); while(q--){ int tp = read(), l = read(), r = read(); if(tp) write(qu(1, n, 1, l, r)), puts(&quot;&quot;); else md(1, n, 1, l, r); } return 0;} 双一道栗题 有 $n$ 个互不相等的整数 $a_1, a_2, \\cdots, a_n$，系统会从中随机选择若干个，而你需要确定所有选出的数字。你可以进行若干次询问，每次给出一个 $k$。如果 $a_k$ 被选择，那么系统会将所有选出的数中，能被表示成 $a_k^m\\bmod p\\text{ }(k\\in\\mathbb N^+)$ 的形式的数字告诉你。如果系统的每次选择是等概率选一个集合，请你求出你的最小询问次数的期望，对 $998244353$ 取模。 $n\\le 5000, 0&lt;a_i&lt;p\\le 10^8$$\\text{Subtask1(50pts) : } p \\text{ is prime}$$\\text{Subtask2(50pts) : } p=q^k, \\text{ where }q\\text{ is prime}$ 显然这是计数题不是期望题，考虑简单转化之后，只需要求所有情况下最小操作次数的和。 用 $u\\to v$ 的一条边表示 $u$ 经过一通操作之后可以变成 $v$，那么得到一张可能有环的有向图。不妨钦点对于一个等价集合，只用标号最小的那个算一次贡献，那么图上的环没有了。枚举一个点算贡献，设 $cnt$ 表示图上能到达这个点的点的数量（包括自身），那么这部分贡献就是 $2^{n-cnt}$。 考虑暴力枚举 $i,j$，如何判断一条边 $i\\to j$ 存在。不考虑 $0$，由于 $p$ 是质数，那么意味着剩余系下每个数的阶都存在，离散对数也存在。那么柿子变成 $m\\log a_i\\equiv a_j\\text{ }(\\text{mod }\\varphi(p))$，有解等价于 $(\\log a_i,\\varphi(p))|\\log a_j$，等价于 $(\\log a_i,\\varphi(p))|(\\log a_j, \\varphi(p))$。考虑 $\\log a_i$ 实际上描述了 $a_i$ 每次在原根形成的环上走过的步长，那么有 $(\\log a_i,\\varphi(p))\\text{ord}_p a_i=\\varphi(p)$，柿子又变成 $\\text{ord}_p a_j|\\text{ord}_p a_i$。 那么只需要 $O(\\sqrt p)$ 预处理因子，求阶就是 $O(d(\\varphi(p))\\log p)$ 的，这样就有复杂度 $O(n^2+nd(\\varphi(p))\\log p)$。 考虑如果 $p=q^k$，这意味着不在简化剩余系里面的数字是不存在阶和离散对数一说的。考虑把数分解成 $a_i=q^{\\alpha_i}\\beta_i$，然后分类讨论： $\\alpha_i=\\alpha_j=0$，变成上面的情况； $\\alpha_i,\\alpha_j &gt; 0$，那么可以直接解出来 $m=\\alpha_j/\\alpha_i$，快速幂判断即可； 否则，由于 $q$ 这一个质因子无论如何不会出现或者消失，那么总是不行的。 那么这样就有复杂度 $O(n^2\\log p)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int P = 998244353;const int CN = 5050;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int n, p, q = 1, K, fac[CN], ord[CN], A[CN], a[CN], b[CN], ans, p2[CN]; // A[i] = a[i]q^b[i]int qp(int a, int b){ if(b &lt; 0) return 1; int r = 1; for(; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if(b &amp; 1) r = 1ll * r * a % p; return r;}void div(int n){ for(int d = 1; d * d &lt;= n; d++){ if(n % d) continue; fac[++fac[0]] = d, fac[++fac[0]] = n / d; } sort(fac + 1, fac + fac[0] + 1), fac[0] = unique(fac + 1, fac + fac[0] + 1) - fac - 1;}bool ck(int u, int v) { // u to v if(!b[u] &amp;&amp; !b[v]){ if(ord[u] == ord[v]) return u &lt; v; return !(ord[u] % ord[v]); } else if(b[u] &amp;&amp; b[v]){ if(u == v || b[v] % b[u]) return 0; return qp(A[u], b[v] / b[u]) == A[v]; } else return 0;}int main(){ n = read(), p = read(); for(int i = 2; q == 1 &amp;&amp; i * i &lt;= p; i++) if(!(p % i)) q = i; int t = p; while(q ^ 1 &amp;&amp; !(t % q)) K++, t /= q; div(p - qp(q, K - 1)); for(int i = 1; i &lt;= n; i++){ A[i] = a[i] = read(); while(q ^ 1 &amp;&amp; !(a[i] % q)) b[i]++, a[i] /= q; } for(int i = 1; i &lt;= n; i++) for(int j = 1; !ord[i] &amp;&amp; j &lt;= fac[0]; j++) if(qp(a[i], fac[j]) == 1) ord[i] = fac[j]; p2[0] = 1; for(int i = 1; i &lt;= n; i++) p2[i] = add(p2[i - 1], p2[i - 1]); for(int i = 1; i &lt;= n; i++){ int cnt = 0; for(int j = 1; j &lt;= n; j++) cnt += ck(j, i); ans = add(ans, p2[n - cnt - 1]); } printf(&quot;%d\\n&quot;, ans); return 0;} 相关题目 暂无来源 「SHOI2017」相逢是问候 「WC2020」猜数游戏","link":"/2021/01/22/%E5%90%8C%E4%BD%99%E6%95%B0%E8%AE%BA%E4%B9%B1%E8%AE%B2/"},{"title":"圆方树","text":"众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题…… 定义我们对一张联通无向图的每个 BCC（点双连通分量）建一个方点，原图上每个点作为一个圆点。对于不在环上的点，保留它们之间的边；对于环上的点，把它们和对应的方点相连边，就得到了一棵圆方树，如下图。 构建这里使用的是 PinkRabbit 兔队的构建方法，用于一般无向图的圆方树构建。注意，对于仙人掌图的圆方树构建，可以在 dfs 中枚举返祖边来完成，它的好处在于能求出环上的点的顺序，以便于维护环上路径信息。 123456789101112131415161718class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN * 20];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, dfn[CN], low[CN], idx = 0, stk[CN], top = 0, ext = n; vector&lt;int&gt; T[CN];void bd(int u, int p){ dfn[u] = low[u] = ++idx, stk[++top] = u; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]){ bd(v, u), low[u] = min(low[u], low[v]); if(low[v] == dfn[u]){ ext++; int pos = 0; while(pos ^ v) pos = stk[top--], T[ext].push_back(v), T[v].push_back(ext); T[ext].push_back(u), T[u].push_back(ext); } } else low[u] = min(low[u], dfn[v]); }} 一道栗题 $n$ 个点 $m$ 条边的图，$q$ 次询问 $u,v$ 之间的割点的数量。$n,m,q\\le 5\\times 10^5$ 容易发现答案就是圆方树上 $u\\to v$ 的路径上圆点的数量，倍增维护即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int CN = 1e6 + 6;class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, q; vector&lt;int&gt; T[CN];int dfn[CN], low[CN], idx = 0, stk[CN], top = 0, ext, fa[CN][21]; bool w[CN]; void bd(int u, int p){ dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = 1; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]){ bd(v, u), low[u] = min(low[u], low[v]); if(low[v] == dfn[u]){ ext++, fa[ext][0] = u, T[u].push_back(ext); int pos = 0; while(pos ^ v) pos = stk[top--], fa[pos][0] = ext, T[ext].push_back(pos); } } else low[u] = min(low[u], dfn[v]); }}int dis[CN], dep[CN];void dfs(int u, int p){ dep[u] = dep[p] + 1, dis[u] = dis[p] + w[u]; int sz = T[u].size(); for(int i = 0; i &lt; sz; i++) dfs(T[u][i], u);}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}int main(){ ext = n = read(), m = read(); while(m--){ int u = read(), v = read(); add(u, v), add(v, u); } bd(1, 0), dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ int x = read(), y = read(), l = lca(x, y); printf(&quot;%d&quot;, dis[x] + dis[y] - dis[l] - dis[ fa[l][0] ]), puts(&quot;&quot;); } return 0;} 又一道栗题 $n$ 个点 $m$ 条边的图，问有多少三元组 $(s,c,f)$ 满足存在一条 $s\\to f$ 的路径经过 $c$。$n,m\\le 2\\times 10^5$ 题目本质上就是在求 $s\\to f$ 的简单路径的并集大小。 有一个经典结论： 一张无向图上相同 BCC 中两个点 $(u,v)$ 之间的简单路径并集恰好是这个 BCC 一张无向图上不同 BCC 中两个点 $(u,v)$ 之间的简单路径并集是这两个 BCC 并上把它们连接的点 于是可以圆方树上的点恰当赋值：方点点权为该 BCC 的大小，圆点点权为 $-1$。那么 $s\\to f$ 在树上的路径权就是合法的 $c$ 的数量。 考虑计算所有圆点对 $(s,f)$ 的路径长度和。运用贡献法去想，答案是每个 $w[u]$（即点权）乘上经过这个点的路径数量。经过 $u$ 的路径可以分为两种：从 $u$ 子树内到 $u$ 子树外；$u$ 子树内兄弟节点之间的路径。前者的数量是 $sz[u]\\times (n-sz[u])$，后者的数量大概是 $\\dbinom{sz[u]}{2}$ 再减去若干部分，直接在 dfs 的过程中计算即可，时间复杂度 $O(n)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int CN = 4e5 + 6;int read() {int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, q; vector&lt;int&gt; T[CN];int dfn[CN], low[CN], idx = 0, stk[CN], top = 0, ext, w[CN], num; void bd(int u, int p){ dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = -1, num++; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]){ bd(v, u), low[u] = min(low[u], low[v]); if(low[v] == dfn[u]){ ext++, T[u].push_back(ext); int pos = 0; w[ext] = 1; while(pos ^ v) pos = stk[top--], T[ext].push_back(pos), w[ext]++; } } else low[u] = min(low[u], dfn[v]); }}long long ans = 0; int sz[CN];void dfs(int u){ int l = T[u].size(); sz[u] = u &lt;= n; for(int i = 0; i &lt; l; i++) dfs(T[u][i]), ans += 1ll * sz[u] * sz[ T[u][i] ] * w[u], sz[u] += sz[ T[u][i] ]; ans += 1ll * sz[u] * (num - sz[u]) * w[u];}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); ext = n = read(), m = read(); while(m--){ int u = read(), v = read(); add(u, v), add(v, u); } for(int i = 1; i &lt;= n; i++) if(!dfn[i]) num = 0, bd(i, 0), dfs(i); printf(&quot;%lld&quot;, ans &lt;&lt; 1); return 0;} 双一道栗题 $n$ 个点 $m$ 条边的图，点有点权，$q$ 次询问 $u\\to v$ 的可行简单路径上权值最小值，支持修改点权。$n,m,q\\le 10^5$ 注意到如果不带修改，直接圆方树上倍增即可。带修的话，显然的想法是重链剖分之后套个线段树。 但是这样有个问题，就是修改一个圆点需要修改所有与其相连的方点，这样实际上是 $O(n)$ 的。我们考虑利用圆方树的性质，把方点的点权设为它的儿子的权值最小值，那么因为一个圆点至多有一个方点作为父亲，这样修改就变成了 $O(1)$ 的。但是这样查询的时候如果方点的父亲没被访问到，即方点作为 lca 的情况，还需要对这个方点的父亲的权值取 $\\min$。 时间复杂度 $O(n\\log^2 n)$，常数不小，因为实际上我们需要一个 multiset 去维护方点的点权…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;const int CN = 2e5 + 5;const int INF = 0x3f3f3f3f;int read() {int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}class fs {public: int to,nxt; void init(int t,int n) {to = t, nxt = n;} } E[CN &lt;&lt; 1];int hd[CN], ecnt = 0; void add(int x,int y) {E[++ecnt].init(y, hd[x]); hd[x] = ecnt;}int n, m, q; multiset&lt;int&gt; val[CN]; vector&lt;int&gt; T[CN];int dfn[CN], low[CN], dfc = 0, w[CN], ext = 0, stk[CN], tp = 0;void bd(int u, int p){ dfn[u] = low[u] = ++dfc, stk[++tp] = u; for(int k = hd[u]; k; k = E[k].nxt){ int v = E[k].to; if(!dfn[v]){ bd(v, u), low[u] = min(low[u], low[v]); if(low[v] == dfn[u]){ int pos = 0; ext++; while(pos ^ v) pos = stk[tp--], T[ext].push_back(pos), val[ext].insert(w[pos]); w[ext] = *val[ext].begin(), T[u].push_back(ext); } } else low[u] = min(low[u], dfn[v]); }}class SGT { public: int d[CN &lt;&lt; 2]; #define lc k &lt;&lt; 1 #define rc k &lt;&lt; 1 | 1 void md(int l, int r, int k, int p, int x){ if(l == r) return (void)(d[k] = x); int m = (l + r) &gt;&gt; 1; if(p &lt;= m) md(l, m, lc, p, x); else md(m + 1, r, rc, p, x); d[k] = min(d[lc], d[rc]); } int qu(int l, int r, int k, int s, int t){ if(s &lt;= l &amp;&amp; r &lt;= t) return d[k]; int m = (l + r) &gt;&gt; 1, ans = INF; if(s &lt;= m) ans = qu(l, m, lc, s, t); if(m &lt; t) ans = min(ans, qu(m + 1, r, rc, s, t)); return ans; }} D;int dep[CN], id[CN], idx = 0, top[CN], imp[CN], sz[CN], fa[CN];void dfs1(int u, int p){ fa[u] = p, dep[u] = dep[p] + 1, sz[u] = 1; int mx = 0, l = T[u].size(); for(int i = 0; i &lt; l; i++){ int v = T[u][i]; dfs1(v, u), sz[u] += sz[v], imp[u] = mx &lt; sz[v] ? mx = sz[v], v : imp[u]; }}void dfs2(int u, int t){ id[u] = ++idx, D.md(1, ext, 1, id[u], w[u]), top[u] = t; if(imp[u]) dfs2(imp[u], t); int l = T[u].size(); for(int i = 0; i &lt; l; i++){ int v = T[u][i]; if(v ^ imp[u]) dfs2(v, v); }}int qu(int x, int y){ int ans = INF; while(top[x] ^ top[y]){ if(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y); ans = min(ans, D.qu(1, ext, 1, id[ top[x] ], id[x])); x = fa[ top[x] ]; } if(dep[x] &lt; dep[y]) swap(x, y); ans = min(ans, D.qu(1, ext, 1, id[y], id[x])); if(y &gt; n) ans = min(ans, w[ fa[y] ]); return ans;}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); ext = n = read(), m = read(), q = read(); for(int i = 1; i &lt;= n; i++) w[i] = read(); while(m--){ int u = read(), v = read(); add(u, v), add(v, u); } bd(1, 0), dfs1(1, 0), dfs2(1, 1); while(q--){ char c; cin &gt;&gt; c; int a = read(), b = read(); if(c == 'C'){ D.md(1, ext, 1, id[a], b); int f = fa[a]; if(f &gt; n){ val[f].erase(w[a]), val[f].insert(b); if(*val[f].begin() ^ w[f]) w[f] = *val[f].begin(), D.md(1, ext, 1, id[f], w[f]); } w[a] = b; } else printf(&quot;%d&quot;, qu(a, b)), puts(&quot;&quot;); } return 0;} 叒一道栗题 $n$ 个点 $m$ 条边的图，$q$ 次询问，每次询问给出一个点集 $S$，问有多少点满足在图上删除该点后，$\\exists u,v\\in S$，$u,v$ 在图上不连通。$n,m\\le 10^5, \\sum|S_i|\\le 2\\times 10^5$ “圆方树上圆方果，“圆方树下你和我，“圆方树前建虚树，“欢乐多又多。 Subtask2 $|S_i|=2$ 两点间割点数量等于圆方树上点对路径上的圆点数量，则直接在圆方树上倍增即可。Subtask3 考虑建出圆方树的虚树来，然后就可以简单树形 DP 了，时间复杂度 $O(n)-O(|S_i|\\log n)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int CN = 4e5 + 5;int read() {int s = 0,ne = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') ne = c == '-' ? -1 : 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0', c = getchar(); return s * ne;}int TC, n, m, q, id[CN]; vector&lt;int&gt; G[CN], T[CN], S[CN];int stk[CN], top = 0, dfn[CN], low[CN], idx = 0, ext; void tarjan(int u, int p){ dfn[u] = low[u] = ++idx, stk[++top] = u; int l = G[u].size(); for(int i = 0; i &lt; l; i++){ int v = G[u][i]; if(!dfn[v]){ // dfn[] 需要清空!!! tarjan(v, u), low[u] = min(low[u], low[v]); if(dfn[u] == low[v]){ int pos = 0; T[u].push_back(++ext), T[ext].clear(); while(pos ^ v) pos = stk[top--], T[ext].push_back(pos); } } else low[u] = min(low[u], dfn[v]); }}int dep[CN], fa[CN][21], dis[CN];void dfs(int u, int p){ dfn[u] = ++idx, fa[u][0] = p, dep[u] = dep[p] + 1, dis[u] = dis[p] + (u &lt;= n); int l = T[u].size(); for(int i = 0; i &lt; l; i++) dfs(T[u][i], u);}int lca(int u, int v){ if(dep[u] &lt; dep[v]) swap(u, v); for(int k = 20; k + 1; k--) if(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k]; if(u ^ v){ for(int k = 20; k + 1; k--) if(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][0]; } return u;}bool cmp(int i, int j) {return dfn[i] &lt; dfn[j];} int rt;void build(int a[], int n){ sort(a + 1, a + n + 1, cmp); rt = stk[top = 1] = a[1], S[ a[1] ].clear(); for(int i = 2; i &lt;= n; i++){ int u = a[i], l = lca(u, stk[top]); if(dfn[l] &lt; dfn[rt]) rt = l; if(l ^ stk[top]){ while(dfn[ stk[top - 1 ] ] &gt; dfn[l]) S[ stk[top - 1] ].push_back(stk[top]), top--; if(stk[top - 1] ^ l) S[l].clear(), S[l].push_back(stk[top]), stk[top] = l; else S[l].push_back(stk[top--]); } S[u].clear(), stk[++top] = u; } for(int i = 1; i &lt; top; i++) S[ stk[i] ].push_back(stk[i + 1]);}int f[CN];void dp(int u){ int l = S[u].size(); f[u] = u &lt;= n; for(int i = 0; i &lt; l; i++){ int v = S[u][i]; dp(v), f[u] += f[v] + dis[ fa[v][0] ] - dis[u]; }}int main(){ freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); TC = read(); while(TC--){ ext = n = read(), m = read(); for(int i = 1; i &lt;= n; i++) G[i].clear(), T[i].clear(); while(m--){ int u = read(), v = read(); G[u].push_back(v), G[v].push_back(u); } memset(dfn, 0, sizeof(dfn)), idx = top = 0, tarjan(1, 0), idx = 0, dfs(1, 0); for(int k = 1; k &lt;= 20; k++) for(int i = 1; i &lt;= ext; i++) fa[i][k] = fa[ fa[i][k - 1] ][k - 1]; q = read(); while(q--){ id[0] = read(); for(int i = 1; i &lt;= id[0]; i++) id[i] = read(); build(id, id[0]), dp(rt), printf(&quot;%d&quot;, f[rt] - id[0]), puts(&quot;&quot;); } } return 0;} 相关题目 「LG-P4320」道路相遇 「APIO2018」Duathlon 「CF487E」Tourists 「SDOI2018」战略游戏 习题「LG-P5236」静态仙人掌","link":"/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"title":"多项式学习笔记","text":"在模板梳理中给出过一个多项式全家桶，在这里补充一下理论推导，也是对多项式基础知识的总结。限于篇幅，本篇中的解释可能会略有简短，不重要的说明已经省略。 1 形式幂级数与生成函数形式幂级数设 $z$ 是未定元，我们定义一个形式幂级数是一个无穷级数： $$ A(z)=a_0+a_1z^1+a_2z^2+…+a_nz^n+…=\\sum\\limits_{i\\ge 0} a_iz^i $$ 其中 $\\langle a_0,a_1,a_2,…\\rangle$ 是一个无穷的实系数序列。 在这里，我们并不关心 $z$ 是否代入了某个值，它如同一个“占位符”，并不参与我们的运算。 生成函数对于任意一个序列 $\\langle g_0,g_1,g_2,…,g_n\\rangle$，我们可以认为其不存在的项全部等于 0，然后将其看作一个无穷的数列。这样，我们可以定义这个数列的普通生成函数（Ordinary Generating Function, OGF）是一个形式幂级数： $$G(z)=\\sum\\limits_{i\\ge 0} g_iz^i$$ 可以定义这个数列的指数生成函数（Exponential Generating Funcion, EGF）是一个形式幂级数： $$G(z)=\\sum\\limits_{i\\ge 0} \\dfrac{g_iz^i}{i!}$$ 这样我们就通过统一化的语言来表达了一个数列，而这就是生成函数的意义所在：解决数列问题的工具。 从另一种角度来讲，生成函数也可以看作一个次数是正无穷的多项式，因此生成函数的乘法即是多项式相乘。 一般情况下，我们只关心某个生成函数的前 $n$ 项系数，记作 $A(z)\\text{ }\\text{mod}\\text{ } z^n$。这个形式对应了一个有限项的系数序列。 2 卷积乘法卷积对于数列 $f,g$，我们定义它们的乘法卷积（或者直接称作卷积）是一个数列 $c$，满足： $$ c_i=\\sum\\limits_{j=0}^i f_jg_{i-j}$$ 同时记作 $c=fg$。容易发现，两个数列乘法卷积的 OGF 是它们各自的 OGF 相乘得到的结果。 二项卷积对于数列 $f,g$，我们定义它们的二项卷积是一个数列 $c$，满足： $$c_i=\\sum\\limits_{j=0}^i \\dbinom{i}{j}f_jg_{i-j}$$ 同时记作 $c=fg$，这里乘法的定义与上面的不同，但是惯用记号一样，需要根据语境来区分。容易发现，两个数列二项卷积的 EGF 是它们的 EGF 相乘得到的结果。 狄利克雷卷积对于数列 $f,g$，我们定义它们的狄利克雷卷积是一个数列 $c$，满足： $$c_i=\\sum\\limits_{k|i} f_{k}g_{i/k}$$ 记号同上。狄利克雷卷积在数论中很常见。 类似的，我们可以定义异或卷积 $(fg)_i=\\sum\\limits_{j\\oplus k=i} f_jg_k$，或卷积 $(fg)_i=\\sum\\limits_{j\\cup k=i}f_jg_k$，与卷积 $(fg)_i=\\sum\\limits_{j\\cap k=i} f_jg_k$，其中我们用 $\\oplus$ 代表按位异或，用 $\\cup$ 代表按位或，用 $\\cap$ 代表按位与。 除去狄利克雷卷积可以直接 $O(n\\ln n)$ 计算之外，其它卷积计算的朴素实现均是 $O(n^2)$ 的。因此我们需要通过下面的这些手段去计算卷积。 离散傅里叶变换离散傅里叶变换（Discrete Fourier Transform, DFT）是对多项式进行从系数表示到点值表示的变换。设 $f(x)$ 是一个 $n-1$ 次多项式，那么它的 DFT 对应一个长度为 $n$ 的序列 $\\mathcal F(f)$，满足： $$ \\mathcal F(f)_i=f(x_i) $$ 其中 $x_i(i=0,1,2,…,n-1)$ 是代入的点值。 快速傅里叶变换（Fast Fourier Transform, FFT）通过 $n$ 次单位根 $\\omega_n$ 来进行 DFT，其中 $\\omega_n$ 满足 $\\omega_n^n=1$；在复数域下，这样的数字一共有 $n$ 个。如果令 $\\omega_n^1=\\cos \\frac{2\\pi}{n}+i\\sin\\frac{2\\pi}{n}$，那么它们分别是 $\\omega_n^0,\\omega_n^1,\\omega_n^2,…,\\omega_n^{n-1}$。 由于 $n$ 次单位根的一些特殊性质，所以当 $n=2^k$ 时，我们可以通过分治来求解点值，以及通过点值来求解系数，后者称作逆变换（Inverse Discrete Fourier Transfrom, IDFT）。 这样就得到了一个在 $O(n\\log n)$ 的时间内进行 DFT 的算法（FFT）。需要注意的一点是，如果用 FFT 计算序列卷积，得到的是长度为 $n$ 的循环卷积 $(fg)_i=\\sum\\limits_{j+k\\text{ }\\text{mod }n=i}f_jg_k$，用生成函数记作： $$F(z)G(z)\\text{ }\\text{mod }z^n-1$$ FFT 的代码实现可以在模板梳理中找到。 快速数论变换 原根：在 $\\mathbb F_R$ 下，如果一个数 $g^i$ 一共有 $\\varphi(R)$ 种不同的取值，或者说 $g$ 模 $R$ 的阶是 $\\varphi(R)$，那么称 $g$ 是 $\\mathbb F_R$ 下的原根。 可以证明，原根存在的充要条件是 $R=2,4,p^a,2p^a$，其中 $p$ 是一个素数。可以发现，素数的原根是总存在的。 考虑做长度为 $n=2^k$ 的 DFT，有没有什么方式可以避免复数运算？ 对于形如 $P=a2^r+1(r\\ge k)$ 的素数，设 $g$ 是 $\\mathbb F_P$ 下的原根，那么 $g_n=g^{\\varphi(P)/n}$ 有着与 $n$ 次单位根 $\\omega_n$ 相同的性质，即 $g_n^n=1$。根据原根的性质，我们可以发现 $g_n^0,g_n^1,…,g_n^{n-1}$ 是 $n$ 个两两不同的数字，且都满足 $(g_n^l)^n\\equiv g^{l\\varphi(P)}\\equiv 1\\text{ }(\\text{mod }P)$。于是，我们可以用 $g_n$ 来代替 $\\omega_n$ 进行多项式变换，这样就得到了快速数论变换，本质上是 FFT 在模域下的变种。 一个质数的原根一定存在，但并不是只要存在原根就可以 NTT，另一个条件是 $n|\\varphi(P)$，形象的理解即可以等分圆周。 代码同样可以在模板梳理中找到。 值得一提的是，这种计算点值的方法与单位根反演有着异曲同工之妙。单位根反演即是这个柿子： $$[k|n]=\\dfrac{1}{k}\\sum\\limits_{i=0}^{k-1}\\omega_k^{in}$$ 其中 $\\omega_k$ 是 $k$ 次单位根，模义下可用 $g_k$ 来代替；这可以看作是计算了一个点值，在一些题目中会具有优良的性质。 离散沃尔什变换显然，位运算卷积不满足卷积结果的点值是原点值相乘。那么我们可以通过一些手段构造某种变换，来让我们变换出的序列满足点值相乘的规律。这些变换分别是： 按位或 $$\\mathcal{F}(f)_i=\\sum\\limits_{j\\cup i=i}a_j$$ 按位与 $$\\mathcal{F}(f)_i=\\sum\\limits_{j\\cap i=i}a_j$$ 按位异或 $$\\mathcal{F}(f)_i=\\sum\\limits_{j=0}^{n-1} (-1)^{|i\\cap j|} f_j$$ 其中 $|x|$ 代表 $x$ 在二进制下为 1 的位数。可以证明，这些变换满足与 DFT 同样的性质，即点值的乘积是卷积结果的点值。 对于异或的变换，还有一个重要的柿子是 $\\mathcal{F}(\\mathcal{F}(f))_i=n·f_i$，可以通过代入化简来证明。 这些变换都可以通过类似 FFT 的方法在 $O(n\\log n)$ 的时间内得到。代码可以参考模板梳理。 3 微积分形式幂级数的微分定义为逐项微分，即： $$\\dfrac{\\text d}{\\text dz} \\left(\\sum\\limits_{i\\ge 0} a_iz^i \\right)=\\sum\\limits_{i\\ge 0} (i+1)a_{i+1}z^i$$ 同样的，形式幂级数的积分定义为逐项积分。我们可以定义一个形式幂级数的定积分为： $$\\int \\left(\\sum\\limits_{i\\ge 0}a_iz^i \\right)\\text dz=\\sum\\limits_{i&gt;0}\\dfrac{a_{i-1}}{i}z^i$$ 我们可以用微积分来分析一个幂级数的闭合形式，这在涉及指标变换的时候较为方便。 4 乘法逆对于幂级数 $A(z)$，我们定义它的乘法逆是一个幂级数 $B(z)$ 满足 $A(z)B(z)\\equiv 1 \\text{ }(\\text{mod } z^n)$，记作 $B(z)=A^{-1}(z)$。 当 $A(z)$ 的常数项不为零时，它的乘法逆是总存在的。证明如下： 设 $A(z)=\\sum\\limits_{i=0}^{n-1} a_ix^i, B(z)=\\sum\\limits_{i=0}^{n-1} b_ix^i$，通过乘法逆的定义可得： $$\\begin{align} &amp;b_0=\\dfrac{1}{a_0}\\newline &amp;\\sum\\limits_{j=1}^{n-1} a_jb_{i-j}=0\\text{ }(i&gt;0)\\end{align}$$ 对 $i$ 归纳可以得到： $$ b_i=-b_0\\sum\\limits_{j=0}^{i-1}a_{i-j}b_j\\text{ }(i&gt;0) $$ 从而只要 $b_0$ 存在就可以构造出 $B(z)$。同时这也给出了朴素 $O(n^2)$ 求逆的方法，下一步考虑怎么优化。 设 $B_0(z)=A^{-1}(z)\\text{ }\\text{mod } z^n$ 是一个只有前 $n$ 项系数有效的幂级数，可以如下倍增： $$\\begin{align} B_0(z)A(z)&amp;\\equiv 1\\text{ }(\\text{mod } z^n)\\newline (B_0(z)A(z)-1)^2&amp;\\equiv 0\\text{ }(\\text{mod }z^{2n})\\newline B_0^2(z)A^2(z)-2B_0(z)A(z)+1&amp;\\equiv 0\\text{ }(\\text{mod }z^{2n}) \\newline B_0(z)(2-B_0(z)A(z))&amp;\\equiv B(z)\\text{ }(\\text{mod }z^{2n}) \\end{align}$$ 其中 $B(z)=A^{-1}(z)\\text{ }\\text{mod } z^{2n}$ 是一个只有前 $2n$ 项系数有效的幂级数。 依此倍增，复杂度 $T(n)=T(n/2)+O(n\\log n)=O(n\\log n)$，实现可以在代码梳理中找到。 5 指对运算泰勒展开对一个高阶可导的函数 $f(x)$，它在 $x=x_0$ 处的泰勒展开式为： $$f(x)=f(x_0)+f’(x_0)(x-x_0)+\\dfrac{f’’(x_0)(x-x_0)^2}{2}+…+\\dfrac{f^{(n)}(x-x_0)^n}{n!}+…$$ 这是一个无穷级数。也可以只保留前 $n+1$ 项写作： $$f(x)=f(x_0)+f’(x_0)(x-x_0)+\\dfrac{f’’(x_0)(x-x_0)}{2}+…+\\dfrac{f^{(n)}(x_0)}{n!}+r_n(x)$$ 其中 $r_n(x)$ 指代一个余项。 麦克劳林公式在泰勒展开的公式中，取 $x_0=0$，就得到了麦克劳林公式： $$f(x)=f(0)+f’(0)x+\\dfrac{f’’(0)x^2}{2!}+…+\\dfrac{f^{(n)}(0)x^n}{n!}+…$$ 亦即 $f(x)$ 在 $x=0$ 处的泰勒展开。 形式幂级数的乘方是有定义的，那么我们可以通过泰勒展开来定义如何对形式幂级数进行各种诡异的函数变换，诸如指对函数，正余弦函数，等等。 指数函数和对数函数由于 $(e^x)’=e^x$，根据麦克劳林公式，可以得到： $$\\exp x=e^x=1+x+\\dfrac{x^2}{2!}+\\dfrac{x^3}{3!}…$$ 这是一个无穷级数。于是可以定义一个形式幂级数的指数函数为： $$\\exp A(z)=\\sum\\limits_{i\\ge 0}\\dfrac{A^i(z)}{i!}$$ 同理，因为： $$\\ln’ x=x^{-1},\\ln ''x=-x^{-2},…,,\\ln^{(n)} x=(-1)^{n-1}(n-1)!(1+x)^{-n}$$ 可以定义一个形式幂级数的对数函数是： $$\\ln (1+A(z))=-\\sum\\limits_{i&gt;0}\\dfrac{(-1)^iA^i(z)}{i}$$ 注意这里的常数项是未定义的，一般认为其等于 0。 考虑如何求对数函数。设 $B(z)=\\ln A(z)$，两边求导得到： $$B’(z)=\\ln’ A(z)=\\dfrac{A’(z)}{A(z)}$$ 即是链式法则。于是我们只需要求逆即可，复杂度 $O(n\\log n)$。 多项式指数的计算需要用到牛顿迭代。 牛顿迭代法考虑计算一个函数 $f(x)$ 的零点。设 $x_0$ 是一个已知的近似解，在 $x_0$ 处对 $f(x)$ 泰勒展开，可以得到 $f(x)$ 的一个近似表达： $$ f(x)\\sim f(x_0)+f’(x_0)(x-x_0) $$ 令 $f(x_0)+f’(x_0)(x-x_0)=0$，解得 $x=x_0-\\dfrac{f(x_0)}{f’(x_0)}$。取 $x$ 作为下一个近似解 $x_2$，又可以进行同样的操作。可以证明，在某些情况下，这样就可以逼近 $f(x)$ 精确的零点。 设 $B(z)=\\exp A(z)$，那么有 $\\ln B(z)-A(z)=0$。设 $G(B(z))=\\ln B(z)-A(z)$ 是一个以 $B(z)$ 为变元的形式幂级数，$B_0(z)=\\exp A(z)\\text{ }\\text{mod }z^n$ 是已知的近似解，那么可以如下倍增（迭代）： $$\\begin{align} B(z)&amp;\\equiv B_0(z)-\\dfrac{\\ln B_0(z)-A(z)}{1/B_0(z)}\\text{ }(\\text{mod } z^{2n})\\newline &amp;\\equiv B_0(z)(1-\\ln B_0(z)+A(z))\\text{ }(\\text{mod } z^{2n})\\end{align}$$ 依此迭代，复杂度 $T(n)=T(n/2)+O(n\\log n)=O(n\\log n)$，实现可以在代码梳理中找到。 6 应用一道栗题 请构造一个序列 $a_1,a_2,…,a_k$，满足 $\\forall i\\in[1, k] a_i\\in[1, n]$，使得对这个序列做无限背包计数后得到的序列的前 $n$ 项在模 $P$ 意义下是 $f_1,f_2,…,f_n$，其中 $P$ 是一个给定的质数。序列的长度没有限制，可以证明解总存在且唯一。 $n\\le 2^{18},10^6\\le p\\le 2^{30}$ 设 $b_i$ 表示序列中是否包含 $i$ 这个数字，$F(z)=\\sum\\limits_{i=1}^n f_iz^i$，那么有： $$\\begin{align} F(z)&amp;=\\prod\\limits_{i=1}^n \\dfrac{1}{(1-z^i)^{b_i}}\\newline \\ln F(z)&amp;=-\\sum\\limits_{i=1}^nb_i\\ln(1-z^i)\\newline \\ln F(z)&amp;=\\sum\\limits_{i=1}^nb_i\\sum\\limits_{j&gt;0}\\dfrac{z^{ij}}{j}\\newline &amp;=\\sum\\limits_{i=1}^n z^i\\sum\\limits_{j|i}\\dfrac{jb_j}{i} \\end{align}$$ 比较系数得 $nf_n=\\sum\\limits_{i|n}ib_i$，亦即 $f=b*1$，莫比乌斯反演得 $b_n=\\dfrac{1}{n}\\sum\\limits_{j|n}jf_j\\varphi(n/j)$。 复杂度 $O(n(\\log n+\\ln n))$，需要任意模数卷积，这里用拆系数 FFT 实现。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LDB long doubleconst int CN = (1 &lt;&lt; 18) + 3;const LDB PI = acos(-1);int P;int read(){ int s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int qp(int a, int b){ int r = 1; while(b){ if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P, b &gt;&gt;= 1; } return r;}int invx(int x) {return qp(x, P - 2);}namespace POLY{ class COMP{ public: LDB x, y; COMP operator + (const COMP &amp;o) const{ COMP r = *this; r.x += o.x, r.y += o.y; return r; } COMP operator - (const COMP &amp;o) const{ COMP r = *this; r.x -= o.x, r.y -= o.y; return r; } COMP operator * (const COMP &amp;o) const{ COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x; return r; } } ; COMP mk(LDB a, LDB b) {COMP o; o.x = a, o.y = b; return o;} COMP conj(COMP o) {o.y = -o.y; return o;} int rev[CN &lt;&lt; 2]; void cg(COMP t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]); } void fft(COMP t[], int n, int tp){ cg(t, n); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1; COMP gn = mk(cos(2 * PI / (LDB)w), sin(2 * tp * PI / (LDB)w)); for(int i = 0; i &lt; n; i += w){ COMP g = mk(1, 0); for(int j = i; j &lt; i + l; j++){ COMP u = t[j], v = t[j + l] * g; t[j] = u + v, t[j + l] = u - v, g = g * gn; } } } if(tp ^ 1){ for(int i = 0; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n; } } COMP p[CN &lt;&lt; 2], q[CN &lt;&lt; 2], x[CN &lt;&lt; 2], y[CN &lt;&lt; 2], z[CN &lt;&lt; 2], w[CN &lt;&lt; 2]; void conv(int a[], int b[], int n){ // a = a * b int B = (1 &lt;&lt; 15) - 1, N = 1; while(N &lt; (n &lt;&lt; 1)) N &lt;&lt;= 1; for(int i = 0; i &lt; N; i++) p[i] = q[i] = mk(0, 0); for(int i = 0; i &lt; n; i++) p[i] = mk(a[i] &gt;&gt; 15, a[i] &amp; B); // k1 r1 for(int i = 0; i &lt; n; i++) q[i] = mk(b[i] &gt;&gt; 15, b[i] &amp; B); // k2 r2 fft(p, N, 1), fft(q, N, 1); for(int i = 0; i &lt; N; i++){ int j = (N - 1) &amp; (N - i); COMP k1, r1, k2, r2; k1 = (p[i] + conj(p[j])) * mk(0.5, 0); r1 = (p[i] - conj(p[j])) * mk(0, -0.5); k2 = (q[i] + conj(q[j])) * mk(0.5, 0); r2 = (q[i] - conj(q[j])) * mk(0, -0.5); x[i] = k1 * k2, y[i] = r1 * r2, z[i] = k1 * r2, w[i] = k2 * r1; } for(int i = 0; i &lt; N; i++) p[i] = x[i] + y[i] * mk(0, 1); for(int i = 0; i &lt; N; i++) q[i] = z[i] + w[i] * mk(0, 1); fft(p, N, -1), fft(q, N, -1); for(int i = 0; i &lt; n; i++){ LL X = (LL)(0.5 + p[i].x), Y = (LL)(0.5 + p[i].y), Z = (LL)(0.5 + q[i].x), W = (LL)(0.5 + q[i].y); X = (X % P + P) % P, Y = (Y % P + P) % P, Z = (Z % P + P) % P, W = add((W % P + P) % P, Z); a[i] = add((X &lt;&lt; 30) % P, add((W &lt;&lt; 15) % P, Y)); } for(int i = n; i &lt; N; i++) a[i] = 0; } int c[CN &lt;&lt; 2]; void inv(int a[], int b[], int n){ for(int i = 0; i &lt; (n &lt;&lt; 1); i++) b[i] = c[i] = 0; b[0] = invx(a[0]); for(int w = 2; w &lt; (n &lt;&lt; 1); w &lt;&lt;= 1){ for(int i = 0; i &lt; w; i++) c[i] = a[i]; conv(c, b, w); for(int i = 0; i &lt; w; i++) c[i] = add(0, P - c[i]); c[0] = add(2, c[0]); conv(b, c, w); } } int ia[CN &lt;&lt; 2]; void ln(int a[], int b[], int n){ for(int i = 0; i &lt; (n &lt;&lt; 1); i++) ia[i] = b[i] = 0; inv(a, ia, n); for(int i = 0; i &lt; (n &lt;&lt; 1); i++) c[i] = 0; for(int i = 0; i &lt; n - 1; i++) c[i] = 1ll * (i + 1) * a[i + 1] % P; conv(c, ia, n); for(int i = 1; i &lt; n; i++) b[i] = 1ll * c[i - 1] * invx(i) % P; }}int p[CN], mu[CN]; bool np[CN];void sieve(int n){ np[1] = 1, mu[1] = 1; for(int i = 2; i &lt;= n; i++){ if(!np[i]) p[++p[0]] = i, mu[i] = P - 1; for(int j = 1; j &lt;= p[0] &amp;&amp; i * p[j] &lt;= n; j++){ int x = i * p[j]; np[x] = 1; if(i % p[j]) mu[x] = P - mu[i]; else break; } }}int n, a[CN &lt;&lt; 2], b[CN &lt;&lt; 2]; int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read() + 1, P = read(); a[0] = 1; for(int i = 1; i &lt; n; i++) a[i] = read(); POLY :: ln(a, b, n); sieve(n), memset(a, 0, sizeof(a)); for(int i = 1; i &lt; n; i++) b[i] = 1ll * b[i] * i % P; for(int i = 1; i &lt; n; i++) for(int j = 1; i * j &lt; n; j++) a[i * j] = add(a[i * j], 1ll * mu[i] * b[j] % P); int cnt = 0; for(int i = 1; i &lt; n; i++) cnt += (!!a[i]); printf(&quot;%d\\n&quot;, cnt); for(int i = 1; i &lt; n; i++) if(a[i]) printf(&quot;%d &quot;, i); return 0;} 又一道栗题 有一个整数 $x$，初值是 $[0,n]$ 内的一个随机值，其中为 $i$ 的概率为 $p_i$。要进行 $m$ 轮操作，每次把 $x$ 等概率随机地替换成 $[0,x]$ 中的一个数字，求最后对 $\\forall i\\in[0, n]$，$x$ 的取值为 $i$ 的概率。对 $998244353$ 取模。 $n\\le 10^5,m\\le 10^{18}$ 设 $f[k,i]$ 表示经过 $k$ 轮，得到 $i$ 的概率，有递推关系 $f[k,i]=\\sum\\limits_{j\\ge i}^n f[k-1,j]/j+1$。 设 $F(k,z)=\\sum\\limits_{i=0}^n f[k,i]z^i$ 是 $f$ 的 OGF，根据上面的递推关系，有： $$\\begin{aligned} F(k,z)&amp;=\\sum\\limits_{i=0}^n z^i\\sum\\limits_{j=i}^n \\dfrac{f[k-1,j]}{j+1}\\newline &amp;=\\sum\\limits_{j=0}^n \\dfrac{f[k-1,j]}{j+1}\\sum\\limits_{i=0}^j z^i \\newline &amp;=\\dfrac{1}{z-1} \\sum\\limits_{i=0}^n f[k-1,i]\\dfrac{z^{i+1}-1}{i+1} \\end{aligned}$$ 考虑 $f[k-1,i]$ 转移到了哪里，容易发现它在 $F(k,·)$ 中是 $i+1$ 项系数，这个变换不容易快速实现，那么继续推导。 根据牛顿-莱布尼茨公式，可以推得：$\\int_1^z t^i\\text{ }\\text dt=\\dfrac{z^{i+1}}{z-1}-\\dfrac{1}{z-1}$，那么原式化为： $$\\begin{aligned} F(k,z)&amp;=\\dfrac{1}{z-1}\\sum\\limits_{i=0}^n f[k-1,i]\\int_1^z t^i\\text{ }\\text dt\\newline &amp;=\\dfrac{1}{z-1}\\int_1^z\\left( \\sum\\limits_{i=0}^nf[k-1,i]t^i\\right)\\text{ }\\text dt\\newline &amp;= \\dfrac{1}{z-1}\\int_1^z F(k-1,t)\\text{ }\\text dt \\end{aligned}$$ 考虑原式中 $z^{i+1}-1$ 很是鬼畜，考虑把定积分的下指标改为从 0 开始，那么设 $G(k,z)=F(k,z+1)$，有： $$\\begin{aligned} G(k,z)&amp;=\\dfrac{1}{z}\\int_1^{z+1} F(k-1,t)\\text{ }\\text dt \\newline &amp;=\\dfrac{1}{z}\\int_0^z F(k-1,t+1)\\text{ }\\text d(t+1)\\newline &amp;=\\dfrac{1}{z}\\int_0^z G(k-1,t)\\text{ }\\text dt \\newline &amp;= \\dfrac{1}{z}\\sum\\limits_{i=0}^n \\dfrac{g[k-1,i]}{i+1}z^{i+1}\\newline &amp;=\\sum\\limits_{i=0}^n \\dfrac{g[k-1,i]}{i+1}z^i \\end{aligned}$$ 其中 $g[k,i]$ 满足 $G(k,z)=\\sum\\limits_{i=0}^n g[k,i]z^i$，即是对应的序列。考虑系数的变化：$k\\to k+1:g[k,i]\\to g[k+1,i]/(i+1)$，那么 $m$ 次变化之后就是 $g[m,i]=\\dfrac{g[0,i]}{(i+1)^m}$ 这个就可以近似线性直接求出来。 那么只需要类似于 DFT 和 IDFT 那样子，把 $F$ 变成 $G$，系数修改完之后再变回来即可。 考虑怎么变，根据定义，得到： $$\\begin{aligned} G(k,z)&amp;=F(k,z+1)\\newline \\Leftrightarrow \\sum\\limits_{i=0}^n g[k,i]z^i&amp;=\\sum\\limits_{i=0}^n f[k,i](z+1)^i\\newline &amp;=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^i\\dbinom{i}{j}z^jf[k,i] \\newline &amp;= \\sum\\limits_{i=0}^n z^i \\sum\\limits_{j=i}^n \\dbinom{j}{i}f[k,j]\\end{aligned}$$ 考虑 $k=0$，得： $$\\begin{aligned} g[0,i]&amp;=\\sum\\limits_{j=i}^n \\dbinom{j}{i}p_j\\newline &amp;= \\dfrac{1}{i!}\\sum\\limits_{t=0}^{n-i} \\dfrac{(i+t)!p_{i+t}}{t!}\\end{aligned}$$ 这里是差为定值的卷积，依然可以化成序列卷积，那么构造 $A(z)=\\sum\\limits_{i=0}^n \\dfrac{1}{i!},B(z)=\\sum\\limits_{i=0}^n b_ix^i$，其中有 $p_ii!=b_{n-i}$，即人为令下标的和为定值，那么容易发现 $g[0,i]=\\dfrac{1}{i!}[z^{n-i}]A(z)B(z)$。NTT 即可，复杂度 $O(n\\log n)$。 对于 $g\\to f$ 的转化，根据二项式反演，有： $$\\begin{aligned} g[k,i]&amp;=\\sum\\limits_{j=i}^n\\dbinom{j}{i}f[k,j] \\newline \\Leftrightarrow f[k,i]&amp;=\\sum\\limits_{j=i}^n (-1)^{j-i}\\dbinom{j}{i}g[k,j] \\end{aligned}$$ 依然是差为定值的卷积，同理可仿照上面求出，总复杂度 $O(n\\log n)$。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int P = 998244353;const int CN = 1e5 + 10;LL read(){ LL s = 0, ne = 1; char c = getchar(); for(;c &lt; '0' || c &gt; '9';c = getchar()) if(c == '-') ne = -1; for(;c &gt;= '0' &amp;&amp; c &lt;= '9';c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - '0'; return s * ne;}int add(int x, int y) {return x + y &gt;= P ? x + y - P : x + y;}int qp(int a, int b){ int r = 1; while(b){ if(b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P, b &gt;&gt;= 1; } return r;}int inv(int x) {return qp(x, P - 2);}int rev[CN &lt;&lt; 2];void cg(int t[], int n){ for(int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (n &gt;&gt; 1); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(t[i], t[rev[i]]);}void ntt(int t[], int n, int tp){ cg(t, n); for(int w = 2; w &lt;= n; w &lt;&lt;= 1){ int l = w &gt;&gt; 1, gn = qp(tp ? 3 : inv(3), (P - 1) / w); for(int i = 0; i &lt; n; i += w){ int g = 1; for(int j = i; j &lt; i + l; j++){ int u = t[j], v = 1ll * g * t[j + l] % P; t[j] = add(u, v), t[j + l] = add(u, P - v), g = 1ll * g * gn % P; } } } if(!tp){ int in = inv(n); for(int i = 0; i &lt; n; i++) t[i] = 1ll * t[i] * in % P; }}void conv(int A[], int B[], int n){ // A = A * B int N = 1; while(N &lt; (n &lt;&lt; 1)) N &lt;&lt;= 1; ntt(A, N, 1), ntt(B, N, 1); for(int i = 0; i &lt; N; i++) A[i] = 1ll * A[i] * B[i] % P; ntt(A, N, 0); for(int i = n; i &lt; N; i++) A[i] = B[i] = 0;}int A[CN &lt;&lt; 2], B[CN &lt;&lt; 2];int n, m, p[CN], fac[CN], ifac[CN], g[CN];int main(){ // freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin); n = read() + 1, m = read() % (P - 1); fac[0] = 1; for(int i = 1; i &lt; n; i++) fac[i] = 1ll * fac[i - 1] * i % P; ifac[n - 1] = inv(fac[n - 1]); for(int i = n - 2; i + 1; i--) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; for(int i = 0; i &lt; n; i++) p[i] = read(); for(int i = 0; i &lt; n; i++) A[n - i - 1] = 1ll * fac[i] * p[i] % P; for(int i = 0; i &lt; n; i++) B[i] = ifac[i]; conv(A, B, n); for(int i = 0; i &lt; n; i++) g[i] = 1ll * ifac[i] * A[n - i - 1] % P; for(int i = 0; i &lt; n; i++) g[i] = 1ll * g[i] * inv(qp(i + 1, m)) % P; for(int i = 0; i &lt; n; i++) A[n - i - 1] = 1ll * fac[i] * g[i] % P; for(int i = 0; i &lt; n; i++) B[i] = i &amp; 1 ? P - ifac[i] : ifac[i]; conv(A, B, n); for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, int(1ll * ifac[i] * A[n - i - 1] % P)); puts(&quot;&quot;); return 0;} 杂项参考 《生成函数的运算与组合计数问题》金策，IOI中国国家候选队论文2015 《再探快速傅里叶变换》毛啸，IOI中国国家候选队论文2016 《浅谈 OI 中常用的一些生成函数运算的合法与正确性》，rpy’s Blog 相关题目 「SDOI2017」遗忘的集合 「CF923E」Perpetual Subtraction","link":"/2020/12/18/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"树链剖分","text":"树链剖分是一种针对树上问题的很优秀的处理想法。准确的说，它就是一种把“树”映射成“链”的想法。而对于“链”，我们能进行很多处理，诸如挂上线段树，维护前缀和之类。通过这些优秀的数据结构，我们就可以很好的解决有关树上路径的诸多问题…… 一 引入1 模型对于区间求和、区间最值问题，我们有一个很好的数据结构模型——线段树来解决。但是如果我们把区间换成在一棵树上呢？ 维护一棵树，树上的每个点都有一个权值，支持修改树上任意一个点对的路径上，所有点的权值和以任意一个节点为根的子树上所有点的权值，查询任意一个点对的路径上的权值和和以任意一个节点为根的子树上的权值和 怎样解决？这时就需要引入“树链剖分”这一概念，即破树为链，再在链上维护线段树。 还有一类问题，是维护树上的边权。不难发现树上除根以外的所有节点 和 它的父节点的边总是唯一的，那么我们可以把边权看作点权，也就是让$v$的点权等于$u\\to v$的边权（$u$是$v$的父节点），再修改一下细节就好了。 2 概念学习树链剖分需要先引入几个概念： 重儿子（$\\text{prv}[i]$）：节点$i$的子节点中，子树大小最大的那一个。 重链：一个节点的重儿子，重儿子的重儿子，……，组成的链。 $\\text{sz}[i]$：以节点$i$为根的子树的大小（节点数量）。 $\\text{prv}[i]$：节点$i$的父节点。 $\\text{dep}[i]$：节点$i$在树上的深度（定义根的深度为$1$）。 $\\text{pos}[i]$：节点$i$映射在线段树上的节点编号，编号按照dfs的先后顺序从小到大编排。 $\\text{tid}[i]$：线段树上的节点$i$映射在原树上的节点编号，与$\\text{pos}[i]$互为反函数。 $\\text{top}[i]$：节点$i$所在的重链上，深度最低的那个节点（也可以看作重链的根）。 如下图，标记出了一棵树上的所有重链（注意，每个节点都必定在一条重链上）与重链的根，每个节点的重儿子，节点的深度、子树大小和编号（$\\text{pos}[i]$）。 注意：我们对节点进行编号的时候，优先dfs遍历当前节点的重儿子，这样就可以保证一条重链上的编号总是连续的。 二 实现1 思想那么怎么实现上面的问题呢？ 在处理出节点的dfs编号之后，我们不妨把这$n$个编号当作区间，把每条重链映射在这个区间上，如下图： 显然我们可以用线段树去维护这个区间，然后我们就可以快速的求出一条重链上任意一个点对间所有点的权值和。 跳链操作不在一条重链上呢？不妨这样想：我们不断让所在重链的深度（定义为链的根的深度）大的那个点每次跳到它所在重链的根的父节点，也就是另一条重链上。这样，最后总能让这两个点位于一条重链上。那么我们只需要在节点每条过一条重链时，记录这条重链上所有点的权值和，然后再加上最后在同一重链上是两点间的点权和，就是两点的路径上所有点的权值之和。关于权值和修改的问题也同理。 子树查询再看修改子树上的所有点权和这个操作。不难发现以$i$为根的子树，点编号的范围是$[i,i+\\text{sz}[i]-1]$。那么只需要在线段树上直接区间修改就好了。 这样，我们就可以在最高$O((log_2)^2n)$的时间里，完成一次 修改/查询 操作。 2 代码预处理：两遍dfs，分别处理出$\\text{prv}[i],\\text{sz}[i],\\text{prv}[i],\\text{dep}[i]$和$\\text{pos}[i],\\text{tid}[i],\\text{top}[i]$。 然后建立线段树，并写好跳链操作就好了。 代码：模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const int CN = 2e6+10;class fs{ //边表 public: int to,nxt; void init(int t,int n) {to=t; nxt=n;}}E[CN&lt;&lt;2];int hd[CN],ecnt = 0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x] = ecnt;}//v defineint n,m,r,R; //题目要求答案对R取余int v[CN]; //点权/*SGT*//*Segment Tree 线段树 习惯简写SGT*/int dep[CN]; //节点深度 int sz[CN]; //以节点为根的子树的大小 int imp[CN]; //节点的重儿子 int pos[CN]; //节点编号映射在线段树上的编号int tid[CN]; //线段树上节点编号映射到节点实际编号 int top[CN]; //节点所在重链的根 int prv[CN]; //节点的父亲节点 //初始化函数 void init1(int u){ dep[u] = dep[prv[u]]+1; //深度 sz[u] = 1; //子树大小 int mx = 0; //记录最大的子树大小 for(int k=hd[u]; k; k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; //更新重儿子 } }}int idx = 0; //编号 void init2(int u,int t){ pos[u] = ++idx; //更新编号 tid[idx] = u; top[u] = t; //维护链的根 if(!imp[u]) return; //叶节点 init2(imp[u], t); //优先访问重链 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=imp[u] &amp;&amp; dep[v]&gt;dep[u]) init2(v, v); //新开一条重链 }}//线段树 class SegmentTree{ public: int d[CN&lt;&lt;2],tag[CN&lt;&lt;2]; void build(int l,int r,int k){ //构造 if(l == r) return (void)(d[k] = v[tid[l]]%R); int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); d[k] = (d[k&lt;&lt;1]+d[k&lt;&lt;1|1])%R; } void PushDown(int l,int r,int m,int k,int s,int t){ //标记下传 (d[k&lt;&lt;1] += tag[k]*(m-l+1)) %= R; (tag[k&lt;&lt;1] += tag[k]) %= R; (d[k&lt;&lt;1|1] += tag[k]*(r-m)) %= R; (tag[k&lt;&lt;1|1] += tag[k]) %= R; tag[k] = 0; } void modify(int l,int r,int k,int s,int t,int x){ //修改 if(s&lt;=l &amp;&amp; r&lt;=t){ (d[k] += x*(r-l+1)) %= R; (tag[k] += x) %= R; return; } int m = (l+r)&gt;&gt;1; if(tag[k]) PushDown(l,r,m,k,s,t); if(s &lt;= m) modify(l,m,k&lt;&lt;1,s,t,x); if(m &lt; t) modify(m+1,r,k&lt;&lt;1|1,s,t,x); d[k] = (d[k&lt;&lt;1]+d[k&lt;&lt;1|1])%R; } int query(int l,int r,int k,int s,int t){ //查询 if(s&lt;=l &amp;&amp; r&lt;=t) return d[k]; int m = (l+r)&gt;&gt;1,rec = 0; if(tag[k]) PushDown(l,r,m,k,s,t); if(s &lt;= m) rec += query(l,m,k&lt;&lt;1,s,t); if(m &lt; t) rec += query(m+1,r,k&lt;&lt;1|1,s,t); return rec%R; }}sgt;//跳链函数 void PathModify(int u,int v,int x){ //路径修改 x %= R; while(top[u] != top[v]){ //跳至同一条链 if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); sgt.modify(1,n,1,pos[top[v]],pos[v],x); //修改 v = prv[top[v]]; //让深度大的向上跳 } sgt.modify(1,n,1,min(pos[u],pos[v]),max(pos[u],pos[v]),x);}void SubTreeModify(int u,int x){ //子树修改 x %= R; sgt.modify(1,n,1,pos[u],pos[u]+sz[u]-1,x); //直接修改}int PathQuery(int u,int v){ //路径查询 int ans = 0; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); ans += sgt.query(1,n,1,pos[top[v]],pos[v]); //累加 ans %= R; v = prv[top[v]]; //往上跳 } ans += sgt.query(1,n,1,min(pos[u],pos[v]),max(pos[u],pos[v])); return ans%R;}int SubTreeQuery(int x){ //子树查询 return sgt.query(1,n,1,pos[x],pos[x]+sz[x]-1); //直接返回} 三 图论应用树链剖分是一种针对树上问题的很优秀的处理想法。正是因为它太优秀了，所以他并不仅仅能当一个数据结构用，甚至可以被用来解决图论问题。 准确的说，树链剖分就是一种把“树”映射成“链”的想法，就像上面所描述的那样。对于这个“链”，我们就能进行很多处理，诸如挂上线段树，维护前缀和之类。通过这些优秀的数据结构，我们就可以很好的解决有关树上路径的诸多问题。 1 点对LCA最近公共祖先（Least Common Ancestors，LCA）也是可以用LCA求的。我们对树上的一个点对$(u,v)$进行跳链操作，直到两点处于一条重链上停止，那么此时$u,v$中深度浅（更靠近根）的那个就是$(u,v)$的LCA。 实际上这样就不需要再在树剖上挂线段树了。于是代码长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int CN = 5e5+5;class fs{ //边表 public: int to,nxt; void init(int t,int n) {to=t;nxt=n;}}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y){ E[++ecnt].init(y,hd[x]); hd[x] = ecnt;}/*SGT*/int dep[CN],prv[CN],imp[CN],sz[CN],top[CN];void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ top[u] = t; if(!imp[u]) return; init2(imp[u], t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v, v); }}int LCA(int u,int v){ //查询 (u,v) 的LCA while(top[u] != top[v]){ //跳链 if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //让 u 成为深度浅的那个 return u;} 一个LCA的例题：HDU 4547 CD Opt。 2 点对路径和 「HDU 2874」Connections between cities 给你多棵树，树有边权。每次询问一个点对$(u,v)$间的路径上的边权和，若不连通输出 Not connected。 首先是判联通，这个可以用并查集，不多讲了。 前面提到过树剖在处理边权问题的时候，可以把边权改点权。具体的做法是让边$u\\to v$的权变成$v$点的权，因为一个儿子节点只对应一个父节点，也就是只对应一条通向父节点的边。 但是这样实际在统计边权的时候上会多统计一条边，也就是两个点的LCA对应的那条边。于是我们在两个点跳到同一条重链之后（也就是求出了LCA），要把LCA往它的重儿子偏移一个节点，然后再统计边权和。但是有时候还会使得最后这个区间不存在，那么我们加个特判就好了。 另一个边权问题的例子：USACO11DEC Grass Planting。 于是点对间的边权和问题就被转化成了点对间的点权和问题。并且这个点权和还不需要支持修改，于是我们只需要树剖之后，维护一个前缀和就好了。 代码长这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int CN = 1e4+4;const string FAIL = &quot;Not connected&quot;;class fs{ //边表 public: int from,to,nxt,dist; void init(int f,int t,int n,int d) {from = f; to = t; nxt = n; dist = d;}}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z); hd[x] = ecnt;}void fs_init(){memset(hd,0,sizeof(hd)); ecnt = 0;} //边表初始化（多组数据！）class ufs{ //并查集，用来判联通 public: int fa[CN]; ufs() {for(int i=0;i&lt;=10001;i++) fa[i] = i;} //构造函数 void init() {for(int i=0;i&lt;=10001;i++) fa[i] = i;} //初始化 int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);} void merge(int x,int y) {fa[find(x)] = find(y);} bool exm(int x,int y) {return find(x) != find(y);}}con;int n; //点数/*SGT*/int top[CN],pos[CN],sz[CN],imp[CN],prv[CN],dep[CN],idx;void sgt_init(){ //树剖初始化 memset(top,0,sizeof(top)); memset(pos,0,sizeof(pos)); memset(sz,0,sizeof(sz)); memset(imp,0,sizeof(imp)); memset(prv,0,sizeof(prv)); memset(dep,0,sizeof(dep)); idx = 0;}void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ pos[u] = ++idx; top[u] = t; if(!imp[u]) return; init2(imp[u],t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v,v); }}int sum[CN]; //前缀和void NodeValInit(int u){ //边权转点权 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ sum[pos[v]] = E[k].dist; NodeValInit(v); } }}void SGT_Prep(){ //初始化树剖的主调用函数 sgt_init(); for(int i=1;i&lt;=n;i++) //枚举根，因为可能有多棵树 if(!dep[i]){ init1(i); init2(i,i); NodeValInit(i); } for(int i=1;i&lt;=n;i++) sum[i] += sum[i-1]; //推前缀和}int PathQuery(int u,int v){ //回答路径查询 int rec = 0; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); rec += sum[pos[v]]-sum[pos[top[v]]-1]; v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //u is lca u = imp[u]; //下移一个节点 if(dep[u] &gt; dep[v]) return rec; //区间不存在 return rec + sum[pos[v]]-sum[pos[u]-1];} 3 重构树后的树链剖分 「NOIP2013 D1T3」货车运输 给定一张不保证是树的图，边有边权。定义一条$x\\to y$的路径的宽度是这条路径上所有边权的最小值。每次询问图上两点对$(u,v)$间的所有路径上，宽度最大的那条路径的宽度值。 两个相邻的点间可能有多条边，那么肯定要保留边权大的。推广，考虑到要保证图的连通性，我们需要选出最少的边，使每条边的权值都尽量大，并且要求这些边不能使图的连通性改变。 那么也就是最大生成树了。重构最大生成树之后，剩下的问题就是一个查询两点路径上的最小边权。这个可以树剖，然后挂一个线段树就好了。 还有一个细节：图不保证联通。这个像上面一样用并查集维护就好了。 代码长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const int CN = 1e5+4;const int INF = 0x3f3f3f3f;class fs{ //边表 public: int from,to,nxt,dist; void init(int f,int t,int n,int d) {from=f;to=t;nxt=n;dist=d;} bool operator &lt; (const fs &amp;a)const {return dist &gt; a.dist;} //最大生成树}E[CN&lt;&lt;1];int hd[CN],ecnt = 0;void add(int x,int y,int z){ E[++ecnt].init(x,y,hd[x],z); hd[x] = ecnt;}void fs_init() {memset(hd,0,sizeof(hd)); ecnt = 0;} //边表初始化class ufs{ //并查集 public: int fa[CN]; ufs() {for(int i=0;i&lt;=10001;i++) fa[i]=i;} void init() {for(int i=0;i&lt;=10001;i++) fa[i]=i;} //初始化，为了循环利用空间 int find(int x) {return fa[x]==x? x : fa[x]=find(fa[x]);} void merge(int x,int y) {fa[find(x)] = find(y);} bool exm(int x,int y) {return find(x) != find(y);}}con;int n; //点数/*MST*/int X[CN],Y[CN],Z[CN]; //记录选中的边void MST(){ //最大生成树 Kruskal sort(E+1,E+ecnt+1); for(int k=1;k&lt;=ecnt;k++){ int x = E[k].from,y = E[k].to; if(!con.exm(x,y)) continue; con.merge(x,y); ++X[0]; X[X[0]] = x; Y[X[0]] = y; Z[X[0]] = E[k].dist; }}void ReBuild(){ //重构树 fs_init(); con.init(); //初始化图 for(int i=1;i&lt;n;i++){ add(X[i],Y[i],Z[i]),add(Y[i],X[i],Z[i]); if(con.exm(X[i],Y[i])) con.merge(X[i],Y[i]); //维护联通性 }}/*MST end*//*SGT*/class SGT{ //线段树 支持查询静态区间最小值 public: int d[CN&lt;&lt;1],org[CN]; void build(int l,int r,int k){ if(l == r) return (void)(d[k] = org[l]); int m = (l+r)&gt;&gt;1; build(l,m,k&lt;&lt;1); build(m+1,r,k&lt;&lt;1|1); d[k] = min(d[k&lt;&lt;1], d[k&lt;&lt;1|1]); } int query(int l,int r,int k,int s,int t){ if(s&lt;=l &amp;&amp; r&lt;=t) return d[k]; int m = (l+r)&gt;&gt;1,rec = INF; if(s &lt;= m) rec = min(rec, query(l,m,k&lt;&lt;1,s,t)); if(m &lt; t) rec = min(rec, query(m+1,r,k&lt;&lt;1|1,s,t)); return rec; }}sgt;int dep[CN],pos[CN],sz[CN],top[CN],prv[CN],imp[CN],idx = 0;void init1(int u){ dep[u] = dep[prv[u]]+1; sz[u] = 1; int mx = 0; for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(!dep[v]){ prv[v] = u; init1(v); sz[u] += sz[v]; if(sz[v] &gt; mx) mx = sz[imp[u] = v]; } }}void init2(int u,int t){ pos[u] = ++idx; top[u] = t; if(!imp[u]) return; init2(imp[u], t); for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v!=prv[u] &amp;&amp; v!=imp[u]) init2(v, v); }}void NodeValInit(int u){ //边权转点权 for(int k=hd[u];k;k=E[k].nxt){ int v = E[k].to; if(v != prv[u]){ sgt.org[pos[v]] = E[k].dist; NodeValInit(v); } }}void SGT_Prep(){ //初始化树剖的主调用函数 for(int i=1;i&lt;=n;i++){ //枚举根 if(dep[i]) continue; init1(i); init2(i, i); NodeValInit(i); } sgt.build(1,n,1); //初始化线段树}int PathQuery(int u,int v){ //求 (u,v) 路径上的最小值 int mn = INF; while(top[u] != top[v]){ if(dep[top[u]] &gt; dep[top[v]]) swap(u,v); mn = min(mn, sgt.query(1,n,1, pos[top[v]],pos[v])); v = prv[top[v]]; } if(dep[u] &gt; dep[v]) swap(u,v); //u is LCA u = imp[u]; //下移一个节点 if(dep[u] &gt; dep[v]) return mn; return min(mn, sgt.query(1,n,1, pos[u],pos[v]));}/*SGT end*/int main(){ ... //Scan Data /*重构树*/ MST(); ReBuild(); /*初始化树剖*/ SGT_Prep(); ... //Answer Question return 0;}","link":"/2019/07/18/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"tags":[{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"2-SAT","slug":"2-SAT","link":"/tags/2-SAT/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"A*","slug":"A","link":"/tags/A/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"runs","slug":"runs","link":"/tags/runs/"},{"name":"Lyndon分解","slug":"Lyndon分解","link":"/tags/Lyndon%E5%88%86%E8%A7%A3/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"容斥原理","slug":"容斥原理","link":"/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"min-max容斥","slug":"min-max容斥","link":"/tags/min-max%E5%AE%B9%E6%96%A5/"},{"name":"反演","slug":"反演","link":"/tags/%E5%8F%8D%E6%BC%94/"},{"name":"瞎搞","slug":"瞎搞","link":"/tags/%E7%9E%8E%E6%90%9E/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"后缀数组","slug":"后缀数组","link":"/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线法","slug":"扫描线法","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","link":"/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"基环树","slug":"基环树","link":"/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"},{"name":"欧拉路","slug":"欧拉路","link":"/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"name":"筛法","slug":"筛法","link":"/tags/%E7%AD%9B%E6%B3%95/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"单位根反演","slug":"单位根反演","link":"/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"},{"name":"矩阵树定理","slug":"矩阵树定理","link":"/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"floyd","slug":"floyd","link":"/tags/floyd/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"差分约束","slug":"差分约束","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"费用流","slug":"费用流","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流24题","slug":"网络流24题","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"},{"name":"生成树","slug":"生成树","link":"/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"主席树","slug":"主席树","link":"/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"可持久化","slug":"可持久化","link":"/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"线性基","slug":"线性基","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"双连通分量","slug":"双连通分量","link":"/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"割顶","slug":"割顶","link":"/tags/%E5%89%B2%E9%A1%B6/"},{"name":"桥","slug":"桥","link":"/tags/%E6%A1%A5/"},{"name":"后缀树","slug":"后缀树","link":"/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"},{"name":"悬线法","slug":"悬线法","link":"/tags/%E6%82%AC%E7%BA%BF%E6%B3%95/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"五边形数","slug":"五边形数","link":"/tags/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/"},{"name":"斯坦纳树","slug":"斯坦纳树","link":"/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"李超树","slug":"李超树","link":"/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"群论","slug":"群论","link":"/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"置换群","slug":"置换群","link":"/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"},{"name":"Burnside引理","slug":"Burnside引理","link":"/tags/Burnside%E5%BC%95%E7%90%86/"},{"name":"Pólya原理","slug":"Polya原理","link":"/tags/Polya%E5%8E%9F%E7%90%86/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"圆方树","slug":"圆方树","link":"/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"仙人掌图","slug":"仙人掌图","link":"/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE/"},{"name":"生成函数","slug":"生成函数","link":"/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"NTT","slug":"NTT","link":"/tags/NTT/"},{"name":"FWT","slug":"FWT","link":"/tags/FWT/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"categories":[{"name":"OI笔记","slug":"OI笔记","link":"/categories/OI%E7%AC%94%E8%AE%B0/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"备忘录","slug":"杂谈/备忘录","link":"/categories/%E6%9D%82%E8%B0%88/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"Codeforces","slug":"题解/Codeforces","link":"/categories/%E9%A2%98%E8%A7%A3/Codeforces/"},{"name":"AtCoder","slug":"题解/AtCoder","link":"/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"Luogu","slug":"题解/Luogu","link":"/categories/%E9%A2%98%E8%A7%A3/Luogu/"},{"name":"HDU","slug":"题解/HDU","link":"/categories/%E9%A2%98%E8%A7%A3/HDU/"},{"name":"NOIP","slug":"题解/NOIP","link":"/categories/%E9%A2%98%E8%A7%A3/NOIP/"},{"name":"UVa","slug":"题解/UVa","link":"/categories/%E9%A2%98%E8%A7%A3/UVa/"}]}