<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bn&#39;s Blog</title>
  
  
  <link href="/oi-blog/atom.xml" rel="self"/>
  
  <link href="https://big-news.cn/"/>
  <updated>2023-04-15T12:58:48.612Z</updated>
  <id>https://big-news.cn/</id>
  
  <author>
    <name>ce-amtic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>终点</title>
    <link href="https://big-news.cn/2021/07/29/%E7%BB%88%E7%82%B9/"/>
    <id>https://big-news.cn/2021/07/29/%E7%BB%88%E7%82%B9/</id>
    <published>2021-07-29T14:04:00.000Z</published>
    <updated>2023-04-15T12:58:48.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>在联合省选 Day2 爆炸，爬去卷了三个月的 whk 之后，我终于还是以 D 类的身份去了 NOI2021。</p><p>在这样一个宁静的夜晚，我得以平静下来去记录一下这场本应决定我的命运的比赛，同时也记录一下我几年来所走过的漫漫 OI 长路…</p><a id="more"></a><p><del>头图取自西北某高校在 NOI2021 做宣讲时的课件。</del></p>        <div id="aplayer-JDnVMTse" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JDnVMTse"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ニリンソウ",              author: "Key Sounds Label",              url: "/oi-blog/pictures/bgm2.mp3",              pic: "/oi-blog/pictures/bgm2.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>7 月的第 1 周，期末考试结束，我的高二一年正式迎来终结。狂卷三个月之后，期末最终取得了年级 rk40+ 的成绩，还算说得过去，但是跟高一时曾经达到的水平比，已经不知道差到哪里去了。</p><p>然后是四天的放假，基本上是颓了整整四天，OI 一点没碰。而此时距离报到日仅有不到一周了，我甚至连 NOI Linux 都不会用…</p><p>7.19 返校，此时终于开始停课复健训练，唯一的感受是啥也不会，不仅新学的东西基本全忘了，而且码力下降也很大。于是选择了重点练码力（flag），毕竟省选吃过大亏（D2T1 gem）。</p><p>然后来到了喜闻乐见的报到日（7.23）。因为某些众所周知的原因，行程突然变化，导致到余姚的时候已经晚上八点多了，而且雨还下的很大。<br>去报到处领了衣服和胸牌，再去找宿舍，全身都 tm 淋得湿透透的…</p><div class="justified-gallery"><p><img src="/oi-blog/pictures/0002.jpg" alt="动车颓神.jpg"><br><img src="/oi-blog/pictures/0003.jpg" alt="arrival"><br><img src="/oi-blog/pictures/0004.jpg" alt="logo"></p></div><br><p>7.24 是理论报到日，但是并没有事情做。由于我是老年退役选手，所以我选择躺平，于是颓了一上午的 MC…<br>下午突然通知考笔试，然后好几道题不在题库里面，于是因为某些 zz 原因扣了 1pt。出来发现 sls 已经阿克了，然后同宿舍的高一队爷 fqt 因为丢失密码条扣几分的那道题扣了一分…</p><p>“丢失密码条扣五分，不知道‘丢失密码条扣五分’扣一分”</p><p>7.25 理论开幕式，因为台风直接取消了，在宿舍颓了一天的 MC。</p><h3 id="Day-1-7-26"><a href="#Day-1-7-26" class="headerlink" title="Day 1 / 7.26"></a>Day 1 / 7.26</h3><p>第一天考试，因为台风的原因晚开考了一个小时。</p><p>9:00 准时开题，T1 是个数据结构，果然练码力是对的。读完发现这是个经典模型，处理方法大概就是把树重链剖分，然后重边的状态可以简单地用线段树维护，轻边的状态只需要在父亲和儿子节点分别打修改时间戳，然后就可以做到 $O(n\log^2n)$。马上开写，写了一个半小时终于写好了，发现第二个大样例死活过不了。果断写拍，搞到 11:20 的时候终于拍上了，测一发大样例全部过掉。</p><p>然后开 T2，发现是个计数，于是就觉得不会做。去读 T3，发现又是一个有向图上加边乱搞的问题。因为省选在这上面吃过亏，于是直接打了两个题的最低档暴力走人。</p><p>还剩不到一个小时，发现 T1 的最大的大样例很水，自己随了几组大数据发现跑到了 1.5s 左右。于是大力卡常，卡到了 1.3s 左右，还是觉的不稳。</p><p>出场发现一堆人 AK 了，然后人均切 T2，觉得自己药丸。但是 D 类没有什么完不完的，心态瞬间平和了。</p><p>下午出分，T1 卡过了，100+20+28=148。</p><p>晚上听讲题，T2 是个伪数数 / 真行列式定义题，人傻了。T3 好像也不是那么难，果然老年退役选手只会打暴力，还打的很慢。。。</p><div class="justified-gallery"><p><img src="/oi-blog/pictures/0005.jpg" alt="D1T1"><br><img src="/oi-blog/pictures/0006.jpg" alt="D1T2"><br><img src="/oi-blog/pictures/0007.jpg" alt="D1T3"></p></div><br><p>7.27 没有什么事，接着在宿舍颓 MC，下午的嘉年华也没有去，好耶。</p><h3 id="Day-2-7-28"><a href="#Day-2-7-28" class="headerlink" title="Day 2 / 7.28"></a>Day 2 / 7.28</h3><p>8:00 准时开考。</p><p>先花 1h 读完题，发现什么也不会。T3 的部分分做法好像已经在样例解释中写出来了，于是决定倒开。发现算方案的时候有 $2^4$ 种情况，于是大力分讨，到最后花 1.5h 才调出来这个容斥。。+=20pts</p><p>T2 是个连分数，我还在《具体数学》上读到过，但是那一节我觉得没用就没仔细看。。好家伙，基础不牢的报应来了。想了想就算是计算答案都没法快速处理，直接打完 $O(n^2)$ 暴力走人。</p><p>T1 一看就是个乱搞题，可以我不擅长乱搞，但是 苏松松 特别擅长淦翻这种题，觉得我要完了。用四个 long long 手动实现了一个 bitset，写了个 $O(n^2/8)/O(256m\log n)$ 的数据分治（后面是 k=1），卡常发现第一个大数据跑到 13s，觉得没戏。</p><p>这时候就差不多结束了。我的 OI 生涯的最后几秒是盯着大屏幕上的时间度过的。</p><p>下午出分发现 T1 的 k=1 貌似写挂了，其他还好，于是 24+20+20=64。发现同宿舍一车 80+ 的，觉得我要完了。</p><p>然后讲题，由于某些众所周知的原因只讲了 T1 和 T3，发现 T1 是比较简单分块乱搞，觉得我真的老了。</p><p>然后高校宣讲，不过和我这个老年退役夏令营选手并没有什么关系。</p><p>晚上出分了，99+100+20+28+24+20+20=311，擦线上了 Ag 线。好家伙，现在暴力都能 Ag 了，SD 有朝一日也终于卷到了进队比拿 Ag 难的一天。</p><p>同宿舍的 fqt 比我高四分，高一就拿到了银牌，祝贺他。</p><p>hehezhou 705pts 成功 AK NOI 捧杯，tql，膜拜。</p><p>第二天闭幕式，因为要返程所以没去。</p><p><img src="/oi-blog/pictures/0008.jpg" alt="去礼堂的路上"></p><p>回头想一想，我的 OI 生涯也就如此结束了。</p><p>向前看，曾经 lcr，yym，hyd 如愿或未能如愿走过的路，我今天也走到这一步了。回顾这段旅程，我不认为有遗憾了。</p><p>向后看，下一届 dysy 的 hws，dyx，还有 OI 路上认识的神峰，神 qyc，都是 SD 的希望，祝他们有光明的前途。</p><p>今天我在这里正式退役了，成为了时代的眼泪。但是我的路并没有走完。面对 11 个月之后的高考，我仍旧要踏上征程。只愿那时，我不要再出现失误。</p><p><img src="/oi-blog/pictures/0009.jpg" alt="D2讲题时的课件"></p><p>再见了，OI，你好，whk！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在联合省选 Day2 爆炸，爬去卷了三个月的 whk 之后，我终于还是以 D 类的身份去了 NOI2021。&lt;/p&gt;
&lt;p&gt;在这样一个宁静的夜晚，我得以平静下来去记录一下这场本应决定我的命运的比赛，同时也记录一下我几年来所走过的漫漫 OI 长路…&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>「题解」生成树求和</title>
    <link href="https://big-news.cn/2021/03/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%94%9F%E6%88%90%E6%A0%91%E6%B1%82%E5%92%8C/"/>
    <id>https://big-news.cn/2021/03/23/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E7%94%9F%E6%88%90%E6%A0%91%E6%B1%82%E5%92%8C/</id>
    <published>2021-03-23T06:23:00.000Z</published>
    <updated>2021-03-28T00:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>多项式题单里面唯一会做的题/kk<br>苦痛了一中午终于调出来了，写个题解纪念一下……</p><a id="more"></a><p><a href="https://loj.ac/p/6271">原题</a></p><p>考虑先拆位 $O(\log_3c)$，然后对于这一位，需要计算所有“生成树边权在三进制下不进位加法和”在十进制下的和。</p><p>考虑由于是不进位加法，最后的结果一定是 $0,1,2$ 中的一种。那么可以在边权上放一个 $t_u(x)=x^{c_u}$，可以用矩阵树定理求出一个 $A(x)=\sum_T\prod_u t_u(x)$，我们关注的是 $A(x)\bmod x^3-1$ 这个多项式。</p><p>设结果是 $0,1,2$ 的分别有 $cnt[0/1/2]$ 棵树，假设这是第 $x(x\ge 0)$ 位，那么贡献就是 $3^x(cnt[1]+2cnt[2])$。</p><p>那么只考虑计算 $cnt[1],cnt[2]$，可以发现不需要真的做循环卷积，直接将 $\omega_3$ 代入多项式求值即可，也就是单位根反演：</p><p>$$\sum\limits_{i\ge 0}[3|(i-c)]a_i=\dfrac{1}{3}\sum\limits_{k=0}^2\omega_3^{-ck}\sum\limits_{i\ge 0}a_i\omega_3^{ki}$$</p><p>很可惜模数没有单位根，考虑 $\omega_3=e^{\text i\frac{2\pi}{3}}=-\frac{1}{2}+\text i\frac{\sqrt 3}{2}$，设 $\text i^2=-3$ 扩域即可。</p><p>这样就是 $O(3n^3\log_3c)$。</p><p>注意基尔霍夫矩阵是度数矩阵减掉邻接矩阵，这里 $u$ 的度数指的是所有与其相邻点的边权和！！因为这个点自闭了一中午/kk</p><p>大常数辣鸡代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL; <span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">110</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, i2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>, a = (LL)a * a % P) <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = (LL)r * a % P;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> qp(x, P - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COMP</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> a, b;</span><br><span class="line">    COMP <span class="keyword">operator</span> + (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span> &#123;COMP r; r.a = add(a, o.a), r.b = add(b, o.b); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    COMP <span class="keyword">operator</span> - (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span> &#123;COMP r; r.a = add(a, P - o.a), r.b = add(b, P - o.b); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    COMP <span class="keyword">operator</span> * (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span>&#123;</span><br><span class="line">        COMP r; </span><br><span class="line">        r.a = (((LL)a * o.a - (LL)<span class="number">3</span> * b * o.b) % P + P) % P;</span><br><span class="line">        r.b = ((LL)a * o.b + (LL)b * o.a) % P;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[CN][CN], w[<span class="number">5</span>];</span><br><span class="line"><span class="function">COMP <span class="title">I</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;COMP o; o.a = a, o.b = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">extinv</span><span class="params">(COMP o)</span> </span>&#123;<span class="keyword">return</span> ((LL)o.a * o.a + (LL)<span class="number">3</span> * o.b * o.b) % P;&#125;</span><br><span class="line"><span class="function">COMP <span class="title">inv</span><span class="params">(COMP o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o.b) o.b = P - o.b; <span class="keyword">int</span> t = ((LL)o.a * o.a + (LL)<span class="number">3</span> * o.b * o.b) % P;</span><br><span class="line">    t = (t + P) % P, t = inv(t), o.a = (LL)o.a * t % P, o.b = (LL)o.b * t % P; </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">COMP <span class="title">ne</span><span class="params">(COMP o)</span> </span>&#123;<span class="keyword">if</span>(o.a) o.a = P - o.a; <span class="keyword">if</span>(o.b) o.b = P - o.b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, B, X[CN * CN], Y[CN * CN], W[CN * CN], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">while</span>(i) x /= <span class="number">3</span>, i--; <span class="keyword">return</span> x % <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function">COMP <span class="title">det</span><span class="params">()</span></span>&#123;</span><br><span class="line">    COMP res = I(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = i; <span class="keyword">while</span>(p &lt; n &amp;&amp; !extinv(a[p][i])) p++;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= n) <span class="keyword">return</span> I(<span class="number">0</span>, <span class="number">0</span>); <span class="keyword">if</span>(i ^ p) swap(a[p], a[i]), res = ne(res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            COMP t = a[j][i] * inv(a[i][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; n; k++) a[j][k] = a[j][k] - t * a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> bi, <span class="keyword">int</span> pw)</span></span>&#123;</span><br><span class="line">    COMP cnt1 = I(<span class="number">0</span>, <span class="number">0</span>), cnt2 = I(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = X[j], v = Y[j], c = bit(W[j], bi);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>) a[u][v] = a[v][u] = ne(w[<span class="number">0</span>]), a[u][u] = a[u][u] + w[<span class="number">0</span>], a[v][v] = a[v][v] + w[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">1</span>) a[u][v] = a[v][u] = ne(w[i]), a[u][u] = a[u][u] + w[i], a[v][v] = a[v][v] + w[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">2</span>) a[u][v] = a[v][u] = ne(w[i &lt;&lt; <span class="number">1</span>]), a[u][u] = a[u][u] + w[i &lt;&lt; <span class="number">1</span>], a[v][v] = a[v][v] + w[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        COMP cur = det(); cnt1 = cnt1 + cur * inv(w[i]), cnt2 = cnt2 + cur * inv(w[i &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = add(ans, add((LL)cnt1.a * pw % P, (LL)<span class="number">2</span> * cnt2.a * pw % P));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;sum.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>), freopen(<span class="string">&quot;sum.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), m = read(), w[<span class="number">0</span>] = I(<span class="number">1</span>, <span class="number">0</span>), w[<span class="number">1</span>] = I(P - i2, i2), w[<span class="number">2</span>] = w[<span class="number">1</span>] * w[<span class="number">1</span>], w[<span class="number">3</span>] = w[<span class="number">0</span>], w[<span class="number">4</span>] = w[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) X[i] = read(), Y[i] = read(), B = max(B, W[i] = read());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, pw = <span class="number">1</span>; pw &lt;= B; pw *= <span class="number">3</span>, k++) work(k, pw); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL)inv(<span class="number">3</span>) * ans % P); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>LOJ垫底了…我也不知道为什么常数会这么大…</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多项式题单里面唯一会做的题/kk&lt;br&gt;苦痛了一中午终于调出来了，写个题解纪念一下……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="反演" scheme="https://big-news.cn/tags/%E5%8F%8D%E6%BC%94/"/>
    
      <category term="单位根反演" scheme="https://big-news.cn/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
      <category term="矩阵树定理" scheme="https://big-news.cn/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Border的四种求法</title>
    <link href="https://big-news.cn/2021/03/10/Border%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B1%82%E6%B3%95/"/>
    <id>https://big-news.cn/2021/03/10/Border%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B1%82%E6%B3%95/</id>
    <published>2021-03-10T06:50:00.000Z</published>
    <updated>2023-04-15T13:01:45.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>“我问你，border 有四种求法*，你知道么？”</p><p>*Border 的四种求法：指毛估，哈希，KMP 和 runs，其中最后一种求法极其罕见。</p><a id="more"></a><h3 id="Peroid-amp-Border"><a href="#Peroid-amp-Border" class="headerlink" title="Peroid &amp; Border"></a>Peroid &amp; Border</h3><ul><li>（Border）我们定义串 $s$ 的一个非空严格前缀 $s[:k]$ 是 $s$ 的 border，当且仅当 $s[:k]=s[|s|-k+1:]$。注意这里 $k\in[1,|s|)$。</li></ul><p>Border 具有一个优良的性质：$s$ 的一个前缀在 $s$ 中的全部出现位置，即是其在 $s$ 的失配树上的子树中的所有节点。而实际上，失配树上一个节点的祖先，即是这个节点的最长 border 所代指的前缀。</p><p>这样我们可以利用这个性质解决一系列单模式匹配问题，唯一的需求是快速建立失配树的结构。</p><p>这可以用 KMP 算法来解决：维护当前匹配的最长 border $p$，考虑扩展出一个字符 $c$ 之后，只需要验证 $p$ 到根的这一段路径上，有没有一个节点的下一个字符是 $c$。我们暴力跳失配树，容易发现每条树边只会被经过 $O(1)$ 次，因此总复杂度是均摊 $O(n)$。</p><p>注意这里的 border 针对的是同一个串而言，当然我们也可以在不同串之间定义 border，这就出现了 AC 自动机（多模式匹配）和 KMP 自动机（可回撤匹配）等一系列结构。</p><p>Border 在扩展 KMP 算法中还体现了另一个应用，因为不是特别有启发性所以这里跳过。</p><ul><li>（周期）我们定义一个整数 $r\in [1,|s|]$ 是串 $s$ 的周期，当且仅当 $\forall i\in[1,|s|-r]$，满足 $s[i]=s[i+r]$。我们称一个串所有周期中最小的那个为 $s$ 的最小周期，记作 $per(s)$。</li></ul><p>接下来证明一个结论：“$s[:k]$ 是 $s$ 的 border”等价于“$|s|-k$ 是 $s$ 的周期”。</p><p>考虑先证充分性，可以发现 $2k\le |s|$ 的情况是 trivial 的。我们考虑 $2k &gt; |s|$，此时设 $s=XA$，其中 $|A|=k$ 是 $s$ 的 border，可以发现 $X$ 必然是 $A$ 的严格前缀，那么去掉 $X$ 之后，可以转化为同样的问题，最后只会剩下 $X$ 的一段前缀。于是充分性得证，不难发现必要性也同理。</p><p>这意味着，一个串的所有周期和它的所有 border 是等价的集合。</p><p>关于周期，我们知道一些重要的结论：</p><ul><li>（Weak Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。</li><li>（Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q-(p,q)\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。</li></ul><p>这意味这周期的出现是极其规律的。或者换个角度讲，border 的出现也是非常规律的！</p><p>可以发现如下规律：</p><ul><li>对于串 $a,b$，满足 $2|a|\ge b$，则 $a$ 在 $b$ 中的匹配位置构成一个公差为 $per(a)$ 的等差数列。</li><li>对于串 $s$，$s$ 的所有长度大于等于 $\frac{|s|}{2}$ 的 border 构成一个等差数列。</li><li>对于串 $s$，$s$ 的所有 border 排序后形成 $\log |s|$ 段等差数列。</li></ul><p>对于第一和第二个结论，可以通过 WPL 简单证明；而第三个结论只需再利用 “border 的 border 还是 border”这个性质即可证明。</p><h3 id="Runs-amp-Lyndon-Factorize"><a href="#Runs-amp-Lyndon-Factorize" class="headerlink" title="Runs &amp; Lyndon Factorize"></a>Runs &amp; Lyndon Factorize</h3><p>我们考虑从另一个角度理解周期，引入 runs 的概念：</p><ul><li>（Runs）我们定义一个三元组 $(l,r,p)$ 是 $s$ 的一个 run，当且仅当 $per(s[l:r])=p$，且 $2p\le r-l+1$，且 $s[l:r]$ 是极长的一段最小周期为 $p$ 的串。特别的，实数 $\frac{r-l+1}{p}$ 称作一个 run 的指数。</li></ul><p>可以发现这个东西和周期联系密切，它的本质即是对极长严格周期串（即满足 $2per(s)\le |s|$）按照它们的最小周期分类。</p><ul><li>（The Runs Theorem）记 $\rho(n)$ 表示长为 $n$ 的串至多含有的 run 的数量，$\sigma(n)$ 表示长为 $n$ 的串所有 run 的指数和的最大值，那么有 $\rho(n)&lt;n,\sigma(n)\le 3n-3$。</li></ul><p>这意味着我们可以求出一个串的所有 run，考虑怎么求。</p><ul><li>（Lyndon 串）设 $&lt;_\iota$ 是比较运算符，其中 $\iota=0/1$，分别对应两种相反的比较，这里令 $&lt;_0\Leftrightarrow&lt;,&lt;_1\Leftrightarrow &gt;$。我们称 $s$ 是关于 $&lt;_\iota$ 的 Lyndon 串，当且仅当 $\forall i\in [2,|s|]$，满足 $s&lt;_\iota s[i:|s|]$。</li><li>（Lyndon 分解）称 $a_1a_2…a_n=s$ 是 $s$ 关于 $&lt;_\iota$ 的 Lyndon 分解，当且仅当所有 $a_i$ 均是关于 $&lt;_\iota$ 的 Lyndon 串，且 $a_i\not&lt;_\iota a_{i+1}$。可以证明，一个串的 Lyndon 分解存在且唯一。</li><li>（Lyndon Root）称 $\lambda=s[l_\lambda:r_\lambda]$ 是一个 run $u=(l,r,p)$ 关于 $&lt;_\iota$ 的 Lyndon Root，当且仅当 $[l_\lambda:r_\lambda]\subseteq [l,r]$，且 $\lambda$ 是一个 Lyndon 串。</li></ul><p>考虑反过来求每个 Lyndon Root。</p><p>我们把串 Lyndon 分解，然后枚举一个 $i$，设 $ed[i]$ 是这一段 Lyndon 分解的边界，那么以 $i$ 开头的 Lyndon 子串的右端点不会超过 $ed[i]$，一段 Lyndon Root 也必然是 $s[i:ed[i]]$ 的子串。</p><p>我们从这里开始，二分哈希找到包含 $s[i:ed[i]]$ 的极长循环子串 $s[l:r]$。如果这段子串合法（满足 runs 的定义），那么就找到了一个 run。显然一个 $s[l:r]$ 可能被统计多次，我们应当取周期最小的那一次。</p><p>如果对 $\iota=0/1$ 均做一遍这样的操作，我们就可以得到所有的 run。</p><p>我们发现依赖 runs 具有的优良性质，可以解决一系列周期相关的问题以及 border 相关的问题。这种方法比 SAM 等常见处理办法更加简洁，在时间和空间上可以获得进一步的优化。</p><p>但是这也是有局限的，因为 runs 无法表出非严格周期串，否则复杂度就错了。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个仅包含小写拉丁字母的字符串 $s$。有 $q$ 次询问，每次询问形如 $(l,r)$，表示询问 $s[l:r]$ 这一段子串是否可以被表示成 $s[l:r]=X^kX’$ 的形式，其中 $X$ 是任意字符串，$X’$ 是 $X$ 的可空前缀，$k\ge 2$。</p><p>对于每次询问，如果这样的 $X$ 存在，输出最短的 $X$ 的长度；否则，输出 $-1$。</p><p>全部数据满足 $|s|,q\le 10^6$，TL = 2s(-O2) / ML = 128Mb。</p></div></article><p>显然求 $per(s[l:r])$ 等价于求 $s[l:r]$ 的最长 border，直接 KMP 即可 $O(q|s|)$。</p><p>求出 $s$ 的 runs，那么每次询问相当于矩形取 $\min$，直接离线二维数点即可，复杂度 $O((|s|+q)\log |s|)$。</p><p>需要特别说明的是，如果没有 $k\ge 2$ 的限制，那么本题相当于<a href="https://www.luogu.com.cn/problem/P4482">「BJWC2018」Border 的四种求法</a>，解法也不再这样简单。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《The Runs Theorem and Lyndon Tree》杨骏昭、徐翊轩、陈孙立，WC2019 讲稿</li></ul><p>相关题目：</p><ol><li>暂无来源</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“我问你，border 有四种求法*，你知道么？”&lt;/p&gt;
&lt;p&gt;*Border 的四种求法：指毛估，哈希，KMP 和 runs，其中最后一种求法极其罕见。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://big-news.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://big-news.cn/tags/KMP/"/>
    
      <category term="runs" scheme="https://big-news.cn/tags/runs/"/>
    
      <category term="Lyndon分解" scheme="https://big-news.cn/tags/Lyndon%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>同余数论乱讲</title>
    <link href="https://big-news.cn/2021/01/22/%E5%90%8C%E4%BD%99%E6%95%B0%E8%AE%BA%E4%B9%B1%E8%AE%B2/"/>
    <id>https://big-news.cn/2021/01/22/%E5%90%8C%E4%BD%99%E6%95%B0%E8%AE%BA%E4%B9%B1%E8%AE%B2/</id>
    <published>2021-01-22T05:45:00.000Z</published>
    <updated>2021-04-05T02:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>对最近学的数论知识做一些总结，内容比较杂乱，包括但不限于中国剩余定理、欧拉定理、阶和原根、二次剩余。</p><a id="more"></a><p>想不到一写又是 4k 字，害怕害怕……</p><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>先从不定方程开始扯。给出一个形式化的定义：我们称关于 $x,y$ 的，形如 $ax+by=c$ 的方程为二元一次不定方程。</p><ul><li>（裴蜀定理）关于 $x,y$ 的，形如 $ax+by=(a,b)$ 的不定方程总存在整数解。</li></ul><p>可以简单推广出一个普遍性的结论：对于不定方程 $ax+by=c$，它存在整数解的充要条件是 $(a,b)|c$，证明如下：</p><ol><li><p>（充分性）$ax+by=c\Rightarrow ax/(a,b)+by/(a,b)=c/(a,b)$</p></li><li><p>（必要性）根据裴蜀定理，可以构造 $x’,y’$ 使得 $ax’+by’=(a,b)$，那么有 $x=cx’/(a,b),y=cy’/(a,b)$</p></li></ol><p>显然一个线性同余方程 $ax\equiv b\text{ }(\text{mod }p)$ 可以看作不定方程 $ax+tp=b$，其中 $x,t$ 是未知量。根据上面的推导，可以得到该方程存在解的充要条件是 $(a,p)|b$。注意这个条件的本质实际上是 $(a,p)|(b,p)$。</p><p>这个条件启发我们，如果 $ax\equiv b\text{ }(\text{mod }p)$有解，那么它可以被改写作 $ax/(a,p)\equiv b/(a,p)\text{ }(\text{mod } p/(a,p))$。</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>如果存在一个 $x\in \mathbb F_p$，使得 $ax\equiv 1\text{ }(\text{mod }p)$，那么称 $x$ 是 $a$ 在 $\mathbb F_p$ 下的逆元，记作 $x= a^{-1}\bmod p$。</p><p>根据上面的推导，$a$ 在 $\mathbb F_p$ 下的逆元存在当且仅当 $(a,p)=1$，即 $a,p$ 互质。</p><p>考虑模合数的剩余系下，只有一些数字存在逆元，因此在 OI 中，需要求模合数的逆元的情况比较少见。这一类情况需要用到扩展欧几里得算法，相关资料可以在博客中找到。</p><p>对于模质数的逆元，会在下面进一步讨论。</p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>中国剩余定理给出了一组线性同余方程的解在某种意义下的近似，其中“某种意义”特指对所有方程的模数的 LCM 取模。</p><p>形式化地，对于 $n$ 条关于 $x$ 的线性同余方程，第 $i$ 条形如 $a_ix\equiv b_i\text{ }(\text{mod }p_i)$，那么中国剩余定理给出了如下求解 $x$ 的方法：</p><p>令 $P=\prod\limits_{i=1}^n p_i$，记 $k_i=P/p_i,k^{-1}_i=k_i^{-1}\bmod p_i$，计算 $x=\prod\limits_{i=1}^n k_ik^{-1}_i\bmod P$。需要特别注意的是，这里模数的变化是很关键的。</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉定理指出，如果 $(a,p)=1$，那么有：</p><p>$$a^{\varphi(p)}=1\text{ }(\text{mod }p)$$</p><p>特别的，如果 $p$ 是质数，那么 $\varphi(p)=p-1$，有 $a^{p-1}=1\text{ }(\text{mod }p)$，这样就得到了费马小定理。这可以用来求逆元：$a·a^{p-2}\equiv 1\text{ }(\text{mod }p)$。</p><p>通过欧拉定理可以简单得到，如果 $(a,p)=1$，那么对任意 $n\in \mathbb N$，存在：</p><p>$$a^n\equiv a^{n\bmod \varphi(p)}\text{ }(\text{mod }p)$$</p><p>这指出了在剩余系下，与模数互质的数的幂次是成环的。这个环将会在下面对阶和原根的讨论中反复出现。</p><p>注意上面的柿子还有一个推广形式，即对 $(a,p)&gt;1,n&gt;\varphi(p),n\in \mathbb N$，存在：</p><p>$$a^n\equiv a^{n\bmod \varphi(p)+\varphi(p)}\text{ }(\text{mod }p)$$</p><p>这意味着只有当 $n$ 足够大的时候，它才会进入一个环。</p><h3 id="阶和原根"><a href="#阶和原根" class="headerlink" title="阶和原根"></a>阶和原根</h3><ul><li>（阶）对于 $(a,p)=1$，必然存在至少一个 $c\in \mathbb N^+$，使得 $a^c\equiv 1\text{ }(\text{mod }p)$。我们称满足条件的最小的 $c$ 为 $a$ 模 $p$ 的阶，记作 $c=\text{ord}_pa$。</li></ul><p>考虑阶的实际意义：欧拉定理指出了一个与模数互质的数的幂次会成环，并且给出了环长的上界，而阶更精确地确定了这个环长是多少。</p><ul><li>（原根）对于 $g\in \mathbb F_p$，如果 $\text{ord}_pg=\varphi(p)$，则称 $g$ 是模 $p$ 的原根。</li></ul><p>原根的特殊之处在于，原根的环是该剩余系下一个数的幂次可以得到的最大的环，原根的幂次可以填充整个简化剩余系。或者说我们可以用原根定义离散对数，即设 $\log_g x=t$，其中 $t\in \mathbb F_p$，是唯一的满足 $g^t\equiv x\text{ }(\text{mod }p)$ 的数。</p><p>注意原根不能填充整个剩余系。这意味着对于非质数模数，即便是正数的离散对数也可能不存在。</p><p>更加深刻的取理解阶和原根，可以发现一个数 $a$ 的幂次形成的环，实际上就是原根以 $(\log a,\varphi(p))$ 为步长走过的环上的点。形式化的，对于 $(a,p)=1$，$a^n\bmod p,n\in\mathbb N$ 的所有取值是：</p><p>$$g^{kt},t=(\log a,\varphi(p)),k\in[0, \text{ord}_pa)$$</p><p>也可以简单归纳出阶的一些性质：</p><p>$$\begin{aligned} &amp;\text{ord}_pa|\varphi(p)\newline&amp;\text{ord}_pa^k=\dfrac{\text{ord}_pa}{(\text{ord}_pa,k)} \end{aligned}$$</p><h3 id="计算阶和原根"><a href="#计算阶和原根" class="headerlink" title="计算阶和原根"></a>计算阶和原根</h3><p>注意到 $\text{ord}_pa|\varphi(p)$，因此直接暴力枚举 $\varphi(p)$ 的因数，就可以做到 $O(\sqrt p)-O(d(\varphi(p)))$ 计算阶，实现的好就是 $O(p^{1/4})-O(d(\varphi(p)))$。</p><p>可以证明，一个数 $m$ 存在原根的充要条件是 $m=2,4,p^\alpha,2p^\alpha$，其中 $p$ 是奇素数，$\alpha\in \mathbb N^+$ 。</p><p>可以证明，如果一个数存在原根，那么这个数的最小原根是 $m^{1/4}$ 级别。</p><p>原根有着这样的一个判定方法，即 $g$ 是原根等价于 $\forall i,g^{\varphi(p)/\rho_i}\not\equiv 1\text{ }(\text{mod }p)$，其中 $\rho_i$ 是 $\varphi(p)$ 的质因子。</p><p>因此直接暴力枚举判断就可以找到最小原根，期望复杂度 $O(p^{1/4}\log^2 p)$。</p><p>可以证明，设 $g$ 是 $p$ 的一个原根，那么集合 $\begin{Bmatrix}g^s\bmod p\text{ | }s\in\mathbb N,(s,\varphi(p))=1\end{Bmatrix}$ 给出了 $p$ 的所有原根。</p><h3 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h3><p>北上广深（Baby Step Giant Step, BSGS）算法是一个可以在 $O(\sqrt p)$ 的时间内，求解模任意 $p\in \mathbb N^+$ 的离散对数的算法。形式化地，即解这样一个方程：</p><p>$$a^x\equiv b\text{ }(\text{mod }p)$$ </p><p>可以设阀值 $B$，令 $x=kB-r$，有 $(a^B)^k\equiv ba^r\text{ }(\text{mod }p)$。我们用哈希表预处理 $a^{kB}$ 的所有可能取值以及对应的 $k$，那么只需要枚举 $r$，查找一个 $k$ 即可。</p><p>注意 $a^{kB}\equiv ba^r\text{ }(\text{mod }p)$ 是 $a^{kB-r}\equiv b(\text{mod }p)$ 的必要不充分条件，因此还需要检验一下得到的解是否可行。特别地，当 $p$ 是质数时，转化有充分性，可以不进行特判。</p><p>注意 $a^{kB}\to k$ 是单射，因此理论上需要记录前两个值，但是毛估一下会发现只记录一个值的错误概率很低。</p><p>欧拉定理给出了 $x$ 的上界即 $2\varphi(p)$，取 $B=\lceil\sqrt {2p}\rceil$，可以得到最优复杂度 $O(\sqrt p)$。</p><p>代码可以在模板梳理中找到。</p><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><ul><li>（二次剩余）对于一个数 $n$ 满足 $p\nmid n$，如果存在一个 $x\in \mathbb F_p$ 使得 $x^2\equiv n\text{ }(\text{mod }p)$，那么称 $n$ 是模 $p$ 的二次剩余；否则，则称 $n$ 是模 $p$ 的非二次剩余。</li></ul><p>可以证明，如果不考虑 $0$，那么一个数的二次剩余和非二次剩余各有恰 $\dfrac{p-1}{2}$ 个。</p><ul><li>（勒让德符号）定义一个数 $n$ 模 $p$ 的勒让德符号 $(\frac{n}{p})$ 是一个在 $-1,0,1$ 之间的整数。定义当 $p|n$ 时 $(\frac{n}{p})=0$，当 $n$ 是模 $p$ 的二次剩余时 $(\frac{n}{p})=1$，否则 $(\frac{n}{p})=-1$。</li><li>（欧拉判别准则）$\left(\dfrac{n}{p}\right)\equiv n^{(p-1)/2}\text{ }(\text{mod }p)$ </li></ul><p>以上三条给出了二次剩余的定义以及判定方法。如果以及判定了 $n$ 是二次剩余，这意味着 $x^2=n\text{ }(\text{mod }p)$ 将会有解，接下来我们讨论解这个同余二次方程。</p><p>首先考虑解的数量。假设存在任意多的解，取其中不相等的两个 $x_0,x_1$，那么有：</p><p>$$\begin{aligned} &amp;x_0^2\equiv x_1^2 &amp;\text{ }(\text{mod }p)\newline \Leftrightarrow &amp;(x_0-x_1)(x_0+x_1)\equiv0&amp;\text{ }(\text{mod }p)\end{aligned}$$</p><p>考虑 $x_0\neq x_1$，那么必然有 $x_0+x_1\equiv 0\text{ }(\text{mod }p)$，也就是说互不相同的两个解必然互为相反数。这同时可以说明，这个方程至多有两个解。</p><p>Cipolla 算法可以在模质数的前提下求出其中的一个解。</p><h3 id="Cipolla’s-Algorithm"><a href="#Cipolla’s-Algorithm" class="headerlink" title="Cipolla’s Algorithm"></a>Cipolla’s Algorithm</h3><p>设 $p$ 是一个质数，考虑找到一个数 $a$，使得 $a^2-n$ 是模 $p$ 的二次非剩余。由于随机一个数有 $1/2$ 的概率是二次非剩余，那么只需要期望两次操作就可以找到。</p><p>定义虚数单位 $\text i$ 为满足 $\text i^2=a^2-n$ 的数，在模意义下建立一个类复数域，有 $x\equiv (a+\text i)^{(p+1)/2}\text{ }(\text{mod }p)$，证明如下：</p><p>$$\begin{aligned} (a+\text i)^{(p+1)/2}&amp;\equiv [(a+\text i)(a+\text i)^p]^{1/2} &amp;\text{ }(\text{mod }p)\newline &amp;\equiv [(a+\text i)(a^p+\text i^p)]^{1/2}&amp;\text{ }(\text{mod }p)\newline &amp;\equiv [(a+\text i)(a-\text i)]^{1/2}&amp;\text{ }(\text{mod }p)\newline &amp;\equiv (a^2-\text i^2)^{1/2}\equiv n^{1/2}&amp;\text{ }(\text{mod }p)\end{aligned}$$</p><p>这是因为有 $a^p\equiv a·a^{p-1}\equiv a\text{ }(\text{mod }p)$，并且 $i^p\equiv i(i^2)^{(p-1)/2}\equiv i(a^2-n)^{(p-1)/2}\equiv -i\text{ }(\text{mod }p)$，并且 $(a+b)^p\equiv a^p+b^p\text{ }(\text{mod }p)$。</p><p>那么只需要实现一个复数类，做快速幂即可，复杂度 $O(\log p)$。代码可以在模板梳理中找到。</p><h3 id="高次剩余"><a href="#高次剩余" class="headerlink" title="高次剩余"></a>高次剩余</h3><p>在模质数的意义下，求解形如 $x^a\equiv n\text{ }(\text{mod }p)$ 有一类简单且普适性的 $O(\sqrt p)$ 求解方法。具体如下：</p><p>因为是模质数，所以简化剩余系下只有 $0$ 没有被覆盖。如果 $x=0$，那么已经做完了，否则 $x$ 的离散对数一定存在。此时可以认为 $n\neq 0$，对两边同时取离散对数，我们可以得到：</p><p>$$a\log x\equiv \log n\text{ }(\text{mod }\varphi(p))$$</p><p>实则是一个不定方程，可以直接求解。因此复杂度只有计算离散对数的 $O(\sqrt p)$。如果 $p$ 很小，也可以直接预处理离散对数，那么回答的复杂度应该不会高于 $\log p$。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个数字 $n$，判断其是否为完全平方数。 $n\le 10^{1000000}$</p></div></article><p>直接大力高精度开根，存在 $O(n\log n)$ 的牛顿迭代做法，但是细节太多。比较容易理解的是 $O(n\log^2 n)$ 做法，即朴素牛迭，不过要借助 $O(n\log n)$ 高精度整除的科技。这都不太好做。</p><p>考虑随机一个质数 $P$，如果 $P\nmid n$，那么 $n$ 是完全平方等价于 $n$ 是模 $p$ 的二次剩余，使用欧拉准则判断即可。由于不一定满足 $P\nmid n$，所以多随机几个即可。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一个长度为 $n$ 的序列 $\left\langle a\right\rangle$。有 $q$ 次操作，分为两种类型：</p><ul><li>修改操作每次给定区间 $[l,r]$，令这一段区间内的每个元素执行操作 $a’_i\gets c^{a_i}\bmod p$，其中 $c,p$ 在所有操作开始前给出。</li><li>询问操作给出区间 $[l,r]$，你需要求出 $[l,r]$ 内所有 $a_i$ 的和对 $p$ 取模的值。</li></ul><p>$n,q\le 5\times 10^4, p\le 10^8$</p></div></article><p>一般来说这种奇怪数据结构题都可以直接做。</p><p>考虑构造一个序列，满足 $b_0=a_i,b_j=c^{b_{j-1}}(j&gt;0)$。根据欧拉定理，第 $j$ 项的值可以这样算出来：计算 $d_0=b_0\bmod\varphi_j(p)$，然后带入第一项计算 $d_1=c^{d_0}\bmod \varphi_{j-1}(p)$，然后带入第二项计算 $d_2=c^{d_1}\bmod \varphi_{j-2}(p)$…</p><p>其中 $\varphi_1(p)=\varphi(p),\varphi_j(p)=\varphi(\varphi_{j-1}(p))(j&gt;1)$。容易发现当 $j$ 达到 $\log p$ 的级别的时候，会存在一个分界点，使得从这里往后的 $\varphi_j(p)$ 总等于 $1$。</p><p>因此只需要大力维护连续段即可，考虑到快速幂的复杂度，用线段树维护就是 $O(n\log n\log ^2p)$，并查集的话就是 $O(n\alpha(n)\log^2p)$。这里我用线段树实现的，常数大的一匹…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span>(x &gt; <span class="number">9</span>) write(x / <span class="number">10</span>); <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span> + x % <span class="number">10</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> P, d[<span class="number">101</span>]; <span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">bool</span> fla = a &gt;= p; a %= p; </span><br><span class="line">    <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            flag |= fla;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1ll</span> * r * a &gt;= p) flag |= <span class="number">1</span>;</span><br><span class="line">            r = <span class="number">1ll</span> * r * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * a * a &gt;= p) fla |= <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q, c, a[CN], len[CN], fac[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">varphi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">2</span>; d * d &lt;= x; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t % d) <span class="keyword">continue</span>;</span><br><span class="line">        fac[++fac[<span class="number">0</span>]] = d; <span class="keyword">while</span>(!(t % d)) t /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t ^ <span class="number">1</span>) fac[++fac[<span class="number">0</span>]] = t;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= fac[<span class="number">0</span>]; i++) res = res / fac[i] * (fac[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[CN &lt;&lt; <span class="number">2</span>], cnt[CN &lt;&lt; <span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pu</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;sum[k] = add(sum[lc], sum[rc]), cnt[k] = cnt[lc] + cnt[rc];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(cnt[k] = <span class="number">1</span>, sum[k] = a[l]);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; bd(l, m, lc), bd(m + <span class="number">1</span>, r, rc), pu(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[k]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        len[l]++; <span class="keyword">if</span>(len[l] == d[<span class="number">0</span>]) cnt[k]--;</span><br><span class="line">        <span class="keyword">int</span> alp = a[l] % d[len[l]]; flag = a[l] &gt;= d[len[l]]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = len[l] - <span class="number">1</span>; p; p--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) alp = qp(c, alp, d[p]);</span><br><span class="line">            <span class="keyword">else</span> alp = qp(c, alp + d[p + <span class="number">1</span>], d[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        sum[k] = alp; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    upd(l, m, lc), upd(m + <span class="number">1</span>, r, rc), pu(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> upd(l, r, k);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= m) md(l, m, lc, s, t);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; t) md(m + <span class="number">1</span>, r, rc, s, t);</span><br><span class="line">    pu(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> sum[k];</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= m) res = add(res, qu(l, m, lc, s, t));</span><br><span class="line">    <span class="keyword">if</span>(m &lt; t) res = add(res, qu(m + <span class="number">1</span>, r, rc, s, t));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), q = read(), P = read(), c = read();</span><br><span class="line">    d[d[<span class="number">0</span>] = <span class="number">1</span>] = P; </span><br><span class="line">    <span class="keyword">while</span>(d[d[<span class="number">0</span>]] ^ <span class="number">1</span>) d[d[<span class="number">0</span>] + <span class="number">1</span>] = varphi(d[d[<span class="number">0</span>]]), d[<span class="number">0</span>]++; </span><br><span class="line">    d[++d[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) len[i] = <span class="number">1</span>, a[i] = read();</span><br><span class="line">    bd(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = read(), l = read(), r = read();</span><br><span class="line">        <span class="keyword">if</span>(tp) write(qu(<span class="number">1</span>, n, <span class="number">1</span>, l, r)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> md(<span class="number">1</span>, n, <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个互不相等的整数 $a_1, a_2, \cdots, a_n$，系统会从中随机选择若干个，而你需要确定所有选出的数字。<br>你可以进行若干次询问，每次给出一个 $k$。如果 $a_k$ 被选择，那么系统会将所有选出的数中，能被表示成 $a_k^m\bmod p\text{ }(k\in\mathbb N^+)$ 的形式的数字告诉你。<br>如果系统的每次选择是等概率选一个集合，请你求出你的最小询问次数的期望，对 $998244353$ 取模。</p><p>$n\le 5000, 0&lt;a_i&lt;p\le 10^8$<br>$\text{Subtask1(50pts) : } p \text{ is prime}$<br>$\text{Subtask2(50pts) : } p=q^k, \text{ where }q\text{ is prime}$</p></div></article><p>显然这是计数题不是期望题，考虑简单转化之后，只需要求所有情况下最小操作次数的和。</p><p>用 $u\to v$ 的一条边表示 $u$ 经过一通操作之后可以变成 $v$，那么得到一张可能有环的有向图。不妨钦点对于一个等价集合，只用标号最小的那个算一次贡献，那么图上的环没有了。枚举一个点算贡献，设 $cnt$ 表示图上能到达这个点的点的数量（包括自身），那么这部分贡献就是 $2^{n-cnt}$。</p><p>考虑暴力枚举 $i,j$，如何判断一条边 $i\to j$ 存在。不考虑 $0$，由于 $p$ 是质数，那么意味着剩余系下每个数的阶都存在，离散对数也存在。那么柿子变成 $m\log a_i\equiv a_j\text{ }(\text{mod }\varphi(p))$，有解等价于 $(\log a_i,\varphi(p))|\log a_j$，等价于 $(\log a_i,\varphi(p))|(\log a_j, \varphi(p))$。考虑 $\log a_i$ 实际上描述了 $a_i$ 每次在原根形成的环上走过的步长，那么有 $(\log a_i,\varphi(p))\text{ord}_p a_i=\varphi(p)$，柿子又变成 $\text{ord}_p a_j|\text{ord}_p a_i$。</p><p>那么只需要 $O(\sqrt p)$ 预处理因子，求阶就是 $O(d(\varphi(p))\log p)$ 的，这样就有复杂度 $O(n^2+nd(\varphi(p))\log p)$。</p><p>考虑如果 $p=q^k$，这意味着不在简化剩余系里面的数字是不存在阶和离散对数一说的。考虑把数分解成 $a_i=q^{\alpha_i}\beta_i$，然后分类讨论：</p><ol><li>$\alpha_i=\alpha_j=0$，变成上面的情况；</li><li>$\alpha_i,\alpha_j &gt; 0$，那么可以直接解出来 $m=\alpha_j/\alpha_i$，快速幂判断即可；</li><li>否则，由于 $q$ 这一个质因子无论如何不会出现或者消失，那么总是不行的。</li></ol><p>那么这样就有复杂度 $O(n^2\log p)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5050</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="keyword">int</span> n, p, q = <span class="number">1</span>, K, fac[CN], ord[CN], A[CN], a[CN], b[CN], ans, p2[CN]; <span class="comment">// A[i] = a[i]q^b[i]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % p) <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % p;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d * d &lt;= n; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % d) <span class="keyword">continue</span>;</span><br><span class="line">        fac[++fac[<span class="number">0</span>]] = d, fac[++fac[<span class="number">0</span>]] = n / d;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(fac + <span class="number">1</span>, fac + fac[<span class="number">0</span>] + <span class="number">1</span>), fac[<span class="number">0</span>] = unique(fac + <span class="number">1</span>, fac + fac[<span class="number">0</span>] + <span class="number">1</span>) - fac - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// u to v</span></span><br><span class="line">    <span class="keyword">if</span>(!b[u] &amp;&amp; !b[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(ord[u] == ord[v]) <span class="keyword">return</span> u &lt; v;</span><br><span class="line">        <span class="keyword">return</span> !(ord[u] % ord[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[u] &amp;&amp; b[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == v || b[v] % b[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> qp(A[u], b[v] / b[u]) == A[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(), p = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; q == <span class="number">1</span> &amp;&amp; i * i &lt;= p; i++) <span class="keyword">if</span>(!(p % i)) q = i;</span><br><span class="line">    <span class="keyword">int</span> t = p; <span class="keyword">while</span>(q ^ <span class="number">1</span> &amp;&amp; !(t % q)) K++, t /= q; div(p - qp(q, K - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        A[i] = a[i] = read(); <span class="keyword">while</span>(q ^ <span class="number">1</span> &amp;&amp; !(a[i] % q)) b[i]++, a[i] /= q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; !ord[i] &amp;&amp; j &lt;= fac[<span class="number">0</span>]; j++)</span><br><span class="line">        <span class="keyword">if</span>(qp(a[i], fac[j]) == <span class="number">1</span>) ord[i] = fac[j];</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p2[i] = add(p2[i - <span class="number">1</span>], p2[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) cnt += ck(j, i);</span><br><span class="line">        ans = add(ans, p2[n - cnt - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li>暂无来源</li><li><a href="https://loj.ac/p/2142">「SHOI2017」相逢是问候</a></li><li><a href="https://loj.ac/p/3330">「WC2020」猜数游戏</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对最近学的数论知识做一些总结，内容比较杂乱，包括但不限于中国剩余定理、欧拉定理、阶和原根、二次剩余。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="https://big-news.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>min-max容斥学习笔记</title>
    <link href="https://big-news.cn/2021/01/04/min-max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2021/01/04/min-max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-04T05:10:00.000Z</published>
    <updated>2021-01-08T12:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，min-max 容斥简称容斥原理，或称简单容斥，或称二项式反演，是一类可以在 $O(2^n)$ 的时间内求出大小为 $n$ 的集合的元素最小值的优秀算法……</p><a id="more"></a><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>min-max 容斥即是这个柿子：</p><p>$$\begin{align} k\text{-th}\min S&amp;= \sum\limits_{T\subseteq S, T\neq \emptyset} (-1)^{|T|-k}\dbinom{|T|-1}{k-1} \max T \tag 1\newline k\text{-th}\max S&amp;= \sum\limits_{T\subseteq S, T\neq \emptyset} (-1)^{|T|-k}\dbinom{|T|-1}{k-1} \min T \tag 2\end{align}$$</p><p>证明如下。</p><p>假设存在一个系数函数 $f(x)$，使得：</p><p>$$k\text{-th}\min S= \sum\limits_{T\subseteq S, T\neq \emptyset} f(|T|) \max T$$</p><p>那么集合中第 $x$ 小值在求和中的系数是 $\sum\limits_{i=0}^{x-1} \dbinom{x-1}{i}f(i+1)$，比较系数得：</p><p>$$ [n+1=k] = \sum\limits_{i=0}^n\dbinom{n}{i}f(i+1)$$</p><p>二项式反演得：</p><p>$$\begin{aligned} f(n+1)&amp;=\sum\limits_{i=0}^n(-1)^{n-i}\dbinom{n}{i}[i+1=k]\newline &amp;= (-1)^{n+1-k}\dbinom{n}{k-1}\end{aligned} $$</p><p>从而有 $f(x)=(-1)^{x-k}\dbinom{x-1}{k-1}$，它对任意合法的 $k$ 取值均有定义，于是 $(1)$ 式得证。</p><p>$(2)$ 式也可以通过类似的方法证明，此处省略。</p><p>在 $(1),(2)$ 中取 $k=1$，还可以得到：</p><p>$$\begin{align}\min S&amp;=\sum\limits_{T\subseteq S,T\neq \emptyset} (-1)^{|T|-1} \tag 3\max T\newline \max S&amp;=\sum\limits_{T\subseteq S, T\neq \emptyset} (-1)^{|T|-1}\min T \tag 4\end{align}$$</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>设数列 $f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2](i&gt;1)$ 是斐波那契数列。给定由若干正整数构成的集合 $S$，试求 $\text{lcm}_{x\in S} f[x]$，对 $10^9+7$ 取模。<br>$|S|\le 50000, x\le 10^6$</p></div></article><p>考虑 $\text{lcm } a,b=\prod\limits_i p_i^{\max e_i,e’_i}$，其中 $p_i$ 是素数，$e_i$ 和 $e’_i$ 分别是 $a,b$ 标准分解的指数。根据 $(f[a],f[b])=f[(a,b)]$，对指数 min-max 容斥得到：</p><p>$$\begin{align} \text{lcm}_{i\in S} f[i]&amp;=\prod\limits_{T\subseteq S,T\neq \emptyset} \text{gcd}_{i\in T}f[i]^{(-1)^{|T|-1}} \newline &amp;=\prod\limits_{T\subseteq S,T\neq \emptyset} f[\text{gcd}_{i\in T}i]^{(-1)^{|T|-1}}\end{align}$$</p><p>设 $f[n]=\prod\limits_{d|n} g[d]$，简记 $\text{gcd}_{i\in T}i=\text{gcd}T$，那么有：</p><p>$$\begin{align} \text{lcm}_{i\in S} f[i]&amp;=\prod\limits_{T\subseteq S,T\neq \emptyset}\prod\limits_{d|\text{gcd}T}g[d]^{(-1)^{|T|-1}}\newline &amp;=\prod\limits_dg[d]^{\sum_{T\subseteq S,T\neq\emptyset}[d|\text{gcd}T](-1)^{|T|-1}} \end{align}$$</p><p>设 $t=\sum\limits_{x\in S}[d|x]$，考虑指数那一部分，当 $t=0$ 时它必然为 $0$，否则它可以改写成：</p><p>$$\begin{align}\sum\limits_{i=1}^t \dbinom{t}{i}(-1)^{i-1} &amp;=\dbinom{t}{0}-\sum\limits_{i=0}^t (-1)^i\dbinom{t}{i}\newline &amp;=1-\sum\limits_{i=0}^t\dbinom{i-t-1}{i}\newline &amp;=1-\dbinom{t+1-t-1}{t}=1  \end{align}$$</p><p>那么 $\sum\limits_{i=1}^t\dbinom{t}{i}(-1)^{i-1}=[t&gt; 0]$，从而答案是 $\prod\limits_{\exists x\in S,d|x}g[d]$，剩下只需要求出 $g$，由定义：</p><p>$$\begin{align}  &amp;f[n]=\prod\limits_{d|n} g[d]\newline \Leftrightarrow \text{ }&amp; \ln f[n]=\sum\limits_{d|n}\ln g[d]\newline \Leftrightarrow \text{ }&amp;\ln g[n]=\sum\limits_{d|n}\mu(n/d)\ln f[d]\newline \Leftrightarrow \text{ }&amp;g[n]=\prod\limits_{d|n}f[d]^{\mu(n/d)} \end{align}$$</p><p>即是莫比乌斯反演，那么直接做就是 $O(n(\ln n+\log P)+d(n)|S|)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * x * y % P;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; b; a = mul(a, a), b &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = mul(r, a);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> qp(x, P - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> n, f[CN], fi[CN], g[CN], p[CN], mu[CN], md[CN], d[<span class="number">20</span>], alp[<span class="number">20</span>], ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> np[CN], vis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="number">1</span>, md[<span class="number">1</span>] = <span class="number">0</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[++p[<span class="number">0</span>]] = i, md[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * p[j] &lt;= n &amp;&amp; j &lt;= p[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * p[j]; np[x] = <span class="number">1</span>, md[x] = p[j];</span><br><span class="line">            <span class="keyword">if</span>(i % p[j]) mu[x] = -mu[i]; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = add(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fi[i] = invx(f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j += i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mu[j / i]) <span class="keyword">continue</span>;</span><br><span class="line">        g[j] = mul(g[j], mu[j / i] ^ <span class="number">-1</span> ? f[i] : fi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    vis[fac] = <span class="number">1</span>; <span class="keyword">if</span>(i &gt; d[<span class="number">0</span>]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">1</span>; j &lt;= alp[i]; k *= d[i], j++) dfs(i + <span class="number">1</span>, fac * k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">for</span>(; md[t]; t /= md[t]) </span><br><span class="line">        md[t] ^ d[d[<span class="number">0</span>]] ? d[++d[<span class="number">0</span>]] = md[t], alp[d[<span class="number">0</span>]] = <span class="number">1</span> : alp[d[<span class="number">0</span>]]++;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    sieve(<span class="number">1000000</span>), n = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) work(read());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) <span class="keyword">if</span>(vis[i]) ans = mul(ans, g[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $x\in[0,2^n-1]$，与你手上的数字进行按位或操作，其中选择数字 $i$ 的概率是 $p_i$。问期望多少秒后，你手上的数字变成 $2^n-1$。<br>$n\le 20$</p></div></article><p>期望同样可以进行 min-max 容斥，即 $\max$ 代表满足所有限制的操作步数期望，$\min$ 表示满足任意限制的操作步数期望。</p><p>那么只需要求给出一个数 $T$，满足 $T$ 中任意一位被覆盖到的期望操作次数。</p><p>有一个众所周知的结论：如果重复实验直到成功，并且每次实验成功的概率相同，那么试验次数的期望是每次成功的概率的倒数。证明很简单，设 $x$ 是期望次数，$p$ 是成功概率，由 $x=1+(1-p)x$ 可以解得 $x=1/p$。</p><p>那么只需要求出一次成功的概率，即是： </p><p>$$\sum\limits_{i\cup T\neq \emptyset}p[i]=1-\sum\limits_{i\subseteq \complement_T}p[i]$$</p><p>即是高维前缀和，那么直接做就是 $O(n2^n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">int</span> n, B; DB p[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], e[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(x) r++, x -= x &amp; (-x); <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= B; i++)</span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>) p[i] += p[i ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= B; i++) e[i] = <span class="number">1</span> - p[B ^ i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] &lt; EPS) <span class="keyword">return</span> (<span class="keyword">void</span>)(<span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>));</span><br><span class="line">        e[i] = <span class="number">1</span> / e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++) ans += bits(i) &amp; <span class="number">1</span> ? e[i] : -e[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), B = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= B; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">return</span> work(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一棵 $n$ 个结点的树，你从点 $x$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。<br>有 $q$ 次询问，每次询问给定一个集合 $S$，求如果从 $x$ 出发一直随机游走，直到点集 $S$ 中所有点都至少经过一次的话，期望游走几步。起点视为一开始就被经过了一次，对 $998244353 $ 取模。<br>$n\le 18, \sum|S|\le 10^7$</p></div></article><p>min-max 容斥一下，就是求从根出发，到 $T$ 中任意一点的期望步数。设 $f[u]$ 表示从 $u$ 出发的期望步数，显然有：</p><p>$$ f[u]=1+\dfrac{1}{deg[u]}(f[fa[u]]+\sum\limits_{v:son[u]}f[v]) $$</p><p>特别的，有 $f[u]=0,u\in S$。接下来就套上树上高消那一套，即设 $f[u]=k[u]f[fa[u]]+b[u]$，有：</p><p>$$\begin{align} deg[u]f[u]&amp;=deg[u]+f[fa[u]]+f[u]\sum\limits_v{k[v]}+\sum\limits_v{b[v]} \newline \Leftrightarrow f[u]&amp;=\dfrac{1}{deg[u]-\sum k[v]}f[fa[u]]+\dfrac{deg[u]+\sum b[v]}{deg[u]-\sum k[v]}\end{align}$$</p><p>也就是 $k[u]=\dfrac{1}{deg[u]-\sum k[v]},b[u]=\dfrac{deg[u]+\sum b[v]}{deg[u]-\sum k[v]}$，我们只保留 $E(S)=f[x]$ 即可，这部分是 $O(n2^n)$。</p><p>考虑答案即是 $\sum\limits_{T\subseteq S} (-1)^{|T|-1}E(T)$，即是高维前缀和，那么直接做就是 $O(n2^n)-O(1)$，因此总复杂度 $O(n2^n+\sum|S|)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> qp(x, P - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y &amp; (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(x) r++, x -= x &amp; (-x); <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="keyword">int</span> n, q, rt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">20</span>], b[<span class="number">20</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in(u, S)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> deg = G[u].size(), sb = <span class="number">0</span>, sk = <span class="number">0</span>, M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i]; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u, S), sb = add(sb, b[v]), sk = add(sk, k[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    M = add(deg, P - sk), k[u] = invx(M), b[u] = <span class="number">1ll</span> * k[u] * add(deg, sb) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(k, <span class="number">0</span>, <span class="keyword">sizeof</span>(k)), <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">return</span> dfs(rt, <span class="number">0</span>, S), b[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = read(), q = read(), rt = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        G[u].pb(v), G[v].pb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); S++)&#123;</span><br><span class="line">        f[S] = cal(S);</span><br><span class="line">        f[S] = bits(S) &amp; <span class="number">1</span> ? f[S] : add(<span class="number">0</span>, P - f[S]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); S++)</span><br><span class="line">        <span class="keyword">if</span>(S &amp; (<span class="number">1</span> &lt;&lt; j)) f[S] = add(f[S], f[S ^ (<span class="number">1</span> &lt;&lt; j)]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = read(), u, S = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--) u = read() - <span class="number">1</span>, S |= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[S]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 种原料，每个单位时间会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\frac{p_i}{m}$，其中 $m=\sum p_i$。问收集到任意 $k$ 种原料的期望时间，对 $998244353$ 取模。<br>$k\le n\le 1000, n-k\le 10, m\le 10^4$</p></div></article><p>考虑满足任意 $k$ 条限制即是 $k\text{-th}\min$，把它转化成 $(n-k+1)\text{-th}\max$ 来求就可以仿照上例了。以下认为 $k$ 是 $n-k+1$ 来进行推导。</p><p>即是求收集到某个集合中，任意一种原料的期望时间。显然这个概率是 $\sum\limits_{i\in T} \dfrac{p_i}{m}$，期望是$\sum\limits_{i\in T} \dfrac{m}{p_i}$，那么答案就是： </p><p>$$\sum\limits_{T\neq \emptyset} (-1)^{|T|-k}\dbinom{|T|-1}{k-1}\sum\limits_{i\in T}\dfrac{m}{p_i}$$</p><p>直接做是不行的，考虑对 $k$ 和 $\sum p_i$ 分类，即设 $f[i,j,k]$ 表示考虑前 $i$ 个数，当前 $\sum p_i=j$，对 $k$ 求上式得到的和。</p><p>考虑转移，如果不选择 $i$，那么 $f[i,j,k]\gets f[i-1,j,k]$。如果选择 $i$，考虑 $j,k$ 同时变化，把组合数拆开，贡献应当是 $-(f[i-1,j-p[i],k]-f[i-1,j-p[i],k-1])$。那么递推式是:</p><p>$$ f[i,j,k]=f[i-1,j,k]+f[i-1,j-p[i],k-1]-f[i-1,j-p[i],k] $$</p><p>边界是 $f[i,0,0]=1$，那么这样 DP 的复杂度就是 $O(nm(n-k))$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="keyword">int</span> n, K, m, f[CN][<span class="number">20</span>], p[CN], inv[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = <span class="number">1e4</span>, inv[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = <span class="number">1ll</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">    n = read(), K = n - read() + <span class="number">1</span>, m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = read();</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= p[i]; j--) <span class="keyword">for</span>(<span class="keyword">int</span> k = K; k; k--)</span><br><span class="line">            f[j][k] = add(f[j][k], add(f[j - p[i]][k - <span class="number">1</span>], P - f[j - p[i]][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) ans = add(ans, <span class="number">1ll</span> * m * inv[j] % P * f[j][K] % P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://loj.ac/p/6102">「SDJX2017」第三题</a></li><li><a href="https://loj.ac/p/2127">「HAOI2015」按位或</a></li><li><a href="https://loj.ac/p/2542">「PKUWC2018」随机游走</a></li><li><a href="https://www.luogu.com.cn/problem/P4707">「LG-P4707」重返现世</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，min-max 容斥简称容斥原理，或称简单容斥，或称二项式反演，是一类可以在 $O(2^n)$ 的时间内求出大小为 $n$ 的集合的元素最小值的优秀算法……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="容斥原理" scheme="https://big-news.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
      <category term="min-max容斥" scheme="https://big-news.cn/tags/min-max%E5%AE%B9%E6%96%A5/"/>
    
      <category term="反演" scheme="https://big-news.cn/tags/%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>元旦闲扯</title>
    <link href="https://big-news.cn/2021/01/01/%E5%85%83%E6%97%A6%E9%97%B2%E6%89%AF/"/>
    <id>https://big-news.cn/2021/01/01/%E5%85%83%E6%97%A6%E9%97%B2%E6%89%AF/</id>
    <published>2021-01-01T12:30:00.000Z</published>
    <updated>2023-04-15T13:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>又是一个元旦，高二也过去了大半了。高中的最后一个元旦晚会错过了，不知道高三还有没有这样的机会。2021 是一个新的起点，想一想，还是需要写下一点东西来记一些事情的。</p><a id="more"></a><div id="aplayer-tlXXlasY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[00:19.58]なんとなく、でいいよね？总觉得…也可以吧？[00:23.27]「気があいますね」「真是心有灵犀呢」[00:27.09]おんなじ時に会いたくなるってシンクロリズム 在同一个时刻突然会变得想见到彼此[00:34.33][00:34.84]どんなあいさつだったら 该怎样打招呼[00:38.49]「気がつきますか？」「才能让她注意到？」[00:42.23]小さな声でもかならず手を振ってよ 虽然声音很小但是肯定会挥着手吧[00:48.33][00:49.46]こんな毎日が続きますようにと 许下「这样的日子能够继续下去」的愿望[00:57.51]ティースプーンを投げたら 然后把茶匙投出的话[01:03.17][01:05.25]お茶のカミサマ 聞いてくれるかも 茶叶的神明大人 或许就能听到呢[01:12.52]いつか大人になる でもでもでも遊ぼうよ 总有一天大家都会长大 但是但是但是来玩耍吧[01:20.32]お茶のカミサマ みんなを見ていて 茶叶的神明大人 注视着大家[01:27.66]やさしい大人になる そしてそして…それ以上わからないっ 要成为温柔的大人哦 然后然后然后…之后的事还不明白呢[01:37.24][01:43.43]なんとなく、がいいよね？总觉得…也可以吧？[01:47.12]「明日もきてね」「明天还要来噢」[01:50.88]きっと話したいことがあるシンクロミライ 一定还有很多想说的话 心灵相通的未来[01:58.09][01:58.58]とっても楽しいから 今天很开心哦[01:59.77]「明日もくるよ」「明天还会来的」[02:06.09]大きな声で笑っちゃえ 今日の続き放声欢笑 继续今天的话题[02:12.89][02:13.26]夢はふわふわと曖昧なままなの 梦是轻飘飘软绵绵的样子[02:21.27]ポットからの湯気みたい 就像壶中冒出的热气一样[02:26.94][02:28.99]珈琲のカミサマ 白いミルクで 咖啡的神明大人 用洁白的牛奶[02:36.30]いつか大人になる わたしたちを 描いて描绘出长大成人的 我们的模样[02:44.22]珈琲のカミサマ みんなでいつかは 咖啡的神明大人 大家一定都会[02:51.53]かわいい大人になる つもりだけど…それ以上わからないっ 成为可爱的大人…虽然这样打算 但是该怎么做呢[03:00.98][03:02.80]だからミライのあれこれを なんとなく語るけど 所以说虽然不由地就会 聊起未来的这样那样[03:11.00]なんとなく、のままわからない まあいいっか！ 但是就这样，憧憬着未知的未来 不是挺好吗[03:20.62][03:35.80]お茶のカミサマ みんなを見ていて 茶叶的神明大人 注视着大家[03:42.92]やさしい大人になる つもりだからがんばる 要成为温柔的大人 因为这样打算 所以要努力呢[03:51.01]珈琲のカミサマ 白いミルクで 咖啡的神明大人 用洁白的牛奶[03:58.14]いつか大人になる わたしたちを描いて 描绘出长大成人的 我们的模样[04:06.10]珈琲のカミサマ みんなでいつかは 咖啡的神明大人 大家一定都会[04:13.22]かわいい大人になる つもりだけど…それ以上わからないっ 成为可爱的大人…虽然这样打算 但是该怎么做呢[04:23.38]</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-tlXXlasY"),narrow: false,autoplay: false,showlrc: 2,music: {title: "なんとなくミライ",author: "Petit Rabbit's",url: "/oi-blog/pictures/bgm1.mp3",pic: "/oi-blog/pictures/bgm1.png",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p>先放一首歌，感觉扔在这里还是很应景的。</p><p>2020 年对我来说的确是不平凡的一年，从一个老年退役菜鸡变成一个老年没退役菜鸡，甚至还想去考一场 NOI，六个月之前，这是想都不敢想的事情。</p><p><a href="/2019/11/16/CSP2019%20%E9%80%80%E5%BD%B9%E8%AE%B0/">CSP2019 游记</a>里面我并没有放多少回忆，因为我混沌的高一生涯的确没能留下多少值得记录的事情。</p><p>回首半年前在宿舍对着 11D 的洛谷网课讲义硬啃 DFT，发现一个数的 $n$ 次根实际上有 $n$ 个的时候，感觉就像看到了新大陆。然而不得不说，当年的我就是这么 naive。</p><p>但是事实是我成功的苟过了 CSP2020 和 NOIP2020，为冲击省队留出了一线希望。</p><p>“苟”属于用词准确，因为根本不是我考得好，而是比我强的都考的差。</p><p>CSP2020，洛谷估分 40+75+50+0=165，挂的连骨灰都不剩下了，可是谁曾想 CCF 给我来了个 60+100+70=230。</p><p><img src="https://i.loli.net/2020/04/16/9OlFZMCiEfcXjJ1.png"><img src="https://i.loli.net/2020/04/16/9OlFZMCiEfcXjJ1.png"><img src="https://i.loli.net/2020/04/16/9OlFZMCiEfcXjJ1.png"></p><p>NOIP2020 终于没挂成暴力分，可是 90+84+0+40=214 究竟算好吗？显然不是，先不说 T3 的考场降智，实际就连 T4 80pts 的暴力都只能嘴巴，写了 60pts 却被卡常成真·暴力分。</p><p><del>人生三大错觉：CCF机子快，我能过，我是松怪</del></p><p>突击补学完一大堆知识点显然是缺少了一点积累，只能嘴巴和脑子短路这两个问题，时至今日依然成为了我考试垫底的最强动力。</p><p>可是侥幸的是路并没有在此完结，可喜可贺，2021 年，我依然是一个老年没退役菜鸡。</p><p>几年前在大佬 $w{\color{Red}{jyyy}}$ 的博客中读到一篇 NOI 游记，如下写道：</p><p>“很多寝室人都走完了，也熄灯了，此时我的 OI 路也只剩下了最后一盏。”</p><p>大佬不幸地以 Cu rk1 的成绩退役，但是至少他走完了这一程。在回忆的终点，踏上<a href="https://loj.ac/p/2718">归程</a>的时候，无论结果如何，希望我也能留下铭刻着一段时光的文字。</p><p>以上</p><p>祝各位元旦快乐。</p><p>qwq</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个元旦，高二也过去了大半了。高中的最后一个元旦晚会错过了，不知道高三还有没有这样的机会。2021 是一个新的起点，想一想，还是需要写下一点东西来记一些事情的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://big-news.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>多项式学习笔记</title>
    <link href="https://big-news.cn/2020/12/18/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/12/18/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-18T03:33:00.000Z</published>
    <updated>2023-04-15T13:01:45.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>在<a href="/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E5%A4%9A%E9%A1%B9%E5%BC%8F">模板梳理</a>中给出过一个多项式全家桶，在这里补充一下理论推导，也是对多项式基础知识的总结。限于篇幅，本篇中的解释可能会略有简短，不重要的说明已经省略。</p><a id="more"></a><h2 id="1-形式幂级数与生成函数"><a href="#1-形式幂级数与生成函数" class="headerlink" title="1 形式幂级数与生成函数"></a>1 形式幂级数与生成函数</h2><h3 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h3><p>设 $z$ 是未定元，我们定义一个形式幂级数是一个无穷级数：</p><p>$$ A(z)=a_0+a_1z^1+a_2z^2+…+a_nz^n+…=\sum\limits_{i\ge 0} a_iz^i $$</p><p>其中 $\langle a_0,a_1,a_2,…\rangle$ 是一个无穷的实系数序列。</p><p>在这里，我们并不关心 $z$ 是否代入了某个值，它如同一个“占位符”，并不参与我们的运算。</p><h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>对于任意一个序列 $\langle g_0,g_1,g_2,…,g_n\rangle$，我们可以认为其不存在的项全部等于 0，然后将其看作一个无穷的数列。这样，我们可以定义这个数列的普通生成函数（Ordinary Generating Function, OGF）是一个形式幂级数：</p><p>$$G(z)=\sum\limits_{i\ge 0} g_iz^i$$</p><p>可以定义这个数列的指数生成函数（Exponential Generating Funcion, EGF）是一个形式幂级数：</p><p>$$G(z)=\sum\limits_{i\ge 0} \dfrac{g_iz^i}{i!}$$</p><p>这样我们就通过统一化的语言来表达了一个数列，而这就是生成函数的意义所在：解决数列问题的工具。</p><p>从另一种角度来讲，生成函数也可以看作一个次数是正无穷的多项式，因此生成函数的乘法即是多项式相乘。</p><p>一般情况下，我们只关心某个生成函数的前 $n$ 项系数，记作 $A(z)\text{ }\text{mod}\text{ } z^n$。这个形式对应了一个有限项的系数序列。</p><h2 id="2-卷积"><a href="#2-卷积" class="headerlink" title="2 卷积"></a>2 卷积</h2><h3 id="乘法卷积"><a href="#乘法卷积" class="headerlink" title="乘法卷积"></a>乘法卷积</h3><p>对于数列 $f,g$，我们定义它们的乘法卷积（或者直接称作卷积）是一个数列 $c$，满足：</p><p>$$ c_i=\sum\limits_{j=0}^i f_jg_{i-j}$$</p><p>同时记作 $c=fg$。容易发现，两个数列乘法卷积的 OGF 是它们各自的 OGF 相乘得到的结果。</p><h3 id="二项卷积"><a href="#二项卷积" class="headerlink" title="二项卷积"></a>二项卷积</h3><p>对于数列 $f,g$，我们定义它们的二项卷积是一个数列 $c$，满足：</p><p>$$c_i=\sum\limits_{j=0}^i \dbinom{i}{j}f_jg_{i-j}$$</p><p>同时记作 $c=fg$，这里乘法的定义与上面的不同，但是惯用记号一样，需要根据语境来区分。容易发现，两个数列二项卷积的 EGF 是它们的 EGF 相乘得到的结果。</p><h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>对于数列 $f,g$，我们定义它们的狄利克雷卷积是一个数列 $c$，满足：</p><p>$$c_i=\sum\limits_{k|i} f_{k}g_{i/k}$$</p><p>记号同上。狄利克雷卷积在数论中很常见。</p><p>类似的，我们可以定义异或卷积 $(fg)_i=\sum\limits_{j\oplus k=i} f_jg_k$，或卷积 $(fg)_i=\sum\limits_{j\cup k=i}f_jg_k$，与卷积 $(fg)_i=\sum\limits_{j\cap k=i} f_jg_k$，其中我们用 $\oplus$ 代表按位异或，用 $\cup$ 代表按位或，用 $\cap$ 代表按位与。</p><p>除去狄利克雷卷积可以直接 $O(n\ln n)$ 计算之外，其它卷积计算的朴素实现均是 $O(n^2)$ 的。因此我们需要通过下面的这些手段去计算卷积。</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>离散傅里叶变换（Discrete Fourier Transform, DFT）是对多项式进行从系数表示到点值表示的变换。设 $f(x)$ 是一个 $n-1$ 次多项式，那么它的 DFT 对应一个长度为 $n$ 的序列 $\mathcal F(f)$，满足：</p><p>$$ \mathcal F(f)_i=f(x_i) $$</p><p>其中 $x_i(i=0,1,2,…,n-1)$ 是代入的点值。</p><p>快速傅里叶变换（Fast Fourier Transform, FFT）通过 $n$ 次单位根 $\omega_n$ 来进行 DFT，其中 $\omega_n$ 满足 $\omega_n^n=1$；在复数域下，这样的数字一共有 $n$ 个。<br>如果令 $\omega_n^1=\cos \frac{2\pi}{n}+i\sin\frac{2\pi}{n}$，那么它们分别是 $\omega_n^0,\omega_n^1,\omega_n^2,…,\omega_n^{n-1}$。</p><p>由于 $n$ 次单位根的一些特殊性质，所以当 $n=2^k$ 时，我们可以通过分治来求解点值，以及通过点值来求解系数，后者称作逆变换（Inverse Discrete Fourier Transfrom, IDFT）。</p><p>这样就得到了一个在 $O(n\log n)$ 的时间内进行 DFT 的算法（FFT）。需要注意的一点是，如果用 FFT 计算序列卷积，得到的是长度为 $n$ 的循环卷积 $(fg)_i=\sum\limits_{j+k\text{ }\text{mod }n=i}f_jg_k$，用生成函数记作：</p><p>$$F(z)G(z)\text{ }\text{mod }z^n-1$$</p><p>FFT 的代码实现可以在模板梳理中找到。</p><h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><ul><li>原根：在 $\mathbb F_R$ 下，如果一个数 $g^i$ 一共有 $\varphi(R)$ 种不同的取值，或者说 $g$ 模 $R$ 的阶是 $\varphi(R)$，那么称 $g$ 是 $\mathbb F_R$ 下的原根。</li></ul><p>可以证明，原根存在的充要条件是 $R=2,4,p^a,2p^a$，其中 $p$ 是一个素数。可以发现，素数的原根是总存在的。</p><p>考虑做长度为 $n=2^k$ 的 DFT，有没有什么方式可以避免复数运算？</p><p>对于形如 $P=a2^r+1(r\ge k)$ 的素数，设 $g$ 是 $\mathbb F_P$ 下的原根，那么 $g_n=g^{\varphi(P)/n}$ 有着与 $n$ 次单位根 $\omega_n$ 相同的性质，即 $g_n^n=1$。根据原根的性质，我们可以发现 $g_n^0,g_n^1,…,g_n^{n-1}$ 是 $n$ 个两两不同的数字，且都满足 $(g_n^l)^n\equiv g^{l\varphi(P)}\equiv 1\text{ }(\text{mod }P)$。于是，我们可以用 $g_n$ 来代替 $\omega_n$ 进行多项式变换，这样就得到了快速数论变换，本质上是 FFT 在模域下的变种。</p><p>一个质数的原根一定存在，但并不是只要存在原根就可以 NTT，另一个条件是 $n|\varphi(P)$，形象的理解即可以等分圆周。</p><p>代码同样可以在模板梳理中找到。</p><p>值得一提的是，这种计算点值的方法与单位根反演有着异曲同工之妙。单位根反演即是这个柿子：</p><p>$$[k|n]=\dfrac{1}{k}\sum\limits_{i=0}^{k-1}\omega_k^{in}$$</p><p>其中 $\omega_k$ 是 $k$ 次单位根，模义下可用 $g_k$ 来代替；这可以看作是计算了一个点值，在一些题目中会具有优良的性质。</p><h3 id="离散沃尔什变换"><a href="#离散沃尔什变换" class="headerlink" title="离散沃尔什变换"></a>离散沃尔什变换</h3><p>显然，位运算卷积不满足卷积结果的点值是原点值相乘。那么我们可以通过一些手段构造某种变换，来让我们变换出的序列满足点值相乘的规律。这些变换分别是：</p><ul><li>按位或</li></ul><p>$$\mathcal{F}(f)_i=\sum\limits_{j\cup i=i}a_j$$</p><ul><li>按位与</li></ul><p>$$\mathcal{F}(f)_i=\sum\limits_{j\cap i=i}a_j$$</p><ul><li>按位异或</li></ul><p>$$\mathcal{F}(f)_i=\sum\limits_{j=0}^{n-1} (-1)^{|i\cap j|} f_j$$</p><p>其中 $|x|$ 代表 $x$ 在二进制下为 1 的位数。可以证明，这些变换满足与 DFT 同样的性质，即点值的乘积是卷积结果的点值。</p><p>对于异或的变换，还有一个重要的柿子是 $\mathcal{F}(\mathcal{F}(f))_i=n·f_i$，可以通过代入化简来证明。</p><p>这些变换都可以通过类似 FFT 的方法在 $O(n\log n)$ 的时间内得到。代码可以参考模板梳理。</p><h2 id="3-微积分"><a href="#3-微积分" class="headerlink" title="3 微积分"></a>3 微积分</h2><p>形式幂级数的微分定义为逐项微分，即：</p><p>$$\dfrac{\text d}{\text dz} \left(\sum\limits_{i\ge 0} a_iz^i \right)=\sum\limits_{i\ge 0} (i+1)a_{i+1}z^i$$</p><p>同样的，形式幂级数的积分定义为逐项积分。我们可以定义一个形式幂级数的定积分为：</p><p>$$\int \left(\sum\limits_{i\ge 0}a_iz^i \right)\text dz=\sum\limits_{i&gt;0}\dfrac{a_{i-1}}{i}z^i$$</p><p>我们可以用微积分来分析一个幂级数的闭合形式，这在涉及指标变换的时候较为方便。</p><h2 id="4-乘法逆"><a href="#4-乘法逆" class="headerlink" title="4 乘法逆"></a>4 乘法逆</h2><p>对于幂级数 $A(z)$，我们定义它的乘法逆是一个幂级数 $B(z)$ 满足 $A(z)B(z)\equiv 1 \text{ }(\text{mod } z^n)$，记作 $B(z)=A^{-1}(z)$。</p><p>当 $A(z)$ 的常数项不为零时，它的乘法逆是总存在的。证明如下：</p><p>设 $A(z)=\sum\limits_{i=0}^{n-1} a_ix^i, B(z)=\sum\limits_{i=0}^{n-1} b_ix^i$，通过乘法逆的定义可得：</p><p>$$\begin{align} &amp;b_0=\dfrac{1}{a_0}\newline &amp;\sum\limits_{j=1}^{n-1} a_jb_{i-j}=0\text{ }(i&gt;0)\end{align}$$</p><p>对 $i$ 归纳可以得到：</p><p>$$ b_i=-b_0\sum\limits_{j=0}^{i-1}a_{i-j}b_j\text{ }(i&gt;0) $$</p><p>从而只要 $b_0$ 存在就可以构造出 $B(z)$。同时这也给出了朴素 $O(n^2)$ 求逆的方法，下一步考虑怎么优化。</p><p>设 $B_0(z)=A^{-1}(z)\text{ }\text{mod } z^n$ 是一个只有前 $n$ 项系数有效的幂级数，可以如下倍增：</p><p>$$\begin{align} B_0(z)A(z)&amp;\equiv 1\text{ }(\text{mod } z^n)\newline    (B_0(z)A(z)-1)^2&amp;\equiv 0\text{ }(\text{mod }z^{2n})\newline    B_0^2(z)A^2(z)-2B_0(z)A(z)+1&amp;\equiv 0\text{ }(\text{mod }z^{2n}) \newline    B_0(z)(2-B_0(z)A(z))&amp;\equiv B(z)\text{ }(\text{mod }z^{2n}) \end{align}$$</p><p>其中 $B(z)=A^{-1}(z)\text{ }\text{mod } z^{2n}$ 是一个只有前 $2n$ 项系数有效的幂级数。</p><p>依此倍增，复杂度 $T(n)=T(n/2)+O(n\log n)=O(n\log n)$，实现可以在代码梳理中找到。</p><h2 id="5-指对运算"><a href="#5-指对运算" class="headerlink" title="5 指对运算"></a>5 指对运算</h2><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><p>对一个高阶可导的函数 $f(x)$，它在 $x=x_0$ 处的泰勒展开式为：</p><p>$$f(x)=f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)^2}{2}+…+\dfrac{f^{(n)}(x-x_0)^n}{n!}+…$$</p><p>这是一个无穷级数。也可以只保留前 $n+1$ 项写作：</p><p>$$f(x)=f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)}{2}+…+\dfrac{f^{(n)}(x_0)}{n!}+r_n(x)$$</p><p>其中 $r_n(x)$ 指代一个余项。</p><h3 id="麦克劳林公式"><a href="#麦克劳林公式" class="headerlink" title="麦克劳林公式"></a>麦克劳林公式</h3><p>在泰勒展开的公式中，取 $x_0=0$，就得到了麦克劳林公式：</p><p>$$f(x)=f(0)+f’(0)x+\dfrac{f’’(0)x^2}{2!}+…+\dfrac{f^{(n)}(0)x^n}{n!}+…$$</p><p>亦即 $f(x)$ 在 $x=0$ 处的泰勒展开。</p><p>形式幂级数的乘方是有定义的，那么我们可以通过泰勒展开来定义如何对形式幂级数进行各种诡异的函数变换，诸如指对函数，正余弦函数，等等。</p><h3 id="指数函数和对数函数"><a href="#指数函数和对数函数" class="headerlink" title="指数函数和对数函数"></a>指数函数和对数函数</h3><p>由于 $(e^x)’=e^x$，根据麦克劳林公式，可以得到：</p><p>$$\exp x=e^x=1+x+\dfrac{x^2}{2!}+\dfrac{x^3}{3!}…$$ </p><p>这是一个无穷级数。于是可以定义一个形式幂级数的指数函数为：</p><p>$$\exp A(z)=\sum\limits_{i\ge 0}\dfrac{A^i(z)}{i!}$$</p><p>同理，因为：</p><p>$$\ln’ x=x^{-1},\ln &#39;&#39;x=-x^{-2},…,,\ln^{(n)} x=(-1)^{n-1}(n-1)!(1+x)^{-n}$$</p><p>可以定义一个形式幂级数的对数函数是：</p><p>$$\ln (1+A(z))=-\sum\limits_{i&gt;0}\dfrac{(-1)^iA^i(z)}{i}$$</p><p>注意这里的常数项是未定义的，一般认为其等于 0。</p><p>考虑如何求对数函数。设 $B(z)=\ln A(z)$，两边求导得到：</p><p>$$B’(z)=\ln’ A(z)=\dfrac{A’(z)}{A(z)}$$</p><p>即是链式法则。于是我们只需要求逆即可，复杂度 $O(n\log n)$。</p><p>多项式指数的计算需要用到牛顿迭代。</p><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>考虑计算一个函数 $f(x)$ 的零点。设 $x_0$ 是一个已知的近似解，在 $x_0$ 处对 $f(x)$ 泰勒展开，可以得到 $f(x)$ 的一个近似表达：</p><p>$$ f(x)\sim f(x_0)+f’(x_0)(x-x_0) $$</p><p>令 $f(x_0)+f’(x_0)(x-x_0)=0$，解得 $x=x_0-\dfrac{f(x_0)}{f’(x_0)}$。取 $x$ 作为下一个近似解 $x_2$，又可以进行同样的操作。可以证明，在某些情况下，这样就可以逼近 $f(x)$ 精确的零点。</p><p>设 $B(z)=\exp A(z)$，那么有 $\ln B(z)-A(z)=0$。设 $G(B(z))=\ln B(z)-A(z)$ 是一个以 $B(z)$ 为变元的形式幂级数，$B_0(z)=\exp A(z)\text{ }\text{mod }z^n$ 是已知的近似解，那么可以如下倍增（迭代）：</p><p>$$\begin{align} B(z)&amp;\equiv B_0(z)-\dfrac{\ln B_0(z)-A(z)}{1/B_0(z)}\text{ }(\text{mod } z^{2n})\newline    &amp;\equiv B_0(z)(1-\ln B_0(z)+A(z))\text{ }(\text{mod } z^{2n})\end{align}$$</p><p>依此迭代，复杂度 $T(n)=T(n/2)+O(n\log n)=O(n\log n)$，实现可以在代码梳理中找到。</p><h2 id="6-应用"><a href="#6-应用" class="headerlink" title="6 应用"></a>6 应用</h2><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>请构造一个序列 $a_1,a_2,…,a_k$，满足 $\forall i\in[1, k] a_i\in[1, n]$，使得对这个序列做无限背包计数后得到的序列的前 $n$ 项在模 $P$ 意义下是 $f_1,f_2,…,f_n$，其中 $P$ 是一个给定的质数。序列的长度没有限制，可以证明解总存在且唯一。</p><p>$n\le 2^{18},10^6\le p\le 2^{30}$</p></div></article><p>设 $b_i$ 表示序列中是否包含 $i$ 这个数字，$F(z)=\sum\limits_{i=1}^n f_iz^i$，那么有：</p><p>$$\begin{align} F(z)&amp;=\prod\limits_{i=1}^n \dfrac{1}{(1-z^i)^{b_i}}\newline    \ln F(z)&amp;=-\sum\limits_{i=1}^nb_i\ln(1-z^i)\newline    \ln F(z)&amp;=\sum\limits_{i=1}^nb_i\sum\limits_{j&gt;0}\dfrac{z^{ij}}{j}\newline    &amp;=\sum\limits_{i=1}^n z^i\sum\limits_{j|i}\dfrac{jb_j}{i}  \end{align}$$</p><p>比较系数得 $nf_n=\sum\limits_{i|n}ib_i$，亦即 $f=b*1$，莫比乌斯反演得 $b_n=\dfrac{1}{n}\sum\limits_{j|n}jf_j\varphi(n/j)$。</p><p>复杂度 $O(n(\log n+\ln n))$，需要任意模数卷积，这里用拆系数 FFT 实现。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDB long double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> LDB PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invx</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> qp(x, P - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="keyword">namespace</span> POLY&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">COMP</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>: LDB x, y;</span><br><span class="line">        COMP <span class="keyword">operator</span> + (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span>&#123;</span><br><span class="line">            COMP r = *<span class="keyword">this</span>; r.x += o.x, r.y += o.y;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        COMP <span class="keyword">operator</span> - (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span>&#123;</span><br><span class="line">            COMP r = *<span class="keyword">this</span>; r.x -= o.x, r.y -= o.y;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        COMP <span class="keyword">operator</span> * (<span class="keyword">const</span> COMP &amp;o) <span class="keyword">const</span>&#123;</span><br><span class="line">            COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="function">COMP <span class="title">mk</span><span class="params">(LDB a, LDB b)</span> </span>&#123;COMP o; o.x = a, o.y = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line">    <span class="function">COMP <span class="title">conj</span><span class="params">(COMP o)</span> </span>&#123;o.y = -o.y; <span class="keyword">return</span> o;&#125;</span><br><span class="line">    <span class="keyword">int</span> rev[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(COMP t[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) + (i &amp; <span class="number">1</span>) * (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(i &lt; rev[i]) swap(t[i], t[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(COMP t[], <span class="keyword">int</span> n, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">        cg(t, n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">2</span>; w &lt;= n; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = w &gt;&gt; <span class="number">1</span>; COMP gn = mk(<span class="built_in">cos</span>(<span class="number">2</span> * PI / (LDB)w), <span class="built_in">sin</span>(<span class="number">2</span> * tp * PI / (LDB)w));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += w)&#123;</span><br><span class="line">                COMP g = mk(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i + l; j++)&#123;</span><br><span class="line">                    COMP u = t[j], v = t[j + l] * g;</span><br><span class="line">                    t[j] = u + v, t[j + l] = u - v, g = g * gn;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tp ^ <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    COMP p[CN &lt;&lt; <span class="number">2</span>], q[CN &lt;&lt; <span class="number">2</span>], x[CN &lt;&lt; <span class="number">2</span>], y[CN &lt;&lt; <span class="number">2</span>], z[CN &lt;&lt; <span class="number">2</span>], w[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">conv</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// a = a * b</span></span><br><span class="line">        <span class="keyword">int</span> B = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>, N = <span class="number">1</span>; <span class="keyword">while</span>(N &lt; (n &lt;&lt; <span class="number">1</span>)) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = q[i] = mk(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = mk(a[i] &gt;&gt; <span class="number">15</span>, a[i] &amp; B); <span class="comment">// k1 r1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i] = mk(b[i] &gt;&gt; <span class="number">15</span>, b[i] &amp; B); <span class="comment">// k2 r2</span></span><br><span class="line">        fft(p, N, <span class="number">1</span>), fft(q, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = (N - <span class="number">1</span>) &amp; (N - i);</span><br><span class="line">            COMP k1, r1, k2, r2;</span><br><span class="line">            k1 = (p[i] + conj(p[j])) * mk(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            r1 = (p[i] - conj(p[j])) * mk(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            k2 = (q[i] + conj(q[j])) * mk(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            r2 = (q[i] - conj(q[j])) * mk(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            x[i] = k1 * k2, y[i] = r1 * r2, z[i] = k1 * r2, w[i] = k2 * r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = x[i] + y[i] * mk(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) q[i] = z[i] + w[i] * mk(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        fft(p, N, <span class="number">-1</span>), fft(q, N, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            LL X = (LL)(<span class="number">0.5</span> + p[i].x), Y = (LL)(<span class="number">0.5</span> + p[i].y), Z = (LL)(<span class="number">0.5</span> + q[i].x), W = (LL)(<span class="number">0.5</span> + q[i].y);</span><br><span class="line">            X = (X % P + P) % P, Y = (Y % P + P) % P, Z = (Z % P + P) % P, W = add((W % P + P) % P, Z);</span><br><span class="line">            a[i] = add((X &lt;&lt; <span class="number">30</span>) % P, add((W &lt;&lt; <span class="number">15</span>) % P, Y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; N; i++) a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); i++) b[i] = c[i] = <span class="number">0</span>;</span><br><span class="line">        b[<span class="number">0</span>] = invx(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">2</span>; w &lt; (n &lt;&lt; <span class="number">1</span>); w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) c[i] = a[i];</span><br><span class="line">            conv(c, b, w);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) c[i] = add(<span class="number">0</span>, P - c[i]); c[<span class="number">0</span>] = add(<span class="number">2</span>, c[<span class="number">0</span>]);</span><br><span class="line">            conv(b, c, w);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ia[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ln</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); i++) ia[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">        inv(a, ia, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) c[i] = <span class="number">1ll</span> * (i + <span class="number">1</span>) * a[i + <span class="number">1</span>] % P;</span><br><span class="line">        conv(c, ia, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) b[i] = <span class="number">1ll</span> * c[i - <span class="number">1</span>] * invx(i) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p[CN], mu[CN]; <span class="keyword">bool</span> np[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="number">1</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[++p[<span class="number">0</span>]] = i, mu[i] = P - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * p[j]; np[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j]) mu[x] = P - mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[CN &lt;&lt; <span class="number">2</span>], b[CN &lt;&lt; <span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = read() + <span class="number">1</span>, P = read();</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) a[i] = read();</span><br><span class="line">    POLY :: ln(a, b, n);</span><br><span class="line">    sieve(n), <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) b[i] = <span class="number">1ll</span> * b[i] * i % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt; n; j++)</span><br><span class="line">        a[i * j] = add(a[i * j], <span class="number">1ll</span> * mu[i] * b[j] % P);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) cnt += (!!a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="keyword">if</span>(a[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个整数 $x$，初值是 $[0,n]$ 内的一个随机值，其中为 $i$ 的概率为 $p_i$。<br>要进行 $m$ 轮操作，每次把 $x$ 等概率随机地替换成 $[0,x]$ 中的一个数字，求最后对 $\forall i\in[0, n]$，$x$ 的取值为 $i$ 的概率。对 $998244353$ 取模。</p><p>$n\le 10^5,m\le 10^{18}$</p></div></article><p>设 $f[k,i]$ 表示经过 $k$ 轮，得到 $i$ 的概率，有递推关系 $f[k,i]=\sum\limits_{j\ge i}^n f[k-1,j]/j+1$。</p><p>设 $F(k,z)=\sum\limits_{i=0}^n f[k,i]z^i$ 是 $f$ 的 OGF，根据上面的递推关系，有：</p><p>$$\begin{aligned} F(k,z)&amp;=\sum\limits_{i=0}^n z^i\sum\limits_{j=i}^n \dfrac{f[k-1,j]}{j+1}\newline    &amp;=\sum\limits_{j=0}^n \dfrac{f[k-1,j]}{j+1}\sum\limits_{i=0}^j z^i \newline  &amp;=\dfrac{1}{z-1} \sum\limits_{i=0}^n f[k-1,i]\dfrac{z^{i+1}-1}{i+1} \end{aligned}$$</p><p>考虑 $f[k-1,i]$ 转移到了哪里，容易发现它在 $F(k,·)$ 中是 $i+1$ 项系数，这个变换不容易快速实现，那么继续推导。</p><p>根据牛顿-莱布尼茨公式，可以推得：<br>$\int_1^z t^i\text{ }\text dt=\dfrac{z^{i+1}}{z-1}-\dfrac{1}{z-1}$，那么原式化为：</p><p>$$\begin{aligned} F(k,z)&amp;=\dfrac{1}{z-1}\sum\limits_{i=0}^n f[k-1,i]\int_1^z t^i\text{ }\text dt\newline   &amp;=\dfrac{1}{z-1}\int_1^z\left( \sum\limits_{i=0}^nf[k-1,i]t^i\right)\text{ }\text dt\newline   &amp;= \dfrac{1}{z-1}\int_1^z F(k-1,t)\text{ }\text dt  \end{aligned}$$</p><p>考虑原式中 $z^{i+1}-1$ 很是鬼畜，考虑把定积分的下指标改为从 0 开始，那么设 $G(k,z)=F(k,z+1)$，有：</p><p>$$\begin{aligned} G(k,z)&amp;=\dfrac{1}{z}\int_1^{z+1} F(k-1,t)\text{ }\text dt \newline   &amp;=\dfrac{1}{z}\int_0^z F(k-1,t+1)\text{ }\text d(t+1)\newline   &amp;=\dfrac{1}{z}\int_0^z G(k-1,t)\text{ }\text dt \newline    &amp;= \dfrac{1}{z}\sum\limits_{i=0}^n \dfrac{g[k-1,i]}{i+1}z^{i+1}\newline    &amp;=\sum\limits_{i=0}^n \dfrac{g[k-1,i]}{i+1}z^i \end{aligned}$$</p><p>其中 $g[k,i]$ 满足 $G(k,z)=\sum\limits_{i=0}^n g[k,i]z^i$，即是对应的序列。<br>考虑系数的变化：$k\to k+1:g[k,i]\to g[k+1,i]/(i+1)$，那么 $m$ 次变化之后就是 $g[m,i]=\dfrac{g[0,i]}{(i+1)^m}$ 这个就可以近似线性直接求出来。</p><p>那么只需要类似于 DFT 和 IDFT 那样子，把 $F$ 变成 $G$，系数修改完之后再变回来即可。</p><p>考虑怎么变，根据定义，得到：</p><p>$$\begin{aligned} G(k,z)&amp;=F(k,z+1)\newline    \Leftrightarrow \sum\limits_{i=0}^n g[k,i]z^i&amp;=\sum\limits_{i=0}^n f[k,i](z+1)^i\newline    &amp;=\sum\limits_{i=0}^n\sum\limits_{j=0}^i\dbinom{i}{j}z^jf[k,i] \newline    &amp;= \sum\limits_{i=0}^n z^i \sum\limits_{j=i}^n \dbinom{j}{i}f[k,j]\end{aligned}$$</p><p>考虑 $k=0$，得：</p><p>$$\begin{aligned} g[0,i]&amp;=\sum\limits_{j=i}^n \dbinom{j}{i}p_j\newline    &amp;= \dfrac{1}{i!}\sum\limits_{t=0}^{n-i} \dfrac{(i+t)!p_{i+t}}{t!}\end{aligned}$$</p><p>这里是差为定值的卷积，依然可以化成序列卷积，那么构造 $A(z)=\sum\limits_{i=0}^n \dfrac{1}{i!},B(z)=\sum\limits_{i=0}^n b_ix^i$，其中有 $p_ii!=b_{n-i}$，即人为令下标的和为定值，那么容易发现 $g[0,i]=\dfrac{1}{i!}[z^{n-i}]A(z)B(z)$。NTT 即可，复杂度 $O(n\log n)$。</p><p>对于 $g\to f$ 的转化，根据二项式反演，有：</p><p>$$\begin{aligned} g[k,i]&amp;=\sum\limits_{j=i}^n\dbinom{j}{i}f[k,j] \newline    \Leftrightarrow f[k,i]&amp;=\sum\limits_{j=i}^n (-1)^{j-i}\dbinom{j}{i}g[k,j] \end{aligned}$$</p><p>依然是差为定值的卷积，同理可仿照上面求出，总复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> qp(x, P - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> rev[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cg</span><span class="params">(<span class="keyword">int</span> t[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) + (i &amp; <span class="number">1</span>) * (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(i &lt; rev[i]) swap(t[i], t[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> t[], <span class="keyword">int</span> n, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    cg(t, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">2</span>; w &lt;= n; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = w &gt;&gt; <span class="number">1</span>, gn = qp(tp ? <span class="number">3</span> : inv(<span class="number">3</span>), (P - <span class="number">1</span>) / w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += w)&#123;</span><br><span class="line">            <span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i + l; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> u = t[j], v = <span class="number">1ll</span> * g * t[j + l] % P;</span><br><span class="line">                t[j] = add(u, v), t[j + l] = add(u, P - v), g = <span class="number">1ll</span> * g * gn % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tp)&#123;</span><br><span class="line">        <span class="keyword">int</span> in = inv(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) t[i] = <span class="number">1ll</span> * t[i] * in % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conv</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// A = A * B</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>; <span class="keyword">while</span>(N &lt; (n &lt;&lt; <span class="number">1</span>)) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    ntt(A, N, <span class="number">1</span>), ntt(B, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1ll</span> * A[i] * B[i] % P;</span><br><span class="line">    ntt(A, N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; N; i++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[CN &lt;&lt; <span class="number">2</span>], B[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, p[CN], fac[CN], ifac[CN], g[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = read() + <span class="number">1</span>, m = read() % (P - <span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[n - <span class="number">1</span>] = inv(fac[n - <span class="number">1</span>]); <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i + <span class="number">1</span>; i--) ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) A[n - i - <span class="number">1</span>] = <span class="number">1ll</span> * fac[i] * p[i] % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) B[i] = ifac[i];</span><br><span class="line">    conv(A, B, n); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i] = <span class="number">1ll</span> * ifac[i] * A[n - i - <span class="number">1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i] = <span class="number">1ll</span> * g[i] * inv(qp(i + <span class="number">1</span>, m)) % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) A[n - i - <span class="number">1</span>] = <span class="number">1ll</span> * fac[i] * g[i] % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) B[i] = i &amp; <span class="number">1</span> ? P - ifac[i] : ifac[i];</span><br><span class="line">    conv(A, B, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="keyword">int</span>(<span class="number">1ll</span> * ifac[i] * A[n - i - <span class="number">1</span>] % P)); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《生成函数的运算与组合计数问题》金策，IOI中国国家候选队论文2015</li><li>《再探快速傅里叶变换》毛啸，IOI中国国家候选队论文2016</li><li><a href="https://rqy.moe/Math/gf_correct/">《浅谈 OI 中常用的一些生成函数运算的合法与正确性》</a>，rpy’s Blog</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://loj.ac/p/2271">「SDOI2017」遗忘的集合</a></li><li><a href="http://codeforces.com/problemset/problem/923/E">「CF923E」Perpetual Subtraction</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2019/03/29/OI%E6%A8%A1%E6%9D%BF%E6%A2%B3%E7%90%86/#3-%E5%A4%9A%E9%A1%B9%E5%BC%8F&quot;&gt;模板梳理&lt;/a&gt;中给出过一个多项式全家桶，在这里补充一下理论推导，也是对多项式基础知识的总结。限于篇幅，本篇中的解释可能会略有简短，不重要的说明已经省略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="多项式" scheme="https://big-news.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="生成函数" scheme="https://big-news.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="FFT" scheme="https://big-news.cn/tags/FFT/"/>
    
      <category term="NTT" scheme="https://big-news.cn/tags/NTT/"/>
    
      <category term="FWT" scheme="https://big-news.cn/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>置换群学习笔记</title>
    <link href="https://big-news.cn/2020/11/26/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/11/26/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-26T13:39:00.000Z</published>
    <updated>2023-04-15T13:01:45.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>置换群的相关内容主要用于解决一类“充满对称性”的计数问题。基于轨道-稳定子群定理的 Burnside 引理和引申出的 Pólya 计数原理是我们解决这类问题的有力工具……</p><a id="more"></a><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>对于一个非空集合 $S$ 和该集合上定义的二元运算 $·$，当该运算满足一些性质时，我们称它们构成一个群，记作 $(S,·)$。运算需要满足的性质是：</p><ul><li>封闭性：$\forall x,y\in S, x·y\in S$</li><li>结合性：$\forall x,y,z\in S,(x·y)·z=x·(y·z)=x·y·z$</li><li>存在单位元：$\exists e\in S, \text{s.t. }\forall y\in S, e·y=y$</li><li>存在逆元：$\forall y\in S,\exists x\in S,\text{s.t. } x·y=e$</li></ul><p>这是群论的基本定义，在 OI 界，更加常用的是置换群。</p><h3 id="置换和置换群"><a href="#置换和置换群" class="headerlink" title="置换和置换群"></a>置换和置换群</h3><ul><li>置换：一个从某个排列到某个排列的双射称作置换，记作 $p:f\to g$，其中 $f\to g$ 指代某种双射。</li><li>乘法：两个置换 $u,v$ 的乘法定义为它们对排列<strong>先后</strong>作用得到的结果，记作 $v·u$。</li><li>置换群：根据群论的基本概念，置换构成的集合和建立在置换上的乘法构成置换群。</li></ul><p>然后是一些有关于计数的概念。</p><ul><li>染色：给序列中的每个元素分配一个“颜色”从而得到的不同序列的过程称作染色。形式化地，可以用序列 $c$ 表示一个染色，其中 $c[i]$ 表示 $i$ 这个位置上的颜色。所有染色组成染色全集 $\mathcal{C}$。</li><li>置换对染色的作用：对于一个置换 $g$，其作用于某个染色 $c$ 可以得到一个新的染色，记作 $g·c$。</li><li>置换群对染色的作用（轨道）：对于一个置换群 $G$ 和一个染色 $c$，将所有 $g\in G$ 作用于 $c$ 得到的集合称作 $c$ 在 $G$ 下的轨道，记作 $G·c=\begin{Bmatrix}g·c\text{ | }g\in G \end{Bmatrix}$。</li></ul><p>Burnside 引理与 Pólya 计数原理用于解决在某种置换群 $G$ 作用下染色集合 $X\subseteq \mathcal{C}$ 共有多少本质不同的元素，即轨道数 $|X/G|$。</p><h3 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h3><p>设 $X\subseteq \mathcal{C}$ 是某个染色集合， $G$ 是作用在 $X$ 上的置换群，我们记 $X/G$ 为在 $G$ 作用下 $X$ 的轨道集合，即 $X/G=\begin{Bmatrix} gc\text{ | } c\in X, g\in G\end{Bmatrix}$。</p><ul><li>不动点（稳定子）：置换 $g\in G$ 作用在 $X$ 上的不动点为 $X$ 中在 $g$ 作用下不发生变化的元素，组成的集合即 $\begin{Bmatrix}c\in X\text{ | }gc=c\end{Bmatrix}$，记作 $X^g$。</li></ul><p>Burnside 引理指出，轨道数 $|X/G|$ 等于 $G$ 中所有置换对应的不动点个数的平均值，即有：</p><p>$$ |X/G|= \dfrac{1}{|G|}\sum\limits_{g\in G}|X^g| $$</p><h3 id="Polya-计数原理"><a href="#Polya-计数原理" class="headerlink" title="Pólya 计数原理"></a>Pólya 计数原理</h3><ul><li><p>置换的循环表示：简单来讲，如果把置换的双射看成图上的有向边，那么置换显然是成环的。我们可以据此把一个置换拆分成若干置换（轮换）的乘积，这称作置换的循环表示。</p></li><li><p>循环数：某一个置换 $g$ 具有的轮换的个数称作循环数，记作 $\chi(g)$。</p></li></ul><p>Pólya 原理指出，如果对于所有染色序列 $c\in X$ ，如果 $c$ 的所有位置可分配的颜色集合 $S$ 相同，那么不动点个数恰等于色数的循环数次方，即 $|X^g|=|S|^{\chi(g)}$。</p><p>根据 Burnside 引理，可以进一步得到一个常见的计数公式：</p><p> $$|X/G|=\dfrac{1}{|G|}\sum\limits_{g\in G}|S|^{\chi(g)}$$</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n(n+1)/2$ 个格子形成一个 $n$ 层的三角形，我们要给每个格子涂上黑白两种颜色。三角形可以沿中线翻转或顺/逆时针旋转，问一共有多少种本质不同的涂色方式。<br>$n\le 20$</p></div></article><p>显然，旋转的置换一共有三种 $\sigma^0,\sigma^1,\sigma^2$，翻转的置换题目给出了一种。考虑到置换群需要满足自闭性，那么先翻转再旋转的置换也应当位于置换群中，这等价于沿着一条斜着的中线翻转。因此翻转的置换也共有三种。</p><p>然后需要求出某种置换的循环数。$\sigma^0$ 显然是 $n(n+1)/2$，$\sigma^1,\sigma^2$ 容易发现是 $\lceil n(n+1)/6 \rceil$，翻转的循环数显然是 $(n(n-1)/2-\lceil n/2\rceil)/2+\lceil n/2\rceil$，从而答案是 $\dfrac{1}{6}(2^{\binom{n+1}{2}}+2^{\lceil n(n+1)/6 \rceil+1}+3·2^{(\binom{n+1}{2}-\lceil n/2\rceil)/2+\lceil n/2\rceil})$。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定三个整数 $A,B,C$ 和由 $m$ 个置换形成的置换群 $G=\begin{Bmatrix}p_1, p_2, …, p_m\end{Bmatrix}$。需要给 $n=A+B+C$ 个格子涂三种颜色，满足三种颜色的格子各有 $A,B,C$ 个，问在 $G$ 作用下共有多少不同的涂色方案。<br>$A,B,C\le 20,m\le 60$</p></div></article><p>考虑如何求在某个置换作用下的不动点个数。把每个置换循环分解，一个轮换上的点显然只能涂同一种颜色。然后看上去就可以背包一下，DP 把方案数计出来，套一个 Burnside 引理就可以算了。</p><p>朴素的复杂度大概是 $O(mnA^3)$，可能还能进一步优化。</p><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\text{ ~ }m-1$ 之一。环可以旋转，旋转得到的环视为相同的环，问有多少种本质不同的染色方案。<br>$ n,m\le 10^9 $</p></div></article><p>考虑先写出置换群 $G$ 来。我们设 $\sigma$ 为一次顺时针旋转（转动一个单位），则有 $G=\begin{Bmatrix} \sigma ^{x} \text{ | }x\ge 0\end{Bmatrix}$。注意到旋转 $n$ 次等价于不旋转，则 $|G|=n$。</p><p>根据  Pólya 原理，在 $\sigma^{i}$ 下的不动元素数 $|X|^{\sigma ^i}=m^{\chi(\sigma^i)}$。把 $\chi(\sigma^i)$ 写成循环表示的形式，即 $\sigma^i=(1,i,2i,…)(2,i+1,2i+1,…)…$，容易发现循环数为 $(i,n)$，这里的小括号特指两个数的最大公因数（Greatest Common Divisor, GCD）。</p><p>从而答案是 $\dfrac{1}{n}\sum\limits_{i=1}^n m^{(i,n)}$。</p><p>注意到 $(i,n)|n$，化一下柿子变成：<br>$$\begin{aligned}&amp;\dfrac{1}{n}\sum\limits_{i=1}^n m^{(i,n)}\newline =&amp; \dfrac{1}{n}\sum\limits_{d|n}m^d \sum\limits_{i=1}^n[(i,n)=d]\newline =&amp;\dfrac{1}{n}\sum\limits_{d|n}m^d \sum\limits_{d|i,i\le n}[(i/d,n/d)=1]\newline =&amp;\dfrac{1}{n}\sum\limits_{d|n}m^d \varphi(n/d)\end{aligned}$$</p><p>直接做就是 $O(d(n)\sqrt{n})$。</p><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>现在有 $n$ 个点的环，需要给每个点染上 $m$ 种颜色 $0\text{ ~ }m-1$ 之一。有两类置换：</p><ul><li>将环旋转若干次</li><li>给环上每个点的编号 $+1$ 再模 $m$。</li></ul><p>问共有多少种本质不同的染色方案。<br>$n,m\le 10^{18}$</p></div></article><p>设 $G_1=\begin{Bmatrix}\sigma^0,\sigma^1,…,\sigma^{n-1} \end{Bmatrix}$ 是旋转操作 $\sigma$ 的置换群， $G_2=\begin{Bmatrix}\tau^0,\tau^1,…,\tau^{m-1} \end{Bmatrix}$ 是加法操作 $\tau$ 的置换群，则本题中作用在环上的置换群 $G=G_1\times G_2$，其中 $\times$ 表示笛卡尔积。</p><p>分析一下不动点的个数，得到的柿子是：<br>$$\begin{aligned}&amp;\dfrac{1}{nm}\sum\limits_{i=1}^n\sum\limits_{k=1}^m [k\text{ is legal}]m^{(n,i)} \newline =&amp;\dfrac{1}{nm}\sum\limits_{i=1}^nm^{(n,i)}\sum\limits_{k=1}^m [m|\dfrac{kn}{(n,i)}]\newline =&amp;\dfrac{1}{nm}\sum\limits_{i=1}^nm^{(n,i)}(m,n/(n,i))\end{aligned}$$</p><p>第一个柿子里的 $[k\text{ is legal}]$ 这个条件一看就很吓人。但是冷静分析一下，就可以注意到我们实际上是需要轮换上相邻数字之差在模 $m$ 意义下恰好为 $k$，那么只需要判断是否能填充一个合法的轮换，即是否存在 $m|lk$，其中 $l$ 是轮换长，满足 $l=n/(n,i)$。</p><p>化一下变成：<br>$$\begin{aligned} =&amp;\dfrac{1}{nm}\sum\limits_{d|n}m^d(m,n/d)\sum\limits_{i=1}^{n/d}[(i,n/d)=1]\newline =&amp; \dfrac{1}{nm}\sum\limits_{d|n}m^d(m,n/d)\varphi(n/d)\end{aligned}$$</p><p>直接做是 $O(d(n)\sqrt{n})$，加个 Pollard-Rho 强行降成 $O(d(n)n^{1/4})$。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>参考：</p><ul><li>《浅谈群论在信息学竞赛中的简单应用》虞皓翔，IOI中国国家候选队论文2020</li></ul><p>相关题目：</p><ol><li><a href="https://www.luogu.com.cn/problem/P2561">「AHOI2002」黑白瓷砖</a></li><li><a href="https://www.luogu.com.cn/problem/P1446">「HNOI2008」Cards</a></li><li><a href="https://www.luogu.com.cn/problem/P4980">「LG-P4980」Pólya 定理</a></li><li>暂无来源</li></ol><p><del>进阶指南</del>丧命指南：</p><ul><li><p><a href="https://xyix.gitee.io/archieve/?tags=group-counting&page=0">群论计数/Archieve</a>, xyix’s Blog</p></li><li><p><a href="https://xyix.gitee.io/archieve/?tags=lagrange-inversion&page=0">拉格朗日反演/Archieve</a>, xyix’s Blog</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;置换群的相关内容主要用于解决一类“充满对称性”的计数问题。基于轨道-稳定子群定理的 Burnside 引理和引申出的 Pólya 计数原理是我们解决这类问题的有力工具……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="群论" scheme="https://big-news.cn/tags/%E7%BE%A4%E8%AE%BA/"/>
    
      <category term="置换群" scheme="https://big-news.cn/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"/>
    
      <category term="Burnside引理" scheme="https://big-news.cn/tags/Burnside%E5%BC%95%E7%90%86/"/>
    
      <category term="Pólya原理" scheme="https://big-news.cn/tags/Polya%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>李超线段树</title>
    <link href="https://big-news.cn/2020/11/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://big-news.cn/2020/11/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2020-11-02T09:11:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，李超线段树是一类在二维平面上维护最值线段的线段树，某些情况下具有着和动态凸包相类似的功用……</p><a id="more"></a><p>看一个栗子：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>要求在平面直角坐标系中维护若干线段，支持加入一条线段和查询所有线段与直线 $x=k$ （$k$ 给出）交点纵坐标的最大值。<br>一条线段以两个端点 $(x_0,y_0),(x_1,y_1)$ 的形式给出。<br>$q,k,x_0,y_0,x_1,y_1\le 10^5$</p></div></article><p>考虑用线段树维护这些斜线。方便起见，我们将线段看成解析式的形式 $f_i(x)$。对于区间 $[l,r]$，它的中点是 $m$，我们定义 $f_i(x)$ 在这个区间上比 $f_j(x)$ 更具优势，当且仅当 $f_i(m)&gt;f_j(m)$。对于线段树上的每个节点，我们只保留它的最优势线段，这样就可操作了。</p><p>剩余的是两个问题：一条当前区间的劣势线段可能是子区间的优势线段；统计 $p$ 点处的答案时，不一定 $[p,p]$ 上存的线段是最优秀的线段。</p><p>对于第二个问题，我们只需要将线段树上从根到 $[p,p]$ 的祖孙链上的所有线段都统计一遍即可；对于第一个问题，可以考虑把劣势线段下放到它和保留线段（优势线段）有交的那个子区间里，然后递归操作即可。</p><p>根据主定理，这一部分的复杂度（更新某个区间）是 $O(\log n)$ 的，因此李超树插入的总复杂度为 $O(\log^2 n)$，查询的总复杂度为 $O(\log n)$，不过它的常数很小。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equ</span><span class="params">(DB a, DB b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt;= EPS;&#125;</span><br><span class="line"><span class="keyword">int</span> n, lastans;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEG</span> &#123;</span><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> l, r, id; DB yl, yr;  SEG() &#123;l = id = <span class="number">0</span>, r = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">DB <span class="title">slp</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (yr - yl) / (<span class="number">1.0</span> * (r - l));&#125;</span><br><span class="line">    <span class="function">DB <span class="title">mid</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (yl + yr) / <span class="number">2</span>;&#125;</span><br><span class="line">    <span class="function">DB <span class="title">val</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> l == r ? yl : yl + slp() * (x - l);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cl</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;yl = val(x), l = x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;yr = val(x), r = x;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function">SEG <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    SEG o; o.l = a, o.yl = b, o.r = c, o.yr = d, o.id = e;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">le</span><span class="params">(SEG a, SEG b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.mid() &lt; b.mid() || (equ(a.mid(), b.mid()) &amp;&amp; a.id &gt; b.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: SEG d[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt; l) x.cl(l); <span class="keyword">if</span>(x.r &gt; r) x.cr(r);</span><br><span class="line">        <span class="keyword">if</span>(le(d[k], x)) swap(d[k], x);</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.slp() &lt; d[k].slp()) upd(l, m, lc, x);</span><br><span class="line">        <span class="keyword">else</span> upd(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt; l) x.cl(l); <span class="keyword">if</span>(x.r &gt; r) x.cr(r);</span><br><span class="line">        <span class="keyword">if</span>(x.l == l &amp;&amp; x.r == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(upd(l, r, k, x));</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.l &lt;= m) md(l, m, lc, x);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; x.r) md(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125; </span><br><span class="line">    pair&lt;DB, int&gt; qu(int l, int r, int k, int p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> mp(d[k].mid(), d[k].id);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="built_in">pair</span>&lt;DB, <span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) ans = qu(l, m, lc, p);</span><br><span class="line">        <span class="keyword">else</span> ans = qu(m + <span class="number">1</span>, r, rc, p);</span><br><span class="line">        <span class="keyword">if</span>(d[k].val(p) &gt; ans.first || (equ(d[k].val(p), ans.first) &amp;&amp; d[k].id &lt; ans.second))</span><br><span class="line">            ans.first = d[k].val(p), ans.second = d[k].id;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">return</span> (x + lastans - <span class="number">1</span>) % p + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    n = read(); <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = read(), a = read(), b, c, d;</span><br><span class="line">        <span class="keyword">if</span>(tp)&#123;</span><br><span class="line">            b = read(), c = read(), d = read();</span><br><span class="line">            a = enc(a, <span class="number">39989</span>), b = enc(b, <span class="number">1e9</span>), c = enc(c, <span class="number">39989</span>), d = enc(d, <span class="number">1e9</span>);</span><br><span class="line">            <span class="keyword">if</span>(a &gt; c) swap(a, c), swap(b, d);</span><br><span class="line">            D.md(<span class="number">1</span>, <span class="number">1e5</span>, <span class="number">1</span>, mk(a, b, c, d, ++cnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> a = enc(a, <span class="number">39989</span>),</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lastans = D.qu(<span class="number">1</span>, <span class="number">1e5</span>, <span class="number">1</span>, a).second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在斜率优化中的应用"><a href="#在斜率优化中的应用" class="headerlink" title="在斜率优化中的应用"></a>在斜率优化中的应用</h3><p>看这样一个斜率优化的经典模型：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 个点依次排列，第 $i$ 个点有正数权值 $h_i$。你可以划一条线段连接两个点 $i,j$，费用是 $(h_i-h_j)^2$；要求你画的所有线段只能在端点处相交，且对于每个未被连接的点 $i$，需要支付 $w_i$ 的费用。<br>现在需要把 $1$ 号点和 $n$ 号点连接，求连接的最小费用。<br>$n\le 2\times 10^5, 0\le |w_i|, h_i\le 10^6$</p></div></article><p>设 $f[i]$ 为连接到 $i$ 的最小费用，设 $s_i$ 是 $w_i$ 的前缀和，有 $f[i] = \min\limits_{j=1}^{i-1}f[j]+(h_i-h_j)^2+s_{i-1}-s_j$。</p><p>我们可以考虑将其化为斜率优化的一般形式，设 $y_j=f[j]+h^2_j-s_j,b_j=-2h_ih_j+y_j$，则可以看成有一堆点 $(h_j,y_j)$，每次给出一个斜率 $-2h_i$，求纵轴截距 $b_j$ 的最小值。由于 $h_j$ 和 $-2h_i$ 均不单调，朴素斜率优化思路需要用 Splay 维护下凸包二分，或者 CDQ 分治，但是我都不会。</p><p>换一个思路：设 $f_i(x)=k_ix+y_i$，其中 $k_i=-2h_i,y_i=f[i]+h^2_i-s_i$，则我们在求 $h^2_i+s_{i-1}+\min\limits_{j=1}^{i-1} f_j(h_i)$。后面那个式子直接用李超树维护即可，由于这里的线段是直线，因此复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CV = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; LL h[CN], s[CN];</span><br><span class="line"><span class="function">LL <span class="title">squ</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEG</span> &#123;</span><span class="keyword">public</span>: LL k, b; SEG() &#123;b = <span class="number">1e18</span>;&#125; <span class="function">LL <span class="title">val</span><span class="params">(LL p)</span> </span>&#123;<span class="keyword">return</span> k * p + b;&#125;&#125; ;</span><br><span class="line"><span class="function">SEG <span class="title">mk</span><span class="params">(LL a, LL b)</span> </span>&#123;SEG o; o.k = a, o.b = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: SEG d[CV &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, SEG x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.val(m) &lt; d[k].val(m)) swap(d[k], x);</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(x.k &gt; d[k].k) upd(l, m, lc, x); <span class="keyword">else</span> upd(m + <span class="number">1</span>, r, rc, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> d[k].val(p);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; LL ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) ans = qu(l, m, lc, p); <span class="keyword">else</span> ans = qu(m + <span class="number">1</span>, r, rc, p);</span><br><span class="line">        <span class="keyword">return</span> min(ans, d[k].val(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) h[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + read();</span><br><span class="line">    LL yi = squ(h[<span class="number">1</span>]) - s[<span class="number">1</span>], ki = <span class="number">-2</span> * h[<span class="number">1</span>], fi;</span><br><span class="line">    D.upd(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, mk(ki, yi));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        fi = squ(h[i]) + s[i - <span class="number">1</span>] + D.qu(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, h[i]), </span><br><span class="line">        yi = squ(h[i]) - s[i] + fi, ki = <span class="number">-2</span> * h[i],</span><br><span class="line">        D.upd(<span class="number">1</span>, <span class="number">1e6</span>, <span class="number">1</span>, mk(ki, yi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, fi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P4097">「HEOI2013」Segment</a></li><li><a href="https://loj.ac/problem/2483">「CEOI2017」Building Bridges</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，李超线段树是一类在二维平面上维护最值线段的线段树，某些情况下具有着和动态凸包相类似的功用……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="线段树" scheme="https://big-news.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="李超树" scheme="https://big-news.cn/tags/%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>整数划分问题</title>
    <link href="https://big-news.cn/2020/10/19/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
    <id>https://big-news.cn/2020/10/19/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-19T07:42:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，整数划分问题是一类计算将正整数 $n$ 无序拆分成若干可相同的正整数之和的划分数的问题，存在一类普适性的 DP 解法以及针对划分数问题的五边形数定理……</p><a id="more"></a><p>先来看一道小学奥数题。</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出 $n$ 个小球和  $m$ 个盒子，分别计算在以下情况中，将小球放入盒子（盒子不能是空）的方案数：</p><ol><li>小球和盒子都有标号</li><li>小球有标号，盒子无标号</li><li>小球无标号，盒子有标号</li><li>小球和盒子都没有标号</div></article></li></ol><p>显然，问题 1 可以通过简单容斥来求，即我们钦点有 $k$ 个盒子是空的，得到答案是 $\sum\limits_{k=0}^m (-1)^k \dbinom{m}{k} (m-k)^n$。注意到这本质上是第二类斯特林数乘上盒子数的阶乘（见<a href="/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/#2-5-%E7%AC%AC%E4%BA%8C%E7%B1%BB-Stirling-%E6%95%B0%E9%80%9A%E9%A1%B9">通项公式</a>），即 $m!\begin{Bmatrix}n\newline m \end{Bmatrix}$。</p><p>对于问题 2 ，这显然是第二类斯特林数 $\begin{Bmatrix}n\newline m \end{Bmatrix}$ 的定义（组合意义？）。</p><p>对于问题 3，因为小球不可区分，所以我们考虑插板。因为盒子不空，所以答案是 $\dbinom{n-1}{m-1}$。</p><p>至此前三个问题都在 $O(nm)$ 的时间内解决掉了，但是第四个问题呢？显然我们不能直接对 3 除一个 $m!$ 了事，一个最明显的反例就是得到的结果甚至不一定是整数！</p><p>我们考虑 DP。</p><h3 id="整数划分-DP"><a href="#整数划分-DP" class="headerlink" title="整数划分 DP"></a>整数划分 DP</h3><p>问题 4 可以被如下转化：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定正整数 $n$ ，求将 $n$ 分解为 $m$ 个正整数之和的方案数。两种方案不同当且仅当 $m$ 个正整数构成的集合不相同。<br>$n, m\le 5000$</p></div></article><p>设 $f[i,k]$ 为考虑将 $i$ 划成 $k$ 个正整数的方案数。对于当前的状态，我们可以将其划成两种情况：</p><ol><li>当前划分包含数字 1，方案是 $f[i-1,k-1]$</li><li>当前划分不含数字 1，考虑对划分出的每个数字减 1，方案数不变，得到方案数是 $f[i-k,k]$</li></ol><p>因此转移：<br>$$ f[i,k]=f[i-1,k-1]+f[i - k, k] $$ 时间复杂度 $O(nm)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt;= n; i++)</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j];</span><br></pre></td></tr></table></figure><h3 id="一个变形"><a href="#一个变形" class="headerlink" title="一个变形"></a>一个变形</h3><p>考虑这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定正整数 $n$ ，求将 $n$ 分解为若干个正整数之和的方案数。两种方案不同当且仅当划分出的正整数构成的集合不相同。<br>$Subtask1, n \le 5000$<br>$Subtask2,n\le 10^5$</p></div></article><ul><li>Subtask1</li></ul><p>考虑 DP，注意到这本质上就是一个完全背包计数：有 $n$ 个物品 $1,2,…,n$，选出一些让和为 $n$，物品可以取多次。然后就可以 $O(n^2)$ 快乐DP了，代码略。</p><ul><li>Subtask2</li></ul><p>注意到我们有两种求划分数的 DP：第一类状态设计为 $f[i,k]$ 考虑将 $i$ 划成 $k$ 个正整数的方案数，复杂度是 $O(nk)$，即划分个数乘上划分值域；第二类是完全背包计数，复杂度是 $O(nV)$，即元素个数乘上划分值域。</p><p>考虑复杂度均摊，设阈值 $B$，我们把能用的数字划分为 $[1,B]$ 和 $[B+1,n]$ 两部分。第一部分一共有 $B$ 个能用的数字，跑完全背包计数，复杂度 $O(nB)$；第二部分不会选择超过 $\frac{n}{B}$ 个，跑第一种 DP，复杂度 $O(\frac{n^2}{B})$。最后可以模拟卷积合并 DP 结果，取 $B = \lceil\sqrt{n}\rceil$，总复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, n, P, f[CN], g[CN][<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)); </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= B; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        f[j] = add(f[j], f[j - i]);</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(B, i); j++)</span><br><span class="line">        g[i][j] = add(g[i - <span class="number">1</span>][j - <span class="number">1</span>], g[i - j][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(B, i); j++)</span><br><span class="line">        <span class="keyword">if</span>(i + j * B &lt;= n) <span class="comment">// 每个数都 +B </span></span><br><span class="line">            g[i + j * B][<span class="number">0</span>] = add(g[i + j * B][<span class="number">0</span>], g[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="comment">// 合并状态 </span></span><br><span class="line">        ans = add(ans, <span class="number">1ll</span> * f[i] * g[n - i][<span class="number">0</span>] % P);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个问题是一类经典问题，被称作整数拆分问题，另一种解法是五边形数定理。</p><h3 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h3><ul><li>五边形数<br>形如 $p_n = p_{n-1}+3n-2$ 的数字被称作是五边形数，通项是 $p_n=\dfrac{n(3n-1)}{2}$。</li></ul><p>五边形数定理指出：<br>$$ \phi(x) = \prod\limits_{k\ge 1}(1-x^k)=\sum\limits_{k=-\infty}^{+\infty}(-1)^kx^{p_k} $$ 其中 $p_k$ 是五边形数。<br>设 $f_n$ 为 $n$ 的拆分数，$F(x)$ 是 $f_n$ 的 OGF，有：<br>$$ F(x)=1/\phi(x) $$ 即：<br>$$ (1-x-x^2+x^5+x^7-…)(1+f_1x+f_2x^2+f_3x^3+…)=1 $$ 比较系数得：<br>$$\begin{aligned} &amp;f_n-f_{n-1}-f_{n-2}+f_{n-5}+f_{n-7}-…=0 \newline \Leftrightarrow &amp;f_n=f_{n-1}+f_{n-2}-f_{n-5}-f_{n-7}\end{aligned}$$ 其中数列 $1,2,5,7,12,15,…$ 对应广义五边形数 $p_1,p_{-1},p_2,p_{-2},…$。</p><p>然后我们就可以愉快的递推 $f[]$ 了，可以证明这样做的复杂度为 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x * (<span class="number">3</span> * x - <span class="number">1</span>) / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; ;j++)&#123; </span><br><span class="line">        <span class="keyword">int</span> k = p(j); <span class="keyword">if</span>(k &gt; i) <span class="keyword">break</span>;</span><br><span class="line">        f[i] = add(f[i], j &amp; <span class="number">1</span> ? f[i - k] : P - f[i - k]);</span><br><span class="line">        k = p(-j); <span class="keyword">if</span>(k &gt; i) <span class="keyword">break</span>;</span><br><span class="line">        f[i] = add(f[i], j &amp; <span class="number">1</span> ? f[i - k] : P - f[i - k]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，整数划分问题是一类计算将正整数 $n$ 无序拆分成若干可相同的正整数之和的划分数的问题，存在一类普适性的 DP 解法以及针对划分数问题的五边形数定理……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="五边形数" scheme="https://big-news.cn/tags/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」洛谷十月月赛 II</title>
    <link href="https://big-news.cn/2020/10/18/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B%20II/"/>
    <id>https://big-news.cn/2020/10/18/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B%20II/</id>
    <published>2020-10-18T10:38:00.000Z</published>
    <updated>2021-02-21T12:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>又是垫底的一天啊，凉心出题人再次让我感受到了没技术的弱小，不过还是水个题解吧……</p><a id="more"></a><h3 id="A-梦中梦与不再有梦"><a href="#A-梦中梦与不再有梦" class="headerlink" title="A 梦中梦与不再有梦"></a>A 梦中梦与不再有梦</h3><p>签到结论题。首先 $n=1$ 时答案为 0，$n=2$ 时答案为 1，然后考虑 $n\ge 3$：</p><ol><li>当 $n$ 是奇数时，由于图上不存在奇点，那么必然有欧拉回路，答案为 $\dbinom{n}{2}$</li><li>当 $n$ 是偶数时，因 $n\ge 3$，则图上存在多于两个奇点。我们只能保留其中两个，那么删掉 $n/2-1$ 个奇点，答案是 $\dbinom{n}{2}-n/2+1$</li></ol><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n * (n - <span class="number">1</span>) / <span class="number">2</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (n * (n - <span class="number">1</span>) / <span class="number">2</span>) - (n / <span class="number">2</span>) + <span class="number">1</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;T = read(); <span class="keyword">while</span>(T--)&#123;n = read(), work();&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="B-深海少女与胖头鱼"><a href="#B-深海少女与胖头鱼" class="headerlink" title="B 深海少女与胖头鱼"></a>B 深海少女与胖头鱼</h3><p>设 $f(n,m)$ 为当前场面剩余 $n$ 个带盾的和 $m$ 个不带盾的时，剩余操作次数的期望。显然有：<br>$$ \begin{align} f(n,0) &amp;=2+\dfrac{1}{n}f(n-1,0)+\dfrac{n-1}{n}f(n-1,1)\tag 1 \newline f(n,1)&amp;=1+\dfrac{n}{n+1}f(n,1)+\dfrac{1}{n+1}f(n,0)\tag 2 \newline f(n,m)&amp;=1+\dfrac{m}{n+m}f(n,m-1)+\dfrac{n}{n+m}f(n+m-1,1)\tag 3 | m&gt;1 \end{align} $$ 我们令 $(2)$ 代 $(1)$ 得：<br>$$ \begin{aligned} f(n,0)&amp;=n+1+f(n-1,0) \newline f(n,1)&amp;=n+1+f(n,0)  \end{aligned} $$ 归纳可得：<br>$$ f(n,0)=\dfrac{n(n+3)}{2},f(n,1)=n+1+\dfrac{n(n+3)}{2} $$ 于是 $m\le 1$ 的情况做完了，对于 $m&gt;1$ 的情况，根据 $(3)$ 式，容易发现此时分成了 $f(·,m-1)$ 和 $f(·,1)$ 两部分，然后就可以愉快的 $O(m)$ 递推了。</p><p>代码，常数不小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">499122177</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P; a = <span class="number">1ll</span> * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &gt;= P ? a + b - P : a + b;&#125;</span><br><span class="line"><span class="keyword">int</span> n, nn, nN, m, f[CN];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read() % P, m = read(), nn = <span class="number">1ll</span> * n * i2 % P, nN = add(n, <span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span> * nn * (n + <span class="number">3</span>) % P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> M = add(n, i), t;</span><br><span class="line">        t = add(add(M, <span class="number">1</span>), P - (<span class="number">2ll</span> * qp(M, P - <span class="number">2</span>) % P));</span><br><span class="line">        t = <span class="number">1ll</span> * t * nn % P;</span><br><span class="line">        f[i] = add(t, nN);</span><br><span class="line">        t = <span class="number">1ll</span> * i * qp(add(n, i), P - <span class="number">2</span>) % P;</span><br><span class="line">        t = <span class="number">1ll</span> * t * f[i - <span class="number">1</span>] % P;</span><br><span class="line">        f[i] = add(f[i], t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-蝴蝶与花"><a href="#C-蝴蝶与花" class="headerlink" title="C 蝴蝶与花"></a>C 蝴蝶与花</h3><p>不会/kk</p><h3 id="D-象棋与马"><a href="#D-象棋与马" class="headerlink" title="D 象棋与马"></a>D 象棋与马</h3><p>首先考虑 $p(a,b)$ 什么时候能等于 1。</p><p>显然有一个必要条件是 $(a,b)=1$，但是样例就已经说明了这不是充分的；这时候打个表就会发现第二个条件是 $|a-b| \text{ mod } 2 = 1$。</p><p>于是就变成了求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^n [(i,j)=1][|i-j|\text{ mod }2=1]$，显然原式等于 $2\sum\limits_{i=1}^n\sum\limits_{j=1}^i [(i,j)=1][|i-j|\text{ mod }2=1]$，我们考虑求后面这个和式。</p><p>考虑对于偶数 $i$，因为偶数不可能和偶数互质，那么其贡献应当是 $\varphi(i)$。对于奇数 $i$，因为与其互质的数有一半是奇数，一半是偶数，所以其贡献应当是 $\dfrac{\varphi(i)}{2}$。所以我们在求：<br>$$ \sum\limits_{i=1}^n [i\text{ mod }2=0]\varphi(i)+\sum\limits_{i=1}^n [i\text{ mod }2=1]\dfrac{\varphi(i)}{2} $$</p><p>考虑有等式：</p><p>$$\sum\limits_{i=1}^n \varphi(i)[i\bmod 2=0]=\sum\limits_{i=1}^{\lfloor n/2\rfloor}\varphi(i)[i\bmod 2=1] + 2\sum\limits_{i=1}^{\lfloor n/2\rfloor}\varphi(i)[i\bmod 2=0]$$</p><p>即是考虑新增一个因子 $2$ 的贡献，那么直接杜教筛即可 $O(n^{2/3})$。</p><p>大常数辣鸡代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ULL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ULL s = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">for</span>(;c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>;c = getchar());</span><br><span class="line">    <span class="keyword">for</span>(;c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;c = getchar()) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, pr[CN], mu[CN]; ULL p, p0, p1, phi[CN], phi0[CN], phi1[CN]; <span class="keyword">bool</span> np[CN];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PAIR</span> &#123;</span><span class="keyword">public</span>: ULL p, p0, p1;&#125;;</span><br><span class="line"><span class="function">PAIR <span class="title">mp</span><span class="params">(ULL a, ULL b, ULL c)</span> </span>&#123;PAIR o; o.p = a, o.p0 = b, o.p1 = c; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAP</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">191011109</span>, CN = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: ULL key; <span class="keyword">int</span> nxt; PAIR val;&#125; E[CN]; <span class="keyword">int</span> ecnt, hd[CN];</span><br><span class="line">    PAIR&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> ULL &amp;o)&#123;</span><br><span class="line">        ULL A = o &gt;&gt; <span class="number">25</span>, B = o &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>), u = (A ^ B ^ P) % CN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) <span class="keyword">if</span>(E[k].key == o) <span class="keyword">return</span> E[k].val;</span><br><span class="line">        E[++ecnt].key = o, E[ecnt].nxt = hd[u], hd[u] = ecnt; <span class="keyword">return</span> E[ecnt].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> ULL &amp;o)</span></span>&#123;</span><br><span class="line">        ULL A = o &gt;&gt; <span class="number">25</span>, B = o &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>), u = (A ^ B ^ P) % CN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) <span class="keyword">if</span>(E[k].key == o) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; vis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ULL n, ULL &amp;p, ULL &amp;p0, ULL &amp;p1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="keyword">int</span>(<span class="number">1e7</span>)) <span class="keyword">return</span> (<span class="keyword">void</span>)(p = phi[n], p0 = phi0[n], p1 = phi1[n]);</span><br><span class="line">    <span class="keyword">if</span>(vis.count(n)) <span class="keyword">return</span> (<span class="keyword">void</span>)(p = vis[n].p, p0 = vis[n].p0, p1 = vis[n].p1);</span><br><span class="line">    p = n &amp; <span class="number">1</span> ? ((n + <span class="number">1</span>) / <span class="number">2</span>) * n : (n / <span class="number">2</span>) * (n + <span class="number">1</span>), p0 = p1 = <span class="number">0</span>; ULL P, P0, P1;</span><br><span class="line">    <span class="keyword">for</span>(ULL l = <span class="number">2</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        ULL r = n / (n / l); solve(n / l, P, P0, P1);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">2</span>) p0 = (P0 &lt;&lt; <span class="number">1</span>) + P1; p -= (r - l + <span class="number">1</span>) * P, l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = p - p0, vis[n] = mp(p, p0, p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1e7</span>; np[<span class="number">1</span>] = phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) pr[++pr[<span class="number">0</span>]] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pr[<span class="number">0</span>] &amp;&amp; i * pr[j] &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * pr[j]; np[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % pr[j]) mu[x] = -mu[i], phi[x] = phi[i] * (pr[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;phi[x] = phi[i] * pr[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) i &amp; <span class="number">1</span> ? phi1[i] = phi[i] : phi0[i] = phi[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>], phi1[i] += phi1[i - <span class="number">1</span>], phi0[i] += phi0[i - <span class="number">1</span>];</span><br><span class="line">    T = read(); <span class="keyword">while</span>(T--) solve(read(), p, p0, p1), <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, (p0 &lt;&lt; <span class="number">1</span>) + p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是垫底的一天啊，凉心出题人再次让我感受到了没技术的弱小，不过还是水个题解吧……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
  </entry>
  
  <entry>
    <title>考前的小知识积累</title>
    <link href="https://big-news.cn/2020/10/16/%E8%80%83%E5%89%8D%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>https://big-news.cn/2020/10/16/%E8%80%83%E5%89%8D%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/</id>
    <published>2020-10-16T12:05:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>快考试了，整理一下最近学到的细碎的东西。东西很杂，也有一些叫不上名字来，简单写写吧……</p><a id="more"></a><h3 id="max-矩阵乘法"><a href="#max-矩阵乘法" class="headerlink" title="max+ 矩阵乘法"></a>max+ 矩阵乘法</h3><p>定义一类新矩阵乘法：<br>$$ C= A * B\Leftrightarrow C_{i,j}=\max\limits_{i,j,k}A_{i,k}+B_{k,j} $$ 为矩阵的 max+ 乘法。注意到这类乘法是满足结合律的，因此可以快速幂优化。这类乘法的本质类似于一轮 Floyd 传递闭包。</p><p>相关题目：<a href="https://www.luogu.com.cn/problem/P3502">Hamsters</a></p><h3 id="max-卷积"><a href="#max-卷积" class="headerlink" title="max+ 卷积"></a>max+ 卷积</h3><p>定义一类新的序列卷积：<br>$$ C=A*B\Leftrightarrow C_k=\max\limits_{i+j=k}A_i+B_j $$ 这类卷积很难做到低于 $O(n^2)$ 的复杂度内计算，但是如果 $A,B$ 都是离散意义下的凸函数的话，可以做到 $O(n\log n)$ 计算，方法如下：</p><p>把序列 $A,B$ 分别排序后差分，把得到的增量合并到一个序列中降序排序，这会得到一个长度为 $2n-2$ 的新序列，记为 $\text{d}$。注意到必然有 $C_0=A_0+B_0$，我们下一步需要按从大到小的顺序把增量加进去，即有 $C_1=C_0+\text{d}_0, C_i=C_{i-1}+\text{d}_{i - 1}$，于是就还原出了卷积后的结果 $C$，时间复杂度只有排序的 $O(n\log n)$。</p><p>这种做法的正确性在于：对于凸函数而言，增量 $\text{d}$ 的可取范围与其大小是相应变化的。那么如果做凹函数的 min+ 卷积的时候，也可以适用类似的做法。</p><h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>有一种普适性的在亚线性时间复杂度内，解决一类距离最值问题的方法，通俗的叫法好像叫做斜率优化。</p><p>这类问题的一般模型是：定义一类新的距离 $\text{dist}(i,j)=A_i+B_j+C_iD_j$，求 $\min\limits_{i,j}\text{dist}(i,j)$。注意到关于 $i, j$ 的下标运算是二次的，因此无法拆开来简单维护。</p><p>考虑枚举 $i$，转化为求如下式的值：$p + \min\limits_{1\le j\le n} B_j+kD_j$，设有 $l_j=B_j+kD_j$，得到 $B_j=-kD_j+l_j$，这是一条过定点 $(D_j, B_j)$，斜率为 $-k$ 的直线，而我们要最小化的东西是这条直线的截距 $l_j$。</p><p>那么现在等价于给出一堆点 $(D_1,B_1),(D_2,B_2),…,(D_n,B_n)$ 和一个斜率 $-k$，让我们求一条直线使得截距最小。显然，所求点必然在这些点形成的下凸壳上，那么维护出下凸壳二分即可。<br>有时斜率给出的性质特殊，则可以单调维护；当点的选取范围有要求时，可以结合单调栈 / 线段树。</p><p>给出一个示例：求 $\min\limits_{i,j}a_i+b_j+(i-j)^2$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stk[++top] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        u = stk[top], v = stk[top - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * (b[u] - b[v]) * (i - u) &lt; <span class="number">1ll</span> * (b[i] - b[u]) * (u - v)) <span class="keyword">break</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> u = stk[p], v = stk[p + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(p &lt; top &amp;&amp; b[v] - <span class="number">2</span> * i * v &lt; b[u] - <span class="number">2</span> * i * u) </span><br><span class="line">        p++, u = v, v = stk[p + <span class="number">1</span>];</span><br><span class="line">    u = stk[p], ans = min(ans, a[i] + b[u] - <span class="number">2</span> * i * u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：<a href="http://oj.big-news.cn/problem/22">Thief</a></p><h3 id="常幂展开在贡献法中的应用"><a href="#常幂展开在贡献法中的应用" class="headerlink" title="常幂展开在贡献法中的应用"></a>常幂展开在贡献法中的应用</h3><p>看一道好题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出简单无向图 $G=(V,E)$，设 $S=(V_S,E_S)$ 为 $G$ 的某个导出子图，求 $\sum\limits_{S\subseteq G}|E_S|^k$。<br>$|V|,|E|\le 10^5, 1\le k\le 3$</p></div></article><p>显然，当 $k=1$ 时，我们可以运用<strong>贡献法</strong>考虑每条边对答案的贡献，因此得到答案即是 $|E|2^{|V|-2}$。</p><p>但是当 $k\ge 2$ 时，因为乘幂运算的缘故，直接使用贡献法是不可以的。根据<a href="/2020/08/07/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%86%8D%E5%9F%BA%E7%A1%80/#1-2-%E5%B8%B8%E5%B9%82%E5%B1%95%E5%BC%80">常幂展开</a>公式，我们可以这样给柿子变形：<br>$$ \begin{aligned}\sum\limits_{S\subseteq G}|E_S|^k= \sum\limits_{i=0}^k \begin{Bmatrix}k\newline i\end{Bmatrix}i!\sum\limits_{S\subseteq G}\dbinom{|E_S|}{i}   \end{aligned} $$ 注意到这是求和，因此贡献法又适用了，那我们可以考虑求后面的 $\sum\limits_{S\subseteq G}\dbinom{|E_S|}{i}$。<br>考虑这个柿子的意义，我们可以等价于在原图中任意钦点 $i$ 条边出来，统计所有情况下包含 $i$ 条边的导出子图的数量。即我们考虑钦点一个组合数选出来的东西，然后考虑它的贡献，即它被选到的次数。</p><p>我们分类讨论。设边数为 $m$，点数为 $n$，对于 $k=2(i=(0),1,2)$ 的情况，可以这样分类：</p><ol><li>$i=1$，即选一条边，显然是 $m2^{n-2}$；</li><li>$i=2$，即选两条边。注意到两条边可以共用一个端点，或者有四个独立的端点。我们只需要对这两种情况分别统计“方案数x被导出子图包含的次数”即可。</li></ol><p>$k=3$ 的情况也可以类似的进行分类，于是就可以完成了。复杂度的瓶颈在于 $k=3$ 时的三元环计数，因此复杂度 $O(m^{1.5})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = <span class="number">5e8</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i3 = <span class="number">333333336</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * (<span class="number">1ll</span> * x * (x - <span class="number">1</span>) % P) * i2 % P;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, pw[CN], du[CN]; </span><br><span class="line"><span class="keyword">namespace</span> sub1 &#123;<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="number">1ll</span> * m * pw[n - <span class="number">2</span>] % P);&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> sub2 &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1ll</span> * m * pw[n - <span class="number">2</span>] % P, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>; <span class="comment">// i = 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); du[x]++, du[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1 = add(s1, C(du[i]));</span><br><span class="line">    s2 = add(C(m), P - s1);</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1ll</span> * s1 * pw[n - <span class="number">3</span>] % P; <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1ll</span> * s2 * pw[n - <span class="number">4</span>] % P; <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    s1 = add(s1, s2);</span><br><span class="line">    ans = add(ans, add(s1, s1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">namespace</span> sub3 &#123;</span><br><span class="line"><span class="keyword">int</span> X[CN], Y[CN], col[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">le</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> du[i] ^ du[j] ? du[i] &lt; du[j] : i &lt; j;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt1 = <span class="number">1ll</span> * m * pw[n - <span class="number">2</span>] % P, cnt2 = <span class="number">0</span>, cnt3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); </span><br><span class="line">        du[x]++, du[y]++, X[i] = x, Y[i] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">/* cnt2 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1 = add(s1, C(du[i]));</span><br><span class="line">    s2 = add(C(m), P - s1);</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1ll</span> * s1 * pw[n - <span class="number">3</span>] % P;</span><br><span class="line">    <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1ll</span> * s2 * pw[n - <span class="number">4</span>] % P;</span><br><span class="line">    <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    cnt2 = add(s1, s2);</span><br><span class="line">    <span class="comment">/* cnt3 */</span></span><br><span class="line">    s1 = s2 = s3 = s4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = X[i], v = Y[i];</span><br><span class="line">        <span class="keyword">if</span>(le(u, v)) G[v].pb(u); <span class="comment">// v &gt; u : v -&gt; u</span></span><br><span class="line">        <span class="keyword">else</span> G[u].pb(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = G[i].size(), j = <span class="number">0</span>; j &lt; l; j++) col[G[i][j]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = G[i].size(), t = <span class="number">0</span>; t &lt; l; t++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = G[i][t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ll = G[j].size(), tt = <span class="number">0</span>; tt &lt; ll; tt++)</span><br><span class="line">                <span class="keyword">if</span>(col[G[j][tt]] == i) s1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) s2 = add(s2, <span class="number">1ll</span> * (du[X[i]] - <span class="number">1</span>) * (du[Y[i]] - <span class="number">1</span>) % P);</span><br><span class="line">    s2 = add(s2, P - (<span class="number">3ll</span> * s1 % P));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s3 = add(s3, <span class="number">1ll</span> * C(du[i]) * (m - du[i]) % P);</span><br><span class="line">    s3 = add(s3, P - add(<span class="number">3ll</span> * s1 % P, <span class="number">2ll</span> * s2 % P));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1ll</span> * C(du[i]) * (du[i] - <span class="number">2</span>) % P; cur = <span class="number">1ll</span> * cur * i3 % P;</span><br><span class="line">        s2 = add(s2, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    s4 = <span class="number">1ll</span> * C(m) * (m - <span class="number">2</span>) % P, s4 = <span class="number">1ll</span> * s4 * i3 % P;</span><br><span class="line">    s4 = add(s4, P - add(add(s1, s2), s3));</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">3</span>) s1 = <span class="number">1ll</span> * s1 * pw[n - <span class="number">3</span>] % P; <span class="keyword">else</span> s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">4</span>) s2 = <span class="number">1ll</span> * s2 * pw[n - <span class="number">4</span>] % P; <span class="keyword">else</span> s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">5</span>) s3 = <span class="number">1ll</span> * s3 * pw[n - <span class="number">5</span>] % P; <span class="keyword">else</span> s3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">6</span>) s4 = <span class="number">1ll</span> * s4 * pw[n - <span class="number">6</span>] % P; <span class="keyword">else</span> s4 = <span class="number">0</span>;</span><br><span class="line">    cnt3 = add(add(s1, s2), add(s3, s4));</span><br><span class="line">    <span class="comment">/* answer */</span></span><br><span class="line">    cnt2 = <span class="number">6ll</span> * cnt2 % P, cnt3 = <span class="number">6ll</span> * cnt3 % P;</span><br><span class="line">    ans = add(cnt1, add(cnt2, cnt3)), <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pw[i] = add(pw[i - <span class="number">1</span>], pw[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) sub1 :: work();</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">2</span>) sub2 :: work();</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">3</span>) sub3 :: work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lorem-Ipsum"><a href="#Lorem-Ipsum" class="headerlink" title="Lorem Ipsum"></a>Lorem Ipsum</h3><p>一个新的技巧：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>众所周知，将 $m$ 划分为 $n$ 个非负整数有 $\dbinom{m+n-1}{n-1}$ 种方案。对于任意方案 $P$，我们定义 $val_k(P)$ 表示该划分中第 $k$ 大的数（降序排序后的第 $k$ 个）。设 $S$ 为总方案集，现在给定 $m,n,k$，请求出 $\sum\limits_{P\in S}val_k(P)$。<br>$n,m\le 5000$</p></div></article><p>设 $f[k,l]$ 表示一个划分中至少有 $k$ 个数字 $\ge l$ 的划分的数量。首先有等式：<br>$$ \sum\limits_{P\in S} val_k(P) =\sum\limits_{l=1}^mf[k,l] $$ 这个可以这样理解：我们考虑对于任意一个方案中第 $k$ 大的数，设它是 $p$，那么对于 $\forall l\le p$ 的 $f[k,l]$，$p$ 都会在 $f[k,l]$ 中被累加一次，一共累加 $p$ 次，因此这样是正确的。</p><p>那么现在的问题是求出“至少有 $k$ 个数字 $\ge l$ 的划分数”，这是一个“至少”限制，因此不可以直接选出来。可以这样理解：直接拿组合数选出来的是“钦定某 $k$ 个数字 $\ge l$ 的划分数”，而我们要求的是“有任意至少 $k$ 个数字 $\ge l$ 的划分数”。</p><p>形式化的说，设 $g[k,l]$ 为“恰好 $k$ 个数字 $\ge l$ 的划分数”，$h[k,l]$ 为“钦定 $k$ 个数字 $\ge l$ 的划分数”，$f[k,l]$ 为“至少有 $k$ 个数字 $\ge l$ 的划分数”，那么有：<br>$$ \begin{align} h[k,l]&amp;=\dbinom{n}{k}\dbinom{m-kl+n-1}{n-1}\newline &amp;=\sum\limits_{j=k}^n\dbinom{j}{k}g[j,l] \newline \Leftrightarrow g[k,l]&amp;=\sum\limits_{j=k}^n(-1)^{j-k}\dbinom{j}{k}\dbinom{n}{k}\dbinom{m-kl+n-1}{n-1} \end{align}$$ 即是二项式反演，注意到这里实现了“钦定”到“恰好”的转化。“恰好”到“至少”的转化也可以类似的表示：<br>$$ \begin{align} f[k,l]&amp;=\sum\limits_{j=k}^n g[j,l]\newline \Leftrightarrow g[k,l]&amp;=f[k,l]-f[k+1,l] \end{align} $$ 总结来说，二项式反演联系了“钦定”与“恰好”限制，前/后缀和和差分联系了“至少”和“恰好”限制。</p><h3 id="用-set-维护线段覆盖"><a href="#用-set-维护线段覆盖" class="headerlink" title="用 set 维护线段覆盖"></a>用 set 维护线段覆盖</h3><p>看这样一个问题：</p><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给出 $n$ 条线段 $[l_1,r_1],…[l_n,r_n]$，$q$ 次询问编号在 $[a,b]$ 内的线段覆盖的总长度是多少。<br>$n,q\le 10^5, l_i, r_i \le 10^9$</p></div></article><p>首先离线询问，把每个询问挂在询问区间的右端点上。考虑枚举询问的右端点 $b$，并用数据结构来维护每个 $i(i\le b)$ 的答案。</p><p>考虑怎样能快速地维护。如果对数轴上的每一个点维护一下它最后一次被覆盖是在什么时候（没覆盖就是 0），那么可以发现数轴会被划分成若干值相同的连续段。注意到同一时刻连续段的数量只有 $O(n)$ 种，那么我们考虑用 set 去维护这个东西。</p><p>具体来说，我们可以维护一个二元组 $(r,t)$，其中 $r$ 是当前连续段的分界点（右端点），$t$ 是当前连续段最晚被覆盖的时间。我们考虑新加入一个段 $(r_i,i)$，那么首先所有与其有交的连续段都会受到影响。具体来说，会有一些连续段被完全覆盖，即等价于删除，还有至多两个连续段会被分裂成两部分，其中一部分被保留，另一部分被替代。</p><p>我们考虑如果删除了一个连续段 $(r’,t’)$，它的长度是 $l$，那么左端点在 $[t’+1,i]$ 内区间的答案都会被加上 $l$，因为当前连续段的影响从 $t’$ 扩大到了 $i$。那么我们需要一个数据结构，支持区间加和单点求值，那么套一个 BIT 就可以解决了。时间复杂度是 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;PAIR&gt; :: iterator</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) ne = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PAIR</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> PAIR &amp;o) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x ^ o.x ? x &lt; o.x : y &lt; o.y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">PAIR <span class="title">mp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;PAIR o; o.x = a, o.y = b; <span class="keyword">return</span> o;&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;PAIR&gt; S; <span class="built_in">vector</span>&lt;PAIR&gt; Q[CN];</span><br><span class="line"><span class="keyword">int</span> n, m, L[CN], R[CN], ans[CN];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] += x, p += p &amp; (-p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;add(l, x), add(r + <span class="number">1</span>, -x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r += d[p], p -= p &amp; (-p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) L[i] = read(), R[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        Q[r].pb(mp(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    S.insert(mp(<span class="number">1e9</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L[i], r = R[i], fst = <span class="number">-1</span>, prv = l - <span class="number">1</span>;</span><br><span class="line">        iter it = S.lower_bound(mp(l, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it == S.end()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = (*it).x, p = (*it).y, len;</span><br><span class="line">            <span class="keyword">if</span>(fst &lt; <span class="number">0</span>) fst = p;</span><br><span class="line">            len = min(cur, r) - prv, D.md(p + <span class="number">1</span>, i, len);</span><br><span class="line">            <span class="keyword">if</span>(cur &lt;= r)&#123;</span><br><span class="line">                prv = cur;</span><br><span class="line">                iter pit = it; it++, S.erase(pit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; <span class="number">1</span>) S.insert(mp(l - <span class="number">1</span>, fst));</span><br><span class="line">        S.insert(mp(r, i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = Q[i].size(), j = <span class="number">0</span>; j &lt; l; j++)</span><br><span class="line">            ans[Q[i][j].y] = D.qu(Q[i][j].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快考试了，整理一下最近学到的细碎的东西。东西很杂，也有一些叫不上名字来，简单写写吧……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>圆方树</title>
    <link href="https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/21/%E5%9C%86%E6%96%B9%E6%A0%91/</id>
    <published>2020-09-21T06:15:00.000Z</published>
    <updated>2023-04-15T11:39:52.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们对一张联通无向图的每个 BCC（点双连通分量）建一个方点，原图上每个点作为一个圆点。对于不在环上的点，保留它们之间的边；对于环上的点，把它们和对应的方点相连边，就得到了一棵圆方树，如下图。</p><p><img src="/oi-blog/pictures/1126418-20190711015718548-2063534813.png" alt="圆方树的构建"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>这里使用的是 <code>PinkRabbit</code> 兔队的<a href="https://www.cnblogs.com/PinkRabbit/p/10446473.html#codeforces-487etourists">构建方法</a>，用于一般无向图的圆方树构建。注意，对于仙人掌图的圆方树构建，可以在 dfs 中枚举返祖边来完成，它的好处在于能求出环上的点的顺序，以便于维护环上路径信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext = n; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(v), T[v].push_back(ext);</span><br><span class="line">                T[ext].push_back(u), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问 $u,v$ 之间的割点的数量。<br>$n,m,q\le 5\times 10^5$</p></div></article><p>容易发现答案就是圆方树上 $u\to v$ 的路径上圆点的数量，倍增维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, fa[CN][<span class="number">21</span>]; <span class="keyword">bool</span> w[CN]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, fa[ext][<span class="number">0</span>] = u, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], fa[pos][<span class="number">0</span>] = ext, T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[CN], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + w[u];</span><br><span class="line">    <span class="keyword">int</span> sz = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), l = lca(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dis[x] + dis[y] - dis[l] - dis[ fa[l][<span class="number">0</span>] ]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，问有多少三元组 $(s,c,f)$ 满足存在一条 $s\to f$ 的路径经过 $c$。<br>$n,m\le 2\times 10^5$</p></div></article><p>题目本质上就是在求 $s\to f$ 的简单路径的并集大小。</p><p>有一个经典结论：</p><ol><li>一张无向图上相同 BCC 中两个点 $(u,v)$ 之间的简单路径并集恰好是这个 BCC</li><li>一张无向图上不同 BCC 中两个点 $(u,v)$ 之间的简单路径并集是这两个 BCC 并上把它们连接的点</li></ol><p>于是可以圆方树上的点恰当赋值：方点点权为该 BCC 的大小，圆点点权为 $-1$。那么 $s\to f$ 在树上的路径权就是合法的 $c$ 的数量。</p><p>考虑计算所有圆点对 $(s,f)$ 的路径长度和。运用贡献法去想，答案是每个 $w[u]$（即点权）乘上经过这个点的路径数量。经过 $u$ 的路径可以分为两种：从 $u$ 子树内到 $u$ 子树外；$u$ 子树内兄弟节点之间的路径。前者的数量是 $sz[u]\times (n-sz[u])$，后者的数量大概是 $\dbinom{sz[u]}{2}$ 再减去若干部分，直接在 dfs 的过程中计算即可，时间复杂度 $O(n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ne = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], idx = <span class="number">0</span>, stk[CN], top = <span class="number">0</span>, ext, w[CN], num; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u, w[u] = <span class="number">-1</span>, num++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ext++, T[u].push_back(ext);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; w[ext] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos), w[ext]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="keyword">int</span> sz[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size(); sz[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i]), ans += <span class="number">1ll</span> * sz[u] * sz[ T[u][i] ] * w[u], sz[u] += sz[ T[u][i] ];</span><br><span class="line">    ans += <span class="number">1ll</span> * sz[u] * (num - sz[u]) * w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!dfn[i]) num = <span class="number">0</span>, bd(i, <span class="number">0</span>), dfs(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，点有点权，$q$ 次询问 $u\to v$ 的可行简单路径上权值最小值，支持修改点权。<br>$n,m,q\le 10^5$</p></div></article><p>注意到如果不带修改，直接圆方树上倍增即可。带修的话，显然的想法是重链剖分之后套个线段树。</p><p>但是这样有个问题，就是修改一个圆点需要修改所有与其相连的方点，这样实际上是 $O(n)$ 的。<br>我们考虑利用圆方树的性质，把方点的点权设为它的儿子的权值最小值，那么因为一个圆点至多有一个方点作为父亲，这样修改就变成了 $O(1)$ 的。<br>但是这样查询的时候如果方点的父亲没被访问到，即方点作为 lca 的情况，还需要对这个方点的父亲的权值取 $\min$。</p><p>时间复杂度 $O(n\log^2 n)$，常数不小，因为实际上我们需要一个 <code>multiset</code> 去维护方点的点权……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ne = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q; </span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; val[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T[CN];</span><br><span class="line"><span class="keyword">int</span> dfn[CN], low[CN], dfc = <span class="number">0</span>, w[CN], ext = <span class="number">0</span>, stk[CN], tp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++dfc, stk[++tp] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            bd(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; ext++;</span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) </span><br><span class="line">                    pos = stk[tp--], T[ext].push_back(pos), val[ext].insert(w[pos]);</span><br><span class="line">                w[ext] = *val[ext].begin(), T[u].push_back(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc k &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc k &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[k] = x);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) md(l, m, lc, p, x); <span class="keyword">else</span> md(m + <span class="number">1</span>, r, rc, p, x);</span><br><span class="line">        d[k] = min(d[lc], d[rc]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= m) ans = qu(l, m, lc, s, t);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; t) ans = min(ans, qu(m + <span class="number">1</span>, r, rc, s, t));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], id[CN], idx = <span class="number">0</span>, top[CN], imp[CN], sz[CN], fa[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u] = p, dep[u] = dep[p] + <span class="number">1</span>, sz[u] = <span class="number">1</span>; <span class="keyword">int</span> mx = <span class="number">0</span>, l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        dfs1(v, u), sz[u] += sz[v], imp[u] = mx &lt; sz[v] ? mx = sz[v], v : imp[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[u] = ++idx, D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[u], w[u]), top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(imp[u]) dfs2(imp[u], t); <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[u][i]; </span><br><span class="line">        <span class="keyword">if</span>(v ^ imp[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">while</span>(top[x] ^ top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ top[x] ] &lt; dep[ top[y] ]) swap(x, y);</span><br><span class="line">        ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[ top[x] ], id[x]));</span><br><span class="line">        x = fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    ans = min(ans, D.qu(<span class="number">1</span>, ext, <span class="number">1</span>, id[y], id[x]));</span><br><span class="line">    <span class="keyword">if</span>(y &gt; n) ans = min(ans, w[ fa[y] ]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    ext = n = read(), m = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bd(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;  <span class="built_in">cin</span> &gt;&gt; c; <span class="keyword">int</span> a = read(), b = read();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[a], b); <span class="keyword">int</span> f = fa[a];</span><br><span class="line">            <span class="keyword">if</span>(f &gt; n)&#123;</span><br><span class="line">                val[f].erase(w[a]), val[f].insert(b);</span><br><span class="line">                <span class="keyword">if</span>(*val[f].begin() ^ w[f]) w[f] = *val[f].begin(), D.md(<span class="number">1</span>, ext, <span class="number">1</span>, id[f], w[f]);</span><br><span class="line">            &#125;</span><br><span class="line">            w[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, qu(a, b)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点 $m$ 条边的图，$q$ 次询问，每次询问给出一个点集 $S$，问有多少点满足在图上删除该点后，$\exists u,v\in S$，$u,v$ 在图上不连通。<br>$n,m\le 10^5, \sum|S_i|\le 2\times 10^5$</p></div></article><p>“圆方树上圆方果，<br>“圆方树下你和我，<br>“圆方树前建虚树，<br>“欢乐多又多。</p><p>Subtask2 $|S_i|=2$ 两点间割点数量等于圆方树上点对路径上的圆点数量，则直接在圆方树上倍增即可。<br>Subtask3 考虑建出圆方树的虚树来，然后就可以简单树形 DP 了，时间复杂度 $O(n)-O(|S_i|\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ne = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar(); <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar(); <span class="keyword">return</span> s * ne;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TC, n, m, q, id[CN]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[CN], T[CN], S[CN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, dfn[CN], low[CN], idx = <span class="number">0</span>, ext;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx, stk[++top] = u;</span><br><span class="line">    <span class="keyword">int</span> l = G[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">// dfn[] 需要清空!!!</span></span><br><span class="line">            tarjan(v, u), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u] == low[v])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>; T[u].push_back(++ext), T[ext].clear(); </span><br><span class="line">                <span class="keyword">while</span>(pos ^ v) pos = stk[top--], T[ext].push_back(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dis[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[u] = ++idx, fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dis[u] = dis[p] + (u &lt;= n);</span><br><span class="line">    <span class="keyword">int</span> l = T[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) dfs(T[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="keyword">int</span> rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    rt = stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], S[ a[<span class="number">1</span>] ].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = a[i], l = lca(u, stk[top]); <span class="keyword">if</span>(dfn[l] &lt; dfn[rt]) rt = l;</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span> ] ] &gt; dfn[l]) S[ stk[top - <span class="number">1</span>] ].push_back(stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(stk[top - <span class="number">1</span>] ^ l) S[l].clear(), S[l].push_back(stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> S[l].push_back(stk[top--]);</span><br><span class="line">        &#125;</span><br><span class="line">        S[u].clear(), stk[++top] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) S[ stk[i] ].push_back(stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = S[u].size(); f[u] = u &lt;= n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = S[u][i]; </span><br><span class="line">        dp(v), f[u] += f[v] + dis[ fa[v][<span class="number">0</span>] ] - dis[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    TC = read(); <span class="keyword">while</span>(TC--)&#123;</span><br><span class="line">        ext = n = read(), m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear(), T[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(); G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn)), idx = top = <span class="number">0</span>, tarjan(<span class="number">1</span>, <span class="number">0</span>), idx = <span class="number">0</span>, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ext; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        q = read();</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            id[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[<span class="number">0</span>]; i++) id[i] = read();</span><br><span class="line">            build(id, id[<span class="number">0</span>]), dp(rt), <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[rt] - id[<span class="number">0</span>]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P4320">「LG-P4320」道路相遇</a></li><li><a href="https://loj.ac/problem/2587">「APIO2018」Duathlon</a></li><li><a href="https://codeforces.com/problemset/problem/487/E">「CF487E」Tourists</a></li><li><a href="https://www.luogu.com.cn/problem/P4606">「SDOI2018」战略游戏</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P5236">「LG-P5236」静态仙人掌</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，圆方树是用以解决一类仙人掌图问题的重构树，但是类似的方法也可以用来解决某些普通无向图问题。依赖于其优美的树形结构，我们可以在 $\log |V|$ 的时间复杂度内回答一类图上的点对路径并集的询问问题……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="圆方树" scheme="https://big-news.cn/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
      <category term="仙人掌图" scheme="https://big-news.cn/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」洛谷九月月赛</title>
    <link href="https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
    <id>https://big-news.cn/2020/09/19/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8D%E6%B4%9B%E8%B0%B7%E4%B9%9D%E6%9C%88%E6%9C%88%E8%B5%9B/</id>
    <published>2020-09-19T08:48:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>今天怎么有一页阿克爷啊…..<br>怎么我还是啥都不会啊……</p><a id="more"></a><h3 id="A-子弦"><a href="#A-子弦" class="headerlink" title="A 子弦"></a>A 子弦</h3><p>容易发现答案是出现次数最多的字母的出现次数。证明很简单：再扩展一位字符出去限制性也不会变弱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e7</span> + <span class="number">7</span>; <span class="keyword">char</span> ch[CN]; <span class="keyword">int</span> tot[<span class="number">300</span>], mx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ch[i]; i++) tot[ ch[i] ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) mx = max(mx, tot[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-雷雨"><a href="#B-雷雨" class="headerlink" title="B 雷雨"></a>B 雷雨</h3><p>跑三遍 Dijkstra，枚举一个中间点拼起来就好了，复杂度 $O(nm(\log n + \log m))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> x, y; LL v; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp; a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125;;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL c)</span> </span>&#123;DJ d; d.x = a, d.y = b, d.v = c; <span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;DJ&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m,<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, LL d[][CN], LL dis[][CN])</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    Q.push( mk(sx, sy, dis[sx][sy] = d[sx][sy]) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.top().x, y = Q.top().y; Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>; vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> vx = x + dx[k], vy = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(!vx || !vy || vx &gt; n || vy &gt; m || vis[vx][vy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[vx][vy] &gt; dis[x][y] + d[vx][vy])&#123;</span><br><span class="line">                dis[vx][vy] = dis[x][y] + d[vx][vy];</span><br><span class="line">                Q.push( mk(vx, vy, dis[vx][vy]) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c; LL d[CN][CN], da[CN][CN], db[CN][CN], dc[CN][CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), a = read(), b = read(), c = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) d[i][j] = read();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(da, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(da)), SP(n, m, <span class="number">1</span>, a, d, da);</span><br><span class="line">    <span class="built_in">memset</span>(db, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(db)), SP(n, m, n, b, d, db);</span><br><span class="line">    <span class="built_in">memset</span>(dc, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dc)), SP(n, m, n, c, d, dc);</span><br><span class="line"></span><br><span class="line">    LL ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            ans = min(ans, da[i][j] + db[i][j] + dc[i][j] - <span class="number">2ll</span> * d[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-梦原"><a href="#C-梦原" class="headerlink" title="C 梦原"></a>C 梦原</h3><p>考虑如果给出一颗形态固定的树，我们应该怎样算答案？我们只需要把 $w[u]$ 变成 $w[ fa[u] ]-w[u]$（就是树上差分），然后把所有 $w[u]&gt;0$ 的 $w[u]$ 加起来就可以了。也就是我们只考虑把多出来的那部分算到费用里面，容易发现这样一定是最优的。</p><p>然后考虑 $i$ 的父亲大概有 $\min i - 1,k$ 种可能，根据期望的线性性，只需对这些可能求个概率加权和就好了。设 $m=\min i-1, k$，得到答案是：<br>$$\sum\limits_{i=1}^n\sum\limits_{j=i-m}^{i-1}\frac{1}{m}[a_j&lt;a_i](a_i-a_j)$$ 实际上就是个二维数点，由于区间是定长，因此直接拿个树状数组维护即可，复杂度 $O(n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P; a = <span class="number">1ll</span> * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[CN], val[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN], cnt[CN], n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] + x) % P, cnt[p]++, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span>(p &lt;= n) d[p] = (d[p] - x + P) % P, cnt[p]--, p += lb(p);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r = (r + d[p]) % P, p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p) r += cnt[p], p -= lb(p); <span class="keyword">return</span> r;&#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D.n = n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), val[ ++val[<span class="number">0</span>] ] = a[i];</span><br><span class="line">    </span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++tmp] = val[i]; val[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = a[<span class="number">1</span>]; </span><br><span class="line">    D.add(id(a[<span class="number">1</span>]), a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = qp(min(i - <span class="number">1</span>, m), P - <span class="number">2</span>), si = D.qu( id(a[i]) ), cnt = D.quc( id(a[i]) );</span><br><span class="line">        si = (<span class="number">1ll</span> * cnt * a[i] % P - si + P) % P;</span><br><span class="line">        ans = (<span class="number">1ll</span> * k * si % P + ans) % P;</span><br><span class="line">        D.add( id(a[i]) , a[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m + <span class="number">1</span>) D.minus( id(a[i - m]), a[i - m] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-线形生物"><a href="#D-线形生物" class="headerlink" title="D 线形生物"></a>D 线形生物</h3><p>看上去今天只有我一个人不会这题的样子……<br>Subtask1, 10pts 交个<code>cout&lt;&lt;(n&lt;&lt;1)</code>上去就好了，因为对每一位都有 $E_i=\frac{1}{2}E_i+1$，解得 $E_i=2$，因此答案是 $2n$。<br>Subtask4, 40pts 看上去用高斯消元解方程就好了，考场上遇到了些哲学问题没调出来…<br>Subtask5…这就不会了啊。<br>事实上赛后<code>红太阳</code> <a href="https://shuyumo2003.github.io/">SSX</a> 告诉我合并方程就完事了…<br>太草了就不写了…感性理解下吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天怎么有一页阿克爷啊…..&lt;br&gt;怎么我还是啥都不会啊……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」AtCoder Beginner Contest 178</title>
    <link href="https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/"/>
    <id>https://big-news.cn/2020/09/13/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DAtCoder%20Beginner%20Contest%20178/</id>
    <published>2020-09-13T13:23:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>人生 AK 第一场，不过我还是这么的菜……</p><a id="more"></a><p><a href="https://atcoder.jp/contests/abc178">比赛链接</a></p><h3 id="A-Not"><a href="#A-Not" class="headerlink" title="A. Not"></a>A. Not</h3><p>考察输入输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x; x ^= <span class="number">1</span>; <span class="built_in">cout</span> &lt;&lt; x;&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Product-Max"><a href="#B-Product-Max" class="headerlink" title="B. Product Max"></a>B. Product Max</h3><p>对四个值取个 $\max$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL a, b, c, d, x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    x = max(a * c, a * d), y = max(b * c, b * d);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Ubiquity"><a href="#C-Ubiquity" class="headerlink" title="C. Ubiquity"></a>C. Ubiquity</h3><p>简单容斥一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P; a = <span class="number">1ll</span> * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = qp(<span class="number">10</span>, n), k = <span class="number">2ll</span> * qp(<span class="number">9</span>, n) % P;</span><br><span class="line">    ans = (ans - k + P) % P, k = qp(<span class="number">8</span>, n), ans = (ans + k) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Redistribution"><a href="#D-Redistribution" class="headerlink" title="D. Redistribution"></a>D. Redistribution</h3><p>枚举数列的长度，然后简单插板即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e3</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> C[CN][CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = ( C[i - <span class="number">1</span>][j] +<span class="number">0ll</span>+ C[i - <span class="number">1</span>][j - <span class="number">1</span>] ) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, pcal(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l * <span class="number">3</span> &lt;= n; l++) ans = (ans + C[n - l * <span class="number">2</span> - <span class="number">1</span>][l - <span class="number">1</span>]) % P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Dist-Max"><a href="#E-Dist-Max" class="headerlink" title="E. Dist Max"></a>E. Dist Max</h3><p>求平面曼哈顿距离的最大值，有一个经典的技巧是把曼哈顿距离的绝对值拆成四个值的 $\max$，即有：<br>$$|x-x’|+|y-y’|=\max x-x’+y-y’, x-x’+y’-y, x’-x+y-y’, x’-x+y’-y$$ 于是维护一下 $x+y$ 和 $x-y$ 的最大最小值更新答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, x[CN], y[CN], mx = -INF, mn = INF, ans = -INF;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] + y[i]), mn = min(mn, x[i] + y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    mx = -INF, mn = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, x[i] - y[i]), mn = min(mn, x[i] - y[i]);</span><br><span class="line">    ans = max(ans, mx - mn);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Contrast"><a href="#F-Contrast" class="headerlink" title="F. Contrast"></a>F. Contrast</h3><p>大概拿<code>set</code>维护一下就好，但是我的做法好像假了，不过考场上瞎搞过去了……<br>做法先咕着吧。</p><p>先贴一份假代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ne = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[CN], b[CN]; <span class="keyword">int</span> cnt[CN]; <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = read(), S.insert(b[i]), cnt[ b[i] ]++;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> has = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it = S.begin(); it != S.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = *it;</span><br><span class="line">            <span class="keyword">if</span>(val ^ a[i])&#123;</span><br><span class="line">                b[i] = val, has = <span class="literal">true</span>, cnt[val]--; </span><br><span class="line">                <span class="keyword">if</span>(!cnt[val]) S.erase(it); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag &amp;= has;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生 AK 第一场，不过我还是这么的菜……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="AtCoder" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/AtCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>概率期望学习笔记</title>
    <link href="https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://big-news.cn/2020/09/13/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-13T09:04:00.000Z</published>
    <updated>2021-01-22T13:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>随机变量 $x$ 的数学期望 $E(x)$ 定义为 $x$ 的每种取值的概率加权和，可以理解为 $x$ 在平均情况下的取值，我们一般称其为「期望取值」。<br>举个例子，若 $x$ 有 $1/3$ 的概率为 $1$，有 $2/3$ 的概率为 $2$，则 $E(x)=1/3+2\times (2/3)=5/3$。</p><h3 id="线性性"><a href="#线性性" class="headerlink" title="线性性"></a>线性性</h3><p>根据乘法结合律以及分配律，可以发现期望具有线性性，可以将其理解为「元素和的期望等于元素期望的和」，亦即：<br>$$ E(\Sigma x_i)=\sum E(x_i) $$ 设 $c$ 为常量，也容易验证：<br>$$E(x+c)=E(x)+c$$</p><h3 id="一道简单题"><a href="#一道简单题" class="headerlink" title="一道简单题"></a>一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个长度为 $n$ 的数列，一开始所有位置都未被访问。每次随机一个未被访问过的位置，将它和它之前的位置都标记为访问过，问期望操作次数。<br>$n\le 10^{18}$</p></div></article><p>考虑期望的线性性，答案就等于每个位置能被访问到的概率。一个位置 $i$ 能被访问到当且仅当它在所有它后面的数之前被访问，这个概率是 $\frac{1}{n-i+1}$，因此容易发现答案是调和级数 $H_n$，使用近似公式计算即可。</p><h3 id="又一道简单题"><a href="#又一道简单题" class="headerlink" title="又一道简单题"></a>又一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有一个 $n$ 个节点的有根树，一开始所有节点都未被访问。每次随机一个未被访问过的节点，将它到根的路径上所有点都标记为访问过，问期望操作次数，对 $998244353$ 取模。<br>$n\le 10^7$</p></div></article><p>仿照上题，容易发现答案是 $\sum\limits_{i=1}^n\frac{1}{sz[i]}$，其中 $sz[i]$ 表示子树 $i$ 的大小，线性求逆即可。</p><h3 id="双一道简单题"><a href="#双一道简单题" class="headerlink" title="双一道简单题"></a>双一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 堆石子，每堆有 $a_i$ 个，每次随机选一个石子，并取光它所在的那堆石子。问第一堆石子被取到的时间的期望。<br>$n\le 10^5$</p></div></article><p>根据期望的线性性，答案等于每堆石子在 $1$ 之前取到的期望之和，即 $1+\sum\limits_{i=2}^n\frac{a_i}{a_1+a_i}$，线性计算即可。</p><h3 id="叒一道简单题"><a href="#叒一道简单题" class="headerlink" title="叒一道简单题"></a>叒一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个 $n$ 面的骰子，问每一面都被掷到的期望投掷次数。<br>$n\le 10^{18}$</p></div></article><p>此类问题被称作「赠券收集问题」。<br>设 $f[n]$ 为 $n$ 面掷出后还需投掷的次数的期望，易得 $f[i]=\frac{i}{n}f[i]+\frac{n-i}{n}f[i+1]+1$，整理得 $f[i]=f[i+1]+\frac{n}{n-i}$，从而有 $f[0]=nH_n$，利用公式计算即可。</p><h3 id="叕一道简单题"><a href="#叕一道简单题" class="headerlink" title="叕一道简单题"></a>叕一道简单题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>求所有 $n!$ 个 $n$ 的全排列中，逆序对数的期望，对 $998244353$ 取模。<br>$n\le 10^{7}$</p></div></article><p>众所周知，$n$ 的全排列一共有 $\dfrac{n!}{2}\dbinom{n}{2}$ 个逆序对，即对每个二元组 $(i,j)$ 讨论一下它们是否会形成逆序对。<br>因此答案为 $\dfrac{\dfrac{n!}{2}\dbinom{n}{2}}{n!}=\dfrac{n(n-1)}{4}$。</p><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p></div></article><p>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$ 求出答案。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>给定一颗 $n$ 个节点的有根树，$1$ 号节点为根，树上的每个节点 $u$ 都有一个权值 $c_u$。<br>你需要随机一个节点的排列 $P\in [n]$， 并且按这个排列的顺序依次访问所有树上的节点。每当访问到树上的一个节点 $u$ 时，你需要将子树 $u$ 内所有节点的权值加上 $c_u$（包括点 $u$）。<br>问在一切的操作结束之后所有节点权值之和的期望。由于期望可能不是一个整数，请将它乘上 $n!$，并对 $10^9+7$ 取模。<br>$n\le 10^5$, 且<strong>保证树的形态随机</strong></p></div></article><p>根据期望的线性性，我们只需要求出每个节点最后的期望权值即可。设这个东西是 $a_u$ ，容易发现 $a_u$ 的取值只与从根到 $u$ 的这一条祖孙链上的节点有关。<br>因为树的形态随机，所以树高是期望 $O(\sqrt{n})$ 的。设祖孙链长为 $d$，那么只需考虑 $O(d)$ 地求出 $a_u$ 即可。<br>运用贡献法考虑：期望权值 = $Σ$权值$×$期望累加次数，那么考虑预处理一个 $t[]$，使得 $a_u=\sum c_v·t_v$ 即可。</p><p>容易发现 $t_v$ 的取值只与 $u,v$ 的相对距离有关，则可以设 $f_i$ 表示考虑随机访问一个有 $n$ 位的序列 $a_1,a_2,…,a_n$，$a_1$ 在 $i$ 上的期望累加次数。<br>考虑一次累加应当是什么样子： $1\to p_1\to p_2\to …\to i$，且满足 $1&lt;p_1&lt;p_2&lt;…&lt;i$。这显然双射了一个上升子序列（IS）。<br>则 $f_i$ 即代表考虑所有 $P\in [i]$，$P$ 中以 $1$ 起始的 IS 的期望数量。这样我们可以直接拿组合数选出来，即有：<br>$$ f_i=\sum\limits_d \dbinom{i-1}{d-1}\dbinom{i}{d}(i-d)! $$ 于是就可以计算了，时间复杂度 $O(n\sqrt{n})$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P; a = <span class="number">1ll</span> * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[CN], fac[CN], ifac[CN], f[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * (<span class="number">1ll</span> * fac[n] * ifac[m] % P) * ifac[n - m] % P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">stk[dep] = a[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = dep, j = <span class="number">1</span>; i; i--, j++) ans = (<span class="number">1ll</span> * stk[i] * f[j] % P + ans) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = E[k].to;</span><br><span class="line"><span class="keyword">if</span>(v ^ p) dfs(v, u, dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">ifac[n] = qp(fac[n], P - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) ifac[i] = <span class="number">1ll</span> * (i + <span class="number">1</span>) * ifac[i + <span class="number">1</span>] % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= i; d++)&#123;</span><br><span class="line"><span class="keyword">int</span> prd = <span class="number">1ll</span> * C(i - <span class="number">1</span>, d - <span class="number">1</span>) * C(i, d) % P;</span><br><span class="line">prd = <span class="number">1ll</span> * prd * fac[i - d] % P, f[i] = (f[i] + prd) % P;</span><br><span class="line">&#125;</span><br><span class="line">f[i] = <span class="number">1ll</span> * f[i] * ifac[i] % P; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + a[i]) % P;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), ans = <span class="number">1ll</span> * ans * fac[n] % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $n$ 种方法，每种方法需要 $k_i$ 条途径，第 $j$ 条途径有 $p[i,j]$ 的概率无法使用。每次可以查询任意一条途径可否使用，直到查询到一种能使用的方法，求最小的“最少查询次数的期望”。<br>$n,k_i \le 500$</p></div></article><p>容易发现对于任意一种方法，如果不将其全部查询完，那么这次查询是无意义的。对于任意一种方法，我们应当按照 $p[i,j]$ 降序排序的顺序去查询。<br>假定 $\forall i$，$p[i,j]$ 已经降序排序为 $p_1,p_2,…p_{k_i}$，那么考虑对所有方法进行排列，设 $E_i$ 为考虑 $[1:i]$ 中的方法时的答案，则有：<br>$$\begin{aligned} E_i&amp;=p_1(1+E_{i-1}) + p_2(1-p_1)(2+E_{i-1})+…\newline &amp;=k_iE_{i-1}+b_i \end{aligned} $$ 注意到还有 $\prod\limits_j (1-p_j)$ 的概率本次查询不会停止，把这部分加到常数项即可。<br>于是变成了一次函数嵌套的最小值问题，按 $(k_i-1)/b_i$ 升序排序即可，时间复杂度 $O(\sum k_i + n\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DB double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">const</span> DB EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, id[CN]; DB k[CN], b[CN], p[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(DB x, DB y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> k[i] * b[j] + b[i] &lt; k[j] * b[i] + b[j];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        m = read(); <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[j]);</span><br><span class="line">        sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, cmp); DB prd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>] &gt; <span class="number">1.0</span> - EPS) &#123;i--, n--; <span class="keyword">continue</span>;&#125; <span class="keyword">while</span>(m &amp;&amp; p[m] &lt;= EPS) m--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) k[i] += p[j] * prd, b[i] += p[j] * prd * j, prd *= (<span class="number">1.0</span> - p[j]);</span><br><span class="line">        b[i] += m * prd, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, comp); DB ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i, p = n; p; p--) i = id[p], ans = k[i] * ans + b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叒一道栗题"><a href="#叒一道栗题" class="headerlink" title="叒一道栗题"></a>叒一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>有 $m$ 张牌，其中一张是王牌。现在你执行 $n$ 次如下操作：洗牌后查看第一张牌是什么。<br>令 $x$ 为洗牌后第一张牌为王牌的次数，现在假设洗牌时 $m!$ 种牌的排列出现的概率均相等，求 $x^k$ 的期望值，对 $998244353$ 取模。<br>$n,m\le 998244352, k\le 5000$</p></div></article><p>题目等价于：有 $n$ 个相互独立的随机变量 $x_1,x_2,…x_n$，每个变量有 $\frac{1}{m}$ 的概率为 $1$，其余情况为 $0$，求：<br>$$E[\left(\sum\limits_{i=1}^nx_i\right)^k]$$</p><p>根据期望的线性性，可以枚举 $d=\sum\limits_{i=1}^nx_i$，则有：<br>$$\begin{aligned} E[\left(\sum\limits_{i=1}^nx_i\right)^k] &amp;=\sum\limits_{d=0}^n E(d^k)\newline &amp;= \sum\limits_{d=0}^n P(d)·d^k\newline  &amp;= \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k  \end{aligned}$$ 把后面的 $d^k$ 拿 Stirling 数展开，大力化一下柿子，得到：<br>$$ \sum\limits_{d=0}^n\dbinom{n}{d}\left(\frac{1}{m}\right)^d\left(1-\frac{1}{m} \right)^{n-d} ·d^k=\sum\limits_{i=0}^k \begin{Bmatrix}k\newline i\end{Bmatrix} n^{\underline{i}}\left(\frac{1}{m} \right)^i $$ 就可以做了，时间复杂度 $O(k^2)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">int</span> r = <span class="number">1</span>; <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = <span class="number">1ll</span> * r * a % P; a = <span class="number">1ll</span> * a * a % P; b &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, S[CN][CN], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read(), m = qp(m, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) S[i][j] = (<span class="number">1ll</span> * j * S[i - <span class="number">1</span>][j] % P + S[i - <span class="number">1</span>][j - <span class="number">1</span>]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fall = <span class="number">1</span>, pw = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> prd = <span class="number">1ll</span> * S[k][i] * fall % P;</span><br><span class="line">        ans = (<span class="number">1ll</span> * prd * pw % P + ans) % P;</span><br><span class="line">        pw = <span class="number">1ll</span> * pw * m % P, fall = <span class="number">1ll</span> * fall * (n - i) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li>暂无来源</li><li>暂无来源</li><li>暂无来源</li><li><a href="https://www.spoj.com/problems/FAVDICE/">「SPOJ1026」FAVDICE - Favorite Dice</a> </li><li>暂无来源</li><li><a href="https://darkbzoj.tk/problem/4318">「BZOJ4318」OSU!</a></li><li>暂无来源</li><li>暂无来源</li><li><a href="https://codeforces.com/problemset/problem/1278/F">「CF1278F」Cards</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P6834?contestId=34123">「LG-P6843」梦原</a><br><a href="https://www.luogu.com.cn/problem/P6835?contestId=34123">「LG-P5835」线形生物</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，一个随机变量 $x$ 的数学期望定义为 $E(x)$，即是 $E(x)traodinary$ 的缩写形式，代表 $x$ 是一个非凡的数字……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="期望" scheme="https://big-news.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/"/>
    <id>https://big-news.cn/2020/09/11/%E8%99%9A%E6%A0%91/</id>
    <published>2020-09-11T00:39:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定点集 $V_k$ 代表有效点，我们定义一颗树 $T=(V,E)$ 是建立在 $V_k$ 上的虚树，当且仅当：</p><ol><li>$V_k\subseteq V$</li><li>$\forall x\in V, x\in V_k \text{ or } \exists u,v\in V, \text{s.t. } \text{LCA}(u,v)=x$ </li><li>$\forall (u,v)\in E, \text{LCA}(u,v)=u\text{ or }v$</li></ol><p>一句话来讲：虚数是关键点以及关键点的 LCA 构成的，保证原树的祖孙关系不变的重构树。</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>模仿笛卡尔树的构建，虚树的构建可以使用单调栈在 $O(|V_k|\log |V|)$ 的时间内完成，其中 $\log V$ 的复杂度是倍增 LCA 的复杂度。如果使用 $O(n)-O(1)$ 的 RMQ-LCA，则可以降至 $O(|V_k|\log |V_k|)$，基本可以视作线性。<br>这种方法一般被称为「单调栈维护右链」。</p><p>顾名思义，这种构建方法的本质就在于使用单调栈去维护虚数最靠右边的树链。容易得出这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: sort;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span>&#123;</span>&#125;  E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>, dfn[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125; <span class="comment">// 按 dfs 序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(a[i], stk[top]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，边有边权。$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少边能使得关键点都不与 $1$ 号节点联通，最小化切断的边的边权。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>如果只有一次询问，则可以通过树上 DP 简单求出。注意到 DP 的过程中有效的点只有关键点和它们的 LCA，因此直接建出虚树 DP 即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mn[CN], dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// 预处理</span></span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) mn[v] = min(mn[u], E[k].w), dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// 倍增 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[x][k] ] &gt;= dep[y]) x = fa[x][k];</span><br><span class="line">    <span class="keyword">if</span>(x ^ y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[x][k] ^ fa[y][k]) x = fa[x][k], y = fa[y][k];</span><br><span class="line">        x = fa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[CN], stk[CN], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123; <span class="comment">// 建立虚树</span></span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125; </span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i]; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// DP</span></span><br><span class="line">    f[u] = mn[u]; <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 小心翼翼的初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dp(v, u), sum += f[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!is[u]) f[u] = min(f[u], sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);&#125;</span><br><span class="line">    mn[<span class="number">1</span>] = INF, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hd, <span class="number">0</span>, <span class="keyword">sizeof</span>(hd)), ecnt = <span class="number">0</span>;</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), dp(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>; <span class="comment">// 小心翼翼的清空标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问切断多少点能使得关键点互不相连，无解输出 -1。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>依然沿用上题的思路，只不过在树上 DP 的时候细节较多。可以维护一个 $g[u]$ 表示子树 $u$ 中是否还存在与 $u$ 相连的关键点，在转移时分类讨论即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[CN], fa[CN][<span class="number">21</span>], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>, hd[<span class="number">1</span>] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top]), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top]), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[CN], g[CN]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    f[u] = g[u] = <span class="number">0</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dp(v, u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        f[u] += f[v], cnt += g[v];</span><br><span class="line">        <span class="keyword">if</span>(is[u] &amp;&amp; is[v] &amp;&amp; dep[v] - dep[u] &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is[u]) f[u] += cnt, g[u] = <span class="number">1</span>; <span class="comment">// 讨论 u 的决策</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) f[u]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>) g[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd();</span><br><span class="line">        <span class="keyword">if</span>(dp(<span class="number">1</span>, <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[<span class="number">1</span>]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双一道栗题"><a href="#双一道栗题" class="headerlink" title="双一道栗题"></a>双一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body"><p>$n$ 个点的树，$q$ 次询问，每次给出 $k_i$ 个关键点，问关键点之间的两两距离和，距离最小值和距离最大值。<br>$n,q,\sum k_i\le 10^5$</p></div></article><p>距离最大 / 最小都可以简单维护，对于“距离和”这个问题，有一个常用方法是考虑每条边对答案的贡献。这就跟边有关系了，因此在建立虚树时不能再固定以 $1$ 号节点为根，简单维护一下树根即可，时间复杂度 $O(\sum k_i\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,w; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span> </span>&#123;to = t, nxt = n, w = d;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN], dis[CN], dfn[CN], idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>, dfn[u] = ++idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) dis[v] = dis[u] + E[k].w, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k];</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> dfn[i] &lt; dfn[j];&#125;</span><br><span class="line"><span class="keyword">int</span> stk[CN], top = <span class="number">0</span>, a[CN], rt; <span class="comment">// rt 维护树根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + a[<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">    stk[top = <span class="number">1</span>] = a[<span class="number">1</span>], hd[ a[<span class="number">1</span>] ] = <span class="number">0</span>, ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = lca(stk[top], a[i]);</span><br><span class="line">        <span class="keyword">if</span>(l ^ stk[top])&#123;</span><br><span class="line">            <span class="keyword">while</span>(dfn[ stk[top - <span class="number">1</span>] ] &gt; dfn[l]) add(stk[top - <span class="number">1</span>], stk[top], <span class="number">0</span>), top--;</span><br><span class="line">            <span class="keyword">if</span>(l ^ stk[top - <span class="number">1</span>]) hd[l] = <span class="number">0</span>, add(l, stk[top], <span class="number">0</span>), stk[top] = l;</span><br><span class="line">            <span class="keyword">else</span> add(l, stk[top], <span class="number">0</span>), top--;</span><br><span class="line">        &#125;</span><br><span class="line">        hd[ a[i] ] = <span class="number">0</span>, stk[++top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rt = stk[<span class="number">1</span>]; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; i++) add(stk[i], stk[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mn[CN], mx[CN], sz[CN], amn, amx, ans, tmp1[<span class="number">4</span>], tmp2[<span class="number">4</span>]; <span class="keyword">bool</span> is[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hd[u]) <span class="keyword">return</span> (<span class="keyword">void</span>)(mn[u] = mx[u] = <span class="number">0</span>, sz[u] = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mn[u] = INF, mx[u] = sz[u] = <span class="number">0</span>; <span class="keyword">int</span> Mn = INF, pMn = INF, Mx = <span class="number">0</span>, pMx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to, d = dis[v] - dis[u]; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        dp(v, u);</span><br><span class="line">        </span><br><span class="line">        mn[u] = min(mn[u], mn[v] + d), tmp1[<span class="number">0</span>] = mn[v] + d,</span><br><span class="line">        mx[u] = max(mx[u], mx[v] + d), tmp2[<span class="number">0</span>] = mx[v] + d;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line"></span><br><span class="line">        ans += d * (a[<span class="number">0</span>] - sz[v]) * sz[v]; <span class="comment">// 计算距离和</span></span><br><span class="line"></span><br><span class="line">        tmp1[<span class="number">1</span>] = Mn, tmp1[<span class="number">2</span>] = pMn, tmp2[<span class="number">1</span>] = Mx, tmp2[<span class="number">2</span>] = pMx;</span><br><span class="line">        sort(tmp1, tmp1 + <span class="number">3</span>), sort(tmp2, tmp2 + <span class="number">3</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        Mn = tmp1[<span class="number">0</span>], pMn = tmp1[<span class="number">1</span>], Mx = tmp2[<span class="number">0</span>], pMx = tmp2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    amn = min(amn, Mn + pMn), amx = max(amx, Mx + pMx); <span class="comment">// 计算距离最大 最小</span></span><br><span class="line">    <span class="keyword">if</span>(is[u]) sz[u]++, amn = min(amn, Mn), mn[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v, <span class="number">1</span>), add(v, u, <span class="number">1</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) a[i] = read(), is[ a[i] ] = <span class="literal">true</span>;</span><br><span class="line">        bd(), amn = INF, amx = ans = <span class="number">0</span>; <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="number">1</span>) ans = amn = amx = <span class="number">0</span>;</span><br><span class="line">        dp(rt, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, ans, amn, amx), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) is[ a[i] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol><li><a href="https://www.luogu.com.cn/problem/P2495">「SDOI2011」消耗战</a></li><li><a href="http://codeforces.com/problemset/problem/613/D">「CF613D」Kingdom and its Cities</a></li><li><a href="https://www.luogu.com.cn/problem/P4103">「HEOI2014」大工程</a></li></ol><p>习题<br><a href="https://www.luogu.com.cn/problem/P3233">「HNOI2014」世界树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，虚树是一类重构树，用于处理点数较多而关键点（有效点）数较少的树上问题。举个栗子，我们所熟知的后缀树就是一种虚树……&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI笔记" scheme="https://big-news.cn/categories/OI%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DP" scheme="https://big-news.cn/tags/DP/"/>
    
      <category term="树" scheme="https://big-news.cn/tags/%E6%A0%91/"/>
    
      <category term="虚树" scheme="https://big-news.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 669 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/09/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20669%20(Div.%202)/</id>
    <published>2020-09-09T03:51:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>蒟蒻下分场……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1407">比赛链接</a></p><h3 id="A-Ahahahahahahahaha"><a href="#A-Ahahahahahahahaha" class="headerlink" title="A. Ahahahahahahahaha"></a>A. Ahahahahahahahaha</h3><p>注意到 01 串一定有 $\ge n/2$ 个 0 或者 1，依此构造即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), c += (a[i] == <span class="number">0</span>);</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n &lt;&lt; <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c &gt;= n)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Big-Vova"><a href="#B-Big-Vova" class="headerlink" title="B. Big Vova"></a>B. Big Vova</h3><p>$O(n^2)$ 贪心即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) usd[i] = <span class="number">0</span>;</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(usd[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(mx == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span>(gcd(lst, a[mx]) &lt; gcd(lst, a[j])) mx = j;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[mx] = <span class="number">1</span>, b[i] = a[mx];</span><br><span class="line">    lst = gcd(lst, a[mx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Chocolate-Bunny"><a href="#C-Chocolate-Bunny" class="headerlink" title="C. Chocolate Bunny"></a>C. Chocolate Bunny</h3><p>连续询问 $x,y$ 和 $y, x$，得到 $a,b$，则有 $\max(a,b)=\min(p_x,p_y)$，依此模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>, lst, i); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    x = read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>, i, lst); fflush(<span class="built_in">stdout</span>); </span><br><span class="line">    y = read(), z = max(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y) a[i] = z ;</span><br><span class="line">    <span class="keyword">else</span> a[lst] = z, lst = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[ a[i] ]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vis[i]) &#123;a[lst] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;! &quot;</span>); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Discrete-Centrifugal-Jumps"><a href="#D-Discrete-Centrifugal-Jumps" class="headerlink" title="D. Discrete Centrifugal Jumps"></a>D. Discrete Centrifugal Jumps</h3><p>理性分析一下，边数看上去不是 $O(n^2)$ 的而是 $O(n)$ 的，那么可以线性地把图建出来，单调栈维护一下即可。<br>但是这个题并不需要最短路算法，注意到这是一个 DAG，因此直接 DP 计算即可，时间复杂度 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stk1[++top1] = <span class="number">1</span>, stk2[++top2] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] &lt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">        <span class="keyword">while</span>(top1 &amp;&amp; a[ stk1[top1] ] == a[ stk1[top1 - <span class="number">1</span>] ]) top1--;</span><br><span class="line">        <span class="keyword">if</span>(top1) top1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top1) f[i] = min(f[i], f[ stk1[top1] ]);</span><br><span class="line">    stk1[++top1] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] &gt; a[i])&#123;</span><br><span class="line">        f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">        <span class="keyword">while</span>(top2 &amp;&amp; a[ stk2[top2] ] == a[ stk2[top2 - <span class="number">1</span>] ]) top2--;</span><br><span class="line">        <span class="keyword">if</span>(top2) top2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top2) f[i] = min(f[i], f[ stk2[top2] ]);</span><br><span class="line">    stk2[++top2] = i;</span><br><span class="line"></span><br><span class="line">    f[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]);</span><br></pre></td></tr></table></figure><h3 id="E-Egor-in-the-Republic-of-Dagestan"><a href="#E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="E. Egor in the Republic of Dagestan"></a>E. Egor in the Republic of Dagestan</h3><p>算是比较裸的一道 E 题了……<br>设 $f[u,0/1]$ 表示在 $u$ 点，选 0 边还是选 1 边的答案，对于一条边 $u\gets v$，应当有 $f[u,c]\gets \max(f[v,0],f[v,1])+1$，其中 $c$ 代表边 $u\gets v$ 的颜色。<br>注意到一个点不会被松弛超过一次，直接跑 Dijkstra 转移即可，时间复杂度 $O((n+m)\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt,tp; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span> </span>&#123;to = t, nxt = n, tp = p;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DJ</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> v, id; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> DJ &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v &gt; a.v;&#125;&#125; ;</span><br><span class="line"><span class="function">DJ <span class="title">mk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;DJ d; d.v = a, d.id = b; <span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="keyword">int</span> d[CN][<span class="number">2</span>]; <span class="keyword">bool</span> vis[CN]; <span class="built_in">priority_queue</span>&lt;DJ&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SP</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d)), Q.push( mk(d[u][<span class="number">0</span>] = d[u][<span class="number">1</span>] = <span class="number">0</span>, u) );</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        u = Q.top().id, Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">int</span> dis = max(d[u][<span class="number">0</span>], d[u][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[k].to, c = E[k].tp, cur; <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[v][c] &gt; dis + <span class="number">1</span>)&#123;</span><br><span class="line">                d[v][c] = dis + <span class="number">1</span>, cur = max(d[v][<span class="number">0</span>], d[v][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(cur &lt; INF) Q.push( mk(cur, v) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="keyword">int</span> u = read(), v = read(), t = read(); add(v, u, t);&#125;</span><br><span class="line">    SP(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>]) &lt; INF) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, max(d[<span class="number">1</span>][<span class="number">0</span>], d[<span class="number">1</span>][<span class="number">1</span>])), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(d[i][<span class="number">0</span>] &gt; d[i][<span class="number">1</span>] ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒟蒻下分场……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 668 (Div. 2)</title>
    <link href="https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/"/>
    <id>https://big-news.cn/2020/09/07/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20668%20(Div.%202)/</id>
    <published>2020-09-07T02:12:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>两场 Div.2 爆肝上蓝系列……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1405">比赛链接</a></p><h3 id="A-Permutation-Forgery"><a href="#A-Permutation-Forgery" class="headerlink" title="A. Permutation Forgery"></a>A. Permutation Forgery</h3><p>这题是精心构造样例给选手降智啊….卡了我半小时 /kk<br>实际上反过来输出就好了啊…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[CN], n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="B-Array-Cancellation"><a href="#B-Array-Cancellation" class="headerlink" title="B. Array Cancellation"></a>B. Array Cancellation</h3><p>容易发现答案就是后缀和的最大值…证明显然啊，就算了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[CN];</span><br><span class="line">n = read(); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">int</span> ans = max(<span class="number">0ll</span>, a[n]); <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) a[i] += a[i + <span class="number">1</span>], ans = max(ans, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="C-Balanced-Bitstring"><a href="#C-Balanced-Bitstring" class="headerlink" title="C. Balanced Bitstring"></a>C. Balanced Bitstring</h3><p>容易发现模 $k$ 相同的位置， 字符应当是相同的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k; <span class="keyword">char</span> a[CN], s[CN];</span><br><span class="line">ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) s[i] = <span class="string">&#x27;?&#x27;</span>; <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i % k] == <span class="string">&#x27;?&#x27;</span>) s[i % k] = a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i % k] != a[i]) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    cnt1 += (s[i] == <span class="string">&#x27;1&#x27;</span>), cnt0 += (s[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(cnt0 &gt; (k / <span class="number">2</span>) || cnt1 &gt; (k / <span class="number">2</span>)) flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flag ? <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="D-Tree-Tag"><a href="#D-Tree-Tag" class="headerlink" title="D. Tree Tag"></a>D. Tree Tag</h3><p>容易发现初始位置看似是无用的，那么把树的直径找出来判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, a, b, da, db;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fs</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> to,nxt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span> </span>&#123;to = t, nxt = n;&#125; &#125; E[CN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[CN], ecnt = <span class="number">0</span>; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;E[++ecnt].init(y, hd[x]); hd[x] = ecnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) hd[i] = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[CN], dm;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinit</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) d[i] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) d[v] = d[u] + <span class="number">1</span>, dfs(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[CN][<span class="number">21</span>], dep[CN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) fa[j][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dep[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = p, dep[u] = dep[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt) &#123;<span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v ^ p) pc(v, u);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(dep[ fa[u][k] ] &gt;= dep[v]) u = fa[u][k];</span><br><span class="line">    <span class="keyword">if</span>(u ^ v) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">20</span>; k + <span class="number">1</span>; k--) <span class="keyword">if</span>(fa[u][k] ^ fa[v][k]) u = fa[u][k], v = fa[v][k]; u = fa[u][<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[lca(u, v)];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; T = read(); <span class="keyword">while</span>(T--)&#123; </span><br><span class="line">    hinit(), ecnt = <span class="number">0</span>;</span><br><span class="line">    n = read(), a = read(), b = read(), da = read(), db = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="keyword">int</span> u = read(), v = read(); add(u, v), add(v, u);&#125;</span><br><span class="line"></span><br><span class="line">    finit(), pc(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][k] = fa[ fa[i][k - <span class="number">1</span>] ][k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dis(a, b) &lt;= da) &#123;<span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> mx = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = mx &lt; d[i] ? p = i, mx = d[i] : mx;</span><br><span class="line"></span><br><span class="line">    dinit(), dfs(p, <span class="number">0</span>), dm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dm = max(dm, d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * da &gt;= dm) <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(db &gt;= <span class="number">2</span> * da + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Fixed-Point-Removal"><a href="#E-Fixed-Point-Removal" class="headerlink" title="E. Fixed Point Removal"></a>E. Fixed Point Removal</h3><p>容易发现一个点能否被消除仅与询问的左边界 $l$ 有关，设 $p_i$ 为可以令 $a_i$ 消除的最大的 $l$，则答案是 $\sum\limits_{i=l}^r[p_i\ge l]$，这是一个愉快的二维数点。<br>考虑 $p_i$ 如何求出，容易观察到如下性质：</p><ol><li>若  $a_i &gt; i$，则可以定义 $p_i = 0$；</li><li>若 $a_i = i$，显然 $p_i=i$； </li><li>若 $a_i &lt; i$，则 $p_i=\max m, \text{s.t.} \left( \sum\limits_{j=m}^{i-1}[p_j\ge m]\right) \ge i - a_i$</li></ol><p>前两条都好处理，最后一条二分即可，套一个静态主席树解决二维数点，时间复杂度 $O(n\log^2 n+q\log n)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">int</span> d[CN * <span class="number">50</span>], ch[CN * <span class="number">50</span>][<span class="number">2</span>], rt[CN], idx; SGT()&#123;idx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc ch[u][0]</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc ch[u][1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">md</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = ++idx;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(d[u] = d[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) rc = ch[v][<span class="number">1</span>], md(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> lc = ch[v][<span class="number">0</span>], md(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">        d[u] = d[lc] + d[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qu</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> d[u] - d[v];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> d[rc] - d[ch[v][<span class="number">1</span>]] + qu(lc, ch[v][<span class="number">0</span>], l, m, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> qu(rc, ch[v][<span class="number">1</span>], m + <span class="number">1</span>, r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, p[CN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ai = read();</span><br><span class="line">        <span class="keyword">if</span>(ai &gt; i) p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ai == i) p[i] = i;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>, m, minus = i - ai;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = D.qu(D.rt[i - <span class="number">1</span>], D.rt[m - <span class="number">1</span>], <span class="number">0</span>, n, m);</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= minus) l = m;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        D.md(D.rt[i], D.rt[i - <span class="number">1</span>], <span class="number">0</span>, n, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read(); l++, r = n - r;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, D.qu(D.rt[r], D.rt[l - <span class="number">1</span>], <span class="number">0</span>, n, l)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两场 Div.2 爆肝上蓝系列……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>「解题报告」Codeforces Round 667 (Div. 3)</title>
    <link href="https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/"/>
    <id>https://big-news.cn/2020/09/05/%E3%80%8C%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%8DCodeforces%20Round%20667%20(Div.%203)/</id>
    <published>2020-09-05T06:43:00.000Z</published>
    <updated>2020-12-27T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\oi-blog\assets\css\APlayer.min.css"><script src="\oi-blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\oi-blog\assets\js\Meting.min.js"></script><p>最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……</p><a id="more"></a><p><a href="https://codeforces.com/contest/1409">比赛链接</a></p><h3 id="A-Yet-Another-Two-Integers-Problem"><a href="#A-Yet-Another-Two-Integers-Problem" class="headerlink" title="A. Yet Another Two Integers Problem"></a>A. Yet Another Two Integers Problem</h3><p>签到傻题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t, a, b;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(); <span class="keyword">int</span> k = <span class="built_in">abs</span>(a - b), b = k / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(b * <span class="number">10</span> == k) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b + <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Minimum-Product"><a href="#B-Minimum-Product" class="headerlink" title="B. Minimum Product"></a>B. Minimum Product</h3><p>设 $a$ 变成了 $a-c$，$b$ 变成了 $b-d$，则减少的部分是 $-cb-ad+cd$，代入 $c+d=n$ 可以推出这是一个关于 $c$ 的二次函数，且开口向下，那么容易知道 $c$ 只有两种取值 $\max(0,y-b+n)$ 或 $a-x$，代入检验即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, x, y, n;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    a = read(), b = read(), x = read(), y = read(), n = read();</span><br><span class="line">    <span class="keyword">int</span> ans = INF, c, d;</span><br><span class="line">    <span class="keyword">if</span>(a + b - x - y &lt;= n) ans = x * y;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c = min(n, a - x), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">        c = min(n, max(<span class="number">0ll</span>, y - b + n)), d = min(b - y, n - c);</span><br><span class="line">        ans = min(ans, (a - c) * (b - d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Yet-Another-Array-Restoration"><a href="#C-Yet-Another-Array-Restoration" class="headerlink" title="C. Yet Another Array Restoration"></a>C. Yet Another Array Restoration</h3><p>傻题，模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, y, d, a[CN], ans[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mx = max(mx, a[i]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    n = read(), x = read(), y = read(); <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(d = <span class="number">1</span>; d &lt;= y; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((y - x) % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (y - x) / d + <span class="number">1</span>, u = x; <span class="keyword">if</span>(l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) a[i] = u, u += d;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n - l; u = x - d;</span><br><span class="line">            <span class="keyword">while</span>(u &gt; <span class="number">0</span> &amp;&amp; sum) sum--, a[++l] = u, u -= d;</span><br><span class="line">            u = y + d;</span><br><span class="line">            <span class="keyword">while</span>(sum) sum--, a[++l] = u, u += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = mx(a); <span class="keyword">if</span>(cur &lt; y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; mn) mn = cur, <span class="built_in">memcpy</span>(ans, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Decrease-the-Sum-of-Digits"><a href="#D-Decrease-the-Sum-of-Digits" class="headerlink" title="D. Decrease the Sum of Digits"></a>D. Decrease the Sum of Digits</h3><p>容易发现代价是固定的，那么模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> t, n, s, bit[<span class="number">101</span>], p10[<span class="number">101</span>], cur;</span><br><span class="line">p10[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) p10[i] = p10[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    cur = <span class="number">0</span>, n = read(), s = read();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) bit[++lg] = n % <span class="number">10</span>, n /= <span class="number">10</span>, cur += bit[lg];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg &amp;&amp; cur &gt; s; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ans += (<span class="number">10</span> - bit[i]) * p10[i - <span class="number">1</span>];</span><br><span class="line">        bit[i + <span class="number">1</span>]++, cur -= bit[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>, ans), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Two-Platforms"><a href="#E-Two-Platforms" class="headerlink" title="E. Two Platforms"></a>E. Two Platforms</h3><p>离散化坐标，考虑对于每个坐标 $i$ ，求出 $[1,i]$ 和 $(i,n]$ 的答案，加起来更新答案即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, d, X[CN], val[CN], pre[CN], suf[CN], sum[CN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>, x) - val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    t = read(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    </span><br><span class="line">    n = read(), d = read(), val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) X[i] = read(), val[ ++val[<span class="number">0</span>] ] = X[i], val[ ++val[<span class="number">0</span>] ] = X[i] + d, val[ ++val[<span class="number">0</span>] ] = X[i] - d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read();</span><br><span class="line"></span><br><span class="line">    sort(val + <span class="number">1</span>, val + val[<span class="number">0</span>] + <span class="number">1</span>); <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= val[<span class="number">0</span>]; i++) <span class="keyword">if</span>(val[i] ^ val[i - <span class="number">1</span>]) val[++cnt] = val[i];</span><br><span class="line">    val[<span class="number">0</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= val[<span class="number">0</span>] + <span class="number">100</span>; i++) pre[i] = suf[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[ id(X[i]) ]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = id(X[i]), l = id(X[i] - d), r = id(X[i] + d);</span><br><span class="line">        pre[p] = sum[p] - sum[l - <span class="number">1</span>], suf[p] = sum[r] - sum[p - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) pre[i] = max(pre[i], pre[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = val[<span class="number">0</span>]; i; i--) suf[i] = max(suf[i], suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= val[<span class="number">0</span>]; i++) ans = max(ans, pre[i] + suf[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Subsequences-of-Length-Two"><a href="#F-Subsequences-of-Length-Two" class="headerlink" title="F. Subsequences of Length Two"></a>F. Subsequences of Length Two</h3><p>显然要 DP，设 $f[i,j,k]$ 表示考虑 $s[1:i]$ 中，$t[1]$ 出现了 $j$ 次，当前改动了 $k$ 次的方案数，就可以转移了。</p><p>具体来讲，考虑 $i\to i+1$，我们有两种选择：</p><ol><li>什么都不做，转移到 $f[i+1,c+0/1,k]$；</li><li>把这一位改成 $t_1$，转移到 $f[i+1,c+1,k+1]$</li><li>把这一位改成 $t_2$，转移到 $f[i+1,c,k+1]+c$</li></ol><p>最后特殊考虑一下 $t[1]=t[2]$ 的情况即可，时间复杂度 $O(n^3)$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CN = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,ne = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ne = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d, f[CN][CN][CN], ans; <span class="keyword">char</span> s[CN], c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        c += (s[i] == c1); <span class="keyword">if</span>(s[i] == c2) f[i][c][<span class="number">0</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c2) f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c2) f[i + <span class="number">1</span>][c][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][c + (s[i] == c1)][<span class="number">0</span>] = f[i - <span class="number">1</span>][c][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c1) c++, f[i][c][<span class="number">0</span>] += c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; c++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] == c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k], f[i][c][k] + c);</span><br><span class="line">          <span class="keyword">else</span> f[i + <span class="number">1</span>][c][k] = max(f[i + <span class="number">1</span>][c][k], f[i][c][k]);</span><br><span class="line">          <span class="keyword">if</span>(s[i + <span class="number">1</span>] != c1) f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>] = max(f[i + <span class="number">1</span>][c + <span class="number">1</span>][k + <span class="number">1</span>], f[i][c][k] + c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;_in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    n = read(), d = read(), <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(c1 != c2) DP1(); <span class="keyword">else</span> DP2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n; x++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= d; k++)</span><br><span class="line">            ans = max(ans, f[n][x][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CF 的 Div2.3 有一点点水啊，虽然说蒟蒻还是上不了分……&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://big-news.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
</feed>
