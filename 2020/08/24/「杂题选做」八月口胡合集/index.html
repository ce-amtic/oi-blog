<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「杂题选做」八月口胡合集 - bn&#039;s Blog</title><link rel="manifest" href="/oi-blog/manifest.json"><meta name="application-name" content="bn&#039;s Blog"><meta name="msapplication-TileImage" content="img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="bn&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="众所周知，做题的关键在于口胡出解法，而我还是什么都不会……"><meta property="og:type" content="blog"><meta property="og:title" content="「杂题选做」八月口胡合集"><meta property="og:url" content="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"><meta property="og:site_name" content="bn&#039;s Blog"><meta property="og:description" content="众所周知，做题的关键在于口胡出解法，而我还是什么都不会……"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://big-news.cn/oi-blog/img/og_image.png"><meta property="article:published_time" content="2020-08-24T10:06:00.000Z"><meta property="article:modified_time" content="2021-01-22T13:14:03.000Z"><meta property="article:author" content="ce-amtic"><meta property="article:tag" content="瞎搞"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/oi-blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"},"headline":"bn's Blog","image":["https://big-news.cn/oi-blog/img/og_image.png"],"datePublished":"2020-08-24T10:06:00.000Z","dateModified":"2021-01-22T13:14:03.000Z","author":{"@type":"Person","name":"ce-amtic"},"description":"众所周知，做题的关键在于口胡出解法，而我还是什么都不会……"}</script><link rel="canonical" href="https://big-news.cn/2020/08/24/%E3%80%8C%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%E3%80%8D%E5%85%AB%E6%9C%88%E5%8F%A3%E8%83%A1%E5%90%88%E9%9B%86/"><link rel="alternate" href="/oi-blog/oi-blog/atom.xml" title="bn&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/oi-blog/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/oi-blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?d2bd007ca786af68050dc4eaf58eecdc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/oi-blog/"><img src="/oi-blog/img/logo.png" alt="bn&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/oi-blog/">首页</a><a class="navbar-item" href="/oi-blog/archives">归档</a><a class="navbar-item" href="/oi-blog/tags">标签</a><a class="navbar-item" href="/oi-blog/categories">分类</a><a class="navbar-item" href="/oi-blog/friends.html">友链</a><a class="navbar-item" href="/oi-blog/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Fork Me On GitHub" href="https://github.com/ce-amtic/ce-amtic.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-24T10:06:00.000Z" title="8/24/2020, 6:06:00 PM">2020-08-24</time>发表</span><span class="level-item"><time dateTime="2021-01-22T13:14:03.000Z" title="1/22/2021, 9:14:03 PM">2021-01-22</time>更新</span><span class="level-item"><a class="link-muted" href="/oi-blog/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="level-item">32 分钟读完 (大约4871个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">「杂题选做」八月口胡合集</h1><div class="content"><p>众所周知，做题的关键在于口胡出解法，而我还是什么都不会……</p>
<a id="more"></a>

<p>本篇 Blog 多以口胡为主，杂题居多。</p>
<h3 id="1-Hunger-Game"><a href="#1-Hunger-Game" class="headerlink" title="1 Hunger Game"></a>1 Hunger Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有 $N$ 个箱子，每个箱子有 $a[i]$ 个石头，一开始所有箱子都是关着的。<br>Alice 和 Bob 轮流操作，每次可以至少打开一个被关闭的箱子，或者选择一个已经开着的箱子拿走里面至少一个石头。<br>不能操作的输，求先手必胜还是后手必胜。<br>$1\le N\le 1e5, 0\le a[i]&lt;10^9$</p>
</div></article>

<p>Nim 博弈的经典结论：对于每个状态有 $SG_i=a_i$ ，则终态是 P 态的充要条件是 $a_1\oplus a_2\oplus … \oplus a_n = 0$。</p>
<p>回到本题，如果存在一个 $a_1,a_2,…a_n$ 的子集使其异或和为 0，先手选择一个极大的这样的子集打开，则丢给后手了一个 P 态；此时后手一定要考虑去开新的箱子，但是不存在新的子集使其异或和为 0 了，因此后手并不能挽回局面，故此时为 N 态。<br>如果不存在呢？那么无论先手怎么开箱子，得到的都一定是 N 态，故此时为 P 态。</p>
<p>因此结论：先手必胜当且仅当存在一个子集使之异或和为 0。<br>大力枚举 $O(2^n)$ ，可通过线性基降成 $O(n)$ 。</p>
<h3 id="2-Minimum-Value-of-Equation"><a href="#2-Minimum-Value-of-Equation" class="headerlink" title="2 Minimum Value of Equation"></a>2 Minimum Value of Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定 $k[i],b[i]$，有 $n$ 个函数，第 $j$ 个函数为 $f_j(x)=\sum |k[i]x+b[i]|$，其中$1\le i\le j$。<br>对于每个 $j=1…n$，求出 $f_j(x)$ 的最小值。<br>$1\le n\le 10^5 , |k[i]|\le 1000$</p>
</div></article>

<p>提一下公因式变成 $\sum k_i|x+(b_i/k_i)|$ ，即 $x$ 到数轴上的一堆点 $b_i/k_i$ 的距离和，那么 $x$ 取这些点的中位数就好了。</p>
<h3 id="3-DFS-Count"><a href="#3-DFS-Count" class="headerlink" title="3 DFS Count"></a>3 DFS Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定一个 $n$ 个点的有向图，求合法的 DFS 序的个数。<br>$n \le 13$</p>
</div></article>

<p>直接搜？？？（雾<br>设 $f[u,S]$ 表示当前在 $u$ ，没走过的点集为 $S$ 的方案数。$|S|$ 是递减的，可通过其来划分子问题，得到转移：<br>$$ f[v,T_v \And S]·f[u,S-(T_v \And S)] \to f[u, S] | (u,v)\in E$$<br>其中 $T_v$ 是 $v$ 能到达的点集。容易发现这次从小集合往大集合转移，则其是可操作的。</p>
<h3 id="4-XOR-Product"><a href="#4-XOR-Product" class="headerlink" title="4 XOR Product"></a>4 XOR Product</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定序列 $a_1,…,a_n$ ，求：<br>$$ \sum\limits_{i&lt;j&lt;k}(a_i\oplus a_j)·(a_j \oplus a_k) $$</p>
</div></article>

<p>把 $j$ 提出来，拆一下柿子：<br>$$ \sum\limits_j(\sum\limits_{i&lt;j}a_i\oplus a_j)(\sum\limits_{j&lt;k}a_j \oplus a_k) $$<br>考虑求 $\sum\limits_{i&lt;j}a_i\oplus a_j$ ，把每一位拆开算贡献，则应当统计 $a_1,…,a_{j-1}$ 中这一位上有多少个 1 ，预处理即可。<br>预处理是 $O(n\log)$ 的，枚举 $j$ 处理前后两个 sigma 是 $O(n\log)$ 的，最后统计答案也是 $O(n)$ 的。</p>
<h3 id="5-SUMXOR"><a href="#5-SUMXOR" class="headerlink" title="5 SUMXOR"></a>5 SUMXOR</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定序列 $a[1…n]$ 和 $b[1…n]$ ，求：<br>$$ \bigoplus\limits_{i,j}a_i+b_j $$</p>
</div></article>

<p>依然拆开每一位算，考虑第 $w$ 位的贡献应当是 $2^w\sum[(a_i+b_j)\text{ mod } 2^{w+1} \ge 2^w] \text{ mod }2$。<br>令 $a_i\gets a_i\text{ mod }2^{w+1},b_i\gets b_i\text{ mod }2^{w+1} $，有两种情况：</p>
<ol>
<li>$a_i + b_j \ge 2^{w+1}$，则应当有 $a_i+b_j-2^{w+1}\ge 2^w$，移项得 $a_i+b_j\ge 2^w+2^{w+1}$</li>
<li>$a_i+b_j&lt; 2^{w+1}$，则应当有 $2^w\le a_i+b_j&lt; 2^{w+1}$</li>
</ol>
<p>于是转化成序列上的查询问题，Two-Pointers 扫即可。</p>
<h3 id="6-The-Hanged-Man"><a href="#6-The-Hanged-Man" class="headerlink" title="6 The Hanged Man"></a>6 The Hanged Man</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有一个 $n$ 个点的树，每个点有一个体积 $v[i]$ 和收益 $w[i]$，现在你能选一个独立集，对于每个 $i$ 输出体积和为 $i$ 的收益和最大的独立集的值。<br>$n\le 50, m\le 5000$</p>
</div></article>

<p>$O(nm^2)$ 的 DP 显然啊，但是重链剖分 DP 看不懂啊，这个先咕着。</p>
<p>资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dqsssss/p/11534336.html">乱搞</a>，<a target="_blank" rel="noopener" href="https://blog.aor.sd.cn/archives/1122/">重链剖分</a></p>
<p>附一个 $O(nm^2)$ 的 DP：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, vi[CN], wi[CN], f[CN][<span class="number">5005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to;</span><br><span class="line">        <span class="keyword">if</span>(v ^ p) dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][ vi[u] ][<span class="number">1</span>] = wi[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = hd[u]; k; k = E[k].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].to; <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> V = m; V; V--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> Vp = <span class="number">0</span>; Vp &lt;= V; Vp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(V - Vp &gt;= vi[u]) f[u][V][<span class="number">1</span>] = max(f[u][V][<span class="number">1</span>], f[v][Vp][<span class="number">0</span>] + f[u][V - Vp][<span class="number">1</span>]);</span><br><span class="line">                f[u][V][<span class="number">0</span>] = max(f[u][V][<span class="number">0</span>], max(f[v][Vp][<span class="number">0</span>], f[v][Vp][<span class="number">1</span>]) + f[u][V - Vp][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-Anton-and-Ira"><a href="#7-Anton-and-Ira" class="headerlink" title="7 Anton and Ira"></a>7 Anton and Ira</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定两个排列 $s$ 和 $p$ ，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$ ，输出方案。<br>$n\le 1000$</p>
</div></article>

<p>设 $to[u]$ 是 $u$ 想要去到的位置，可以将其看作一条有向边。根据抽屉原理，某一时刻必然存在一个点使 $to[u]$ 与 $to[to[u]]$ 反向，于是贪心就好了。<br>设这样得到的答案为 $s$，容易发现对于一种操作方案，必然存在另一种与之互为补集的操作方案，其答案也为 $s$。两者可以组成全集，即有 $2s=\sum|i-to[i]|$，从而 $s=\sum|i-to[i]|/2$。</p>
<h3 id="8-Increasing-Shortest-Path"><a href="#8-Increasing-Shortest-Path" class="headerlink" title="8 Increasing Shortest Path"></a>8 Increasing Shortest Path</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有个 $n$ 个点 $m$ 条边的有向图，有 $q$ 个询问：从 $ai$ 到 $bi$，边权递增，经过不超过 $ci$ 条边，权值和最小是多少？<br>$T$组数据（$T\le 100$）。<br>$n ≤ 150, m, q ≤ 5000.$</p>
</div></article>

<p>$n$ 比较小，那么考虑 DP。<br>边权看上去没办法放进状态里面，有一个技巧是把边升序排序，然后按照边来转移状态，即可满足要求。</p>
<p>设 $f[u,v,m]$ 表示 $u\to v$ 经过不超过 $m$ 条边的答案，$O(n)$ 固定起点 $s$，$O(m)$ 枚举一条边 $(u,v,w)$，则有转移：<br>$$ f[s,u,k]+w\to f[s,v,k+1] $$<br>这样看上去是 $O(nm^2)$ 的，但是考虑到限制是“至多经过”，而要求最小路径，则一个环不应在路径中出现，即一个点不会被访问超过一次。考虑到一个点之多有一条出边被选中，因此状态第三维的数量实际上是 $O(n)$ 的。对于 $ci&gt; n$ 的询问，其答案一定等于 $ci=n$ 的询问。</p>
<p>复杂度 $O(T(m\log m+n^2m+q))$，瓶颈在于 $O(Tn^2m)$；考虑到时限是 60s， 因此可以通过。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort(G + <span class="number">1</span>, G + m + <span class="number">1</span>), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][i][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; s++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = G[i].u, v = G[i].v, w = G[i].w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                f[s][v][k + <span class="number">1</span>] = min(f[s][u][k] + w, f[s][v][k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-Increasing-Number"><a href="#9-Increasing-Number" class="headerlink" title="9 Increasing Number"></a>9 Increasing Number</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>一个数是Increasing当且仅当它的十进制表示是不降的，求 $n$ 位不降十进制数中被 $m$ 整除的有多少个。<br>$n ≤ 10^{18}, m ≤ 500.$</p>
</div></article>

<p>显然有状态 $f[n,p,k]$ 表示考虑第 $n$ 位数字，当前位填 $p$，模 $m$ 等于 $k$ 的方案数，转移可以枚举当前位数字和上一位数字，有关系 $f[n,p,(p\times 10^n+k)\text{ mod }m]\gets f[n-1,p’,k]$，复杂度 $O(100nm)$，不太可行。<br>对于这种转移关系比较固定的 DP，可以考虑矩乘加速，但是这是 $O((10m)^3\log n)$ 的，看上去也不太行。</p>
<p>一个重要的性质：一个合法数字必然是至多 9 个仅由 1 组成的数的和。<br>则可以按 $111…111$ 模 $m$ 的值将其分类，这样有 $m$ 类，然后对类做 DP 即可。<br>这也令我们可以得出一个结论：位数小于 $n$ 的不降数的总个数是 $\sum\limits_{i=1}^9\dbinom{i+n-1}{n-1}=\dbinom{n+9}{n}-1$。</p>
<h3 id="10-Little-Elephant-and-Colored-Coins"><a href="#10-Little-Elephant-and-Colored-Coins" class="headerlink" title="10 Little Elephant and Colored Coins"></a>10 Little Elephant and Colored Coins</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>给定 $n$ 个物品，每个物品可以取无限次，每个物品有两种属性：价值 $v$ 和颜色 $c$。<br>现在有 $q$ 个询问，询问最多能用多少种颜色组成 $S$。<br>$n ≤ 30, v_i ≤ 2\times 10^5,s\le 10^{18}$</p>
</div></article>

<p>对于这种题目，一般来说技巧是取 $w=\min v_i$ ，把问题转化到模 $w$ 的剩余系下做。这样做的正确性在于：$\mathbb{F}_P$ 中的所有数与 $P$ 的倍数组合能够填满整个整数域。<br>然后可以设状态 $f[u,k]$ 或 $f[k]$ 表示模 $w$ 为 $k$ 的答案，对于物品的价值 $v$ 可以抽象成一条边的边权，然后套用最短路模型，于是做到 $O(w\log w)$ 转移状态。</p>
<p>对于本题，考虑到硬币种类可能在统计过程中重复，因此设 $f[i,k]$ 表示选至少 $i$ 种，模 $w$ 为 $k$ 的路径的最小长度；用最短路模型来转移看上去也不太行，考虑换成背包模型，即有 $f[i,k]\gets f[i+1,(k+v_i)\text{ mod }w]$，然后按 $i$ 分组 DP 更新即可，复杂度 $O(n^2w)$。</p>
<p>给出大致的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read(), w = w ? min(w, v[i]) : v[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j + <span class="number">1</span>; j--) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[j + <span class="number">1</span>][(k + v[i]) % w] = min(f[j][k] + v[i], f[j + <span class="number">1</span>][(k + v[i]) % w]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w; k++)</span><br><span class="line">            f[i][(k + v[j]) % w] = min(f[i][k] + v[j], f[i][(k + v[j]) % w]);</span><br><span class="line">    </span><br><span class="line">q = read();</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="keyword">int</span> s = read(), sw = s % w;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &amp;&amp; !flag; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[i][sw] &lt; INF &amp;&amp; f[i][sw] &lt;= s) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-Balance"><a href="#11-Balance" class="headerlink" title="11 Balance"></a>11 Balance</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>一个杠杆，半长为 $n$，$2n+1$ 个整数坐标各有一个质量相同的砝码，取走 $k$ 个，问最终杠杆仍然平衡的方案数。<br>$n\le 10^4, k\le 10$</p>
</div></article>

<p>整数划分问题。<br>容易发现两边是完全对称的，那么只需要考虑一边。考虑枚举取的数字和是多少，设 $f[i,k]$ 表示把数字 $i$ 拆分成 $k$ 个小于 $n$ 的不同数字的方案数，有转移：<br>$$ \begin{aligned}f[i,k]&amp;=f[i-k,k]+f[i-k,k-1]\newline f[i,k]&amp;=f[i,k]-f[i-n-1,k-1] \text{ }\text{ }| \text{ }\text{ }i\ge n + 1 \end{aligned}$$<br>复杂度 $O(nk^2)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - K + <span class="number">1</span>; i &lt;= n; i++) N += i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        f[i][k] = i &gt;= k ? (f[i - k][k] + f[i - k][k - <span class="number">1</span>]) % p : <span class="number">0</span>,</span><br><span class="line">        f[i][k] = i &gt; n ? (f[i][k] - f[i - n - <span class="number">1</span>][k - <span class="number">1</span>] + p) % p : f[i][k];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; j++) ans = (<span class="number">1ll</span> * f[w][j] * f[w][K - j] % p + ans) % p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= N; w++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K - <span class="number">1</span>; j++) ans = (<span class="number">1ll</span> * f[w][j] * f[w][K - j - <span class="number">1</span>] % p + ans) % p;</span><br></pre></td></tr></table></figure>
<h3 id="12-Arrangement-Count"><a href="#12-Arrangement-Count" class="headerlink" title="12 Arrangement Count"></a>12 Arrangement Count</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>求有多少个排列 $A\subseteq [n]$，使得 $A$ 中每个位置与相邻位置的数的差不为 1。<br>$n\le 1000$</p>
</div></article>

<p>设 $f[i,j,0/1]$ 表示考虑 $A\subseteq [i]$，有 $j$ 对相邻位置相差为 1 ，$i$ 是否与 $i+1$ 相邻的方案数，有转移：</p>
<ol>
<li>$f[i,j,0]·j\to f[i+1,j-1,0]$</li>
<li>$f[i,j,0]·2\to f[i+1, j + 1, 1], f[i,j,1]·2\to f[i+1, j, 1]$</li>
<li>$f[i,j,0/1]·(i-j-1)\to f[i+1,j,0]$</li>
</ol>
<p>复杂度 $O(n^2)$。</p>
<h3 id="13-Cut-Tree"><a href="#13-Cut-Tree" class="headerlink" title="13 Cut Tree"></a>13 Cut Tree</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>$n$ 个节点的树，点有点权，要切两条边和加一个点使得形成的三个子树点权和相等，最小化新加节点点权的绝对值。<br>$n \le 10^5$</p>
</div></article>

<p>考虑固定一整棵树的根，对所有 $n$ 棵子树的大小统计其出现次数 $cnt[]$。不妨设当前的根处需要割断一条边，那么枚举其的枚举一个子树 $v$，设其大小为 $sz[v]$ ，则当 $cnt[sz[v]]&gt;1$ 时，可将整棵树切成三个部分：两个 $sz[v]$ 和一个 $n-sz[v]$ ，于是可以更新答案。</p>
<p>但是当前根处不一定会割断边，那么考虑换根。容易发现当根向某个儿子移动时，至多有两个节点的 $sz[]$ 值会发生变化，则简单维护即可。</p>
<p>于是可以做到不漏算答案，时间复杂度 $O(n)$。</p>
<h3 id="14-Number-Game"><a href="#14-Number-Game" class="headerlink" title="14 Number Game"></a>14 Number Game</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>Alice 和 Bob 又双叒叕在玩游戏。<br>Bob 每次会想一个 $0\text{~}n$ 的数，Alice 每次猜 $k$，Bob 告诉 Alice 大了还是小了。Alice 猜 $k$ 会付出 $a_k$ 的代价，Alice 要最小化代价，Bob 要最大化代价（并在不违反前面询问的情况下改数）。假设二人都绝顶聪明，求 Alice 最后付出多少代价。<br>$n \le 10^5, a_i\le 9$</p>
</div></article>

<p>本人只会 $O(n^3)$ 的辣鸡 DP……</p>
<p>设 $f[l,r]$ 为考虑区间 $[l,r]$ 的答案，应当有转移：<br>$$ f[l,r]=\min\limits_k a_k+ \max(f[l,k-1],f[k+1,r]) $$ 边界是 $f[i,i]=a_i$，直接大力 DP 即可做到 $O(n^3)$。</p>
<h3 id="15-Distributs"><a href="#15-Distributs" class="headerlink" title="15 Distributs"></a>15 Distributs</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>小 A 带来了 $m$ 种特产，第 $i$ 种特产的数量为 $a_i$。小 A 要把它们全部分给 $n$ 个同学，要求每个同学至少拿到一个特产，问有多少种分法，对 $10^9+7$ 取模。<br>$n,m \le 1000$</p>
</div></article>

<p>容斥简单题，钦点 $k$ 个人一定分不到，剩下的随便分，在总方案数中减去就好了，则答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\sum\limits_j \dbinom{a_j+n-k-1}{n-k-1}$$ 复杂度 $O(n^2)$。</p>
<h3 id="16-Solutions-of-the-Equation"><a href="#16-Solutions-of-the-Equation" class="headerlink" title="16 Solutions of the Equation"></a>16 Solutions of the Equation</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有 $n$ 个变量 $x_1…x_n$，每个变量 $0&lt;x\le R$，给定 $S$，求方程 $x_1+x_2+…+x_n=S$有多少组正整数解。<br>$n \le 1000$</p>
</div></article>

<p>容斥简单题，如果不考虑限制答案是 $\dbinom{S-1}{n-1}$，然后钦点有 $k$ 个变量不合法然后去加加减减，答案是：<br>$$ \sum\limits_{k=0}^n (-1)^k \dbinom{n}{k}\dbinom{S-kR-1}{n-1} $$ 复杂度 $O(n^2)$。</p>
<h3 id="17-Bohater"><a href="#17-Bohater" class="headerlink" title="17 Bohater"></a>17 Bohater</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>在一款电脑游戏中，你需要打败$n$只怪物（从 $1$ 到 $n$ 编号），初始生命值为 $z$。<br>为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。<br>任何时候你的生命值都不能降到 0（或 0 以下）。请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。如果存在请输出方案，不存在输出NO。<br>$1≤n,z≤10^5，0≤d_i,a_i≤10^5$</p>
</div></article>

<p>考虑把怪分成两类，先打加血怪，再打减血怪；考虑打加血怪的过程：应当按 $d_i$ 升序去打。<br>减血怪呢？考虑打怪的反过程：不打一个怪，血量增加 $d_i$ 而减少 $a_i$。<br>则反过程应当按 $a_i$ 升序排，正过来就是按 $a_i$ 降序排。</p>
<p>复杂度 $O(n\log n)$。</p>
<h3 id="18-Swap-Space"><a href="#18-Swap-Space" class="headerlink" title="18 Swap Space"></a>18 Swap Space</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量从 $a_i$ 变成 $b_i$。<br>为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。<br>你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上，数据可以分割。<br>格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。<br>求最小的额外储存设备容量。<br>$1≤n≤10^6,1≤a_i,b_i≤10^9$</p>
</div></article>

<p>考虑二分最终的答案 $M$ ，表示一开始购买的硬盘大小，则模型变为：</p>
<ul>
<li>给定一些元素 $(a,b)$ ，选择某个元素会付出代价 $a$ 得到收益 $b$ ，求能否选择所有元素。</li>
</ul>
<p>这就是上题模型，复杂度 $O(n\log^2n)$，看上去有点卡。</p>
<p>实际上二分大可不必，依然按照上题的思路去做，当代价和多于当前的承受限度时，把多出来的那一部分加到答案里即可，复杂度 $O(n\log n)$。</p>
<h3 id="19-Maximum-Value-of-Linear-Function"><a href="#19-Maximum-Value-of-Linear-Function" class="headerlink" title="19 Maximum Value of Linear Function"></a>19 Maximum Value of Linear Function</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>现在有 $n$ 个一次函数，$f_i(x)=a_ix+b_i$。给定 $x$，并且对于所有的 $f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。<br>$n\le 10^6$</p>
</div></article>

<p>容易发现 $x$ 的系数一定，那么只需要考虑常数项最大。<br>考虑交换，对二元组 $(a_1,b_1)$ 和 $(a_2,b_2)$ ，前者放在外层当且仅当 $a_1(a_2x+b_2)+b_1&gt;a_2(a_1x+b_1)+b_2$，移项得 $(a_1-1)/b_1&gt;(a_2-1)/b_2$，则按照 $(a_i-1)/b_i$ 降序排序，把靠前的放在外层即可。</p>
<p>这个题也可以类比一下<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1080">「国王游戏」</a>那道题。考虑何时应该交换相邻的两个元素 $i,j$：当且仅当 $\Pi/b_i+(a_i·\Pi)/b_j &gt; \Pi/b_j+(a_j·\Pi)/b_i$，化简得 $(a_j-1)·b_j&lt;(a_i-1)·b_i$，因此按 $(a_i-1)·b_i$ 为关键字排序即可。</p>
<h3 id="20-Kuglarz"><a href="#20-Kuglarz" class="headerlink" title="20 Kuglarz"></a>20 Kuglarz</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>$n$ 个杯子排成一排，每个杯子中可能放有也可能没有一个小球。你每次可以花费 $C(i,j)$ 的代价得知区间 $[i,j]$ 的杯子中球的总数的奇偶性。<br>问最少花费多少代价才能求出每个杯子中是否有小球。<br>$n\le 1000$</p>
</div></article>

<p>看上去很像 DP，但我的做法假掉了……<br>建一张图，边 $(u,v)$ 的边权为 $C(u,v)$，则问题等价于求出图上的最小生成树。<br>时间复杂度 $O(n^2)$。</p>
<h3 id="21-OSU"><a href="#21-OSU" class="headerlink" title="21 OSU!"></a>21 OSU!</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>一个长度为 $n$ 的 01 串按以下方式生成：第 $i$ 个位置有 $a_i$ 的概率为 1，$1-a_i$ 的概率为 0。01 串的价值如下计算：每一个极长全 1 子串的长度的三次方之和。<br>求该 01 串的价值的期望。<br>$n\le 10^5$</p>
</div></article>

<p>考察期望的定义，和应用用贡献法计算每一位的价值期望。<br>设 $l_1[i]$ 表示末尾一段极长全 1 子串长度的期望， $l_2[i]$ 表示末尾一段极长全 1 子串长度的平方的期望，设 $f[i]$ 为长度为 $i$ 的 01 串价值的期望，考虑到有 $(x+1)^3-x^3=3x^2+3x+1$，则有：<br>$$ f[i]=f[i-1]+a_i(3l_2[i-1]+3l_1[i-1]+1) $$ 即对最后加入的位置 $i$ 讨论了一下它对答案的贡献。同理有：<br>$$ \begin{aligned} l_1[i]&amp;=a_i(l_1[i-1]+1) \newline l_2[i]&amp;=a_i(l_2[i-1]+2l_1[i-1]+1) \end{aligned}$$ 于是可以做到 $O(n)$。<br>注意区分 $f[]$ 和 $l[]$ 的定义，前者是全局的期望价值，后者是末位极长全 1 串的期望价值，同时还需要区分一下 “长度的三次方的期望” 和 “长度的期望的三次方”。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = a[i] * (l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l2[i] = a[i] * (l2[i - <span class="number">1</span>] + <span class="number">2</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + a[i] * (<span class="number">3</span> * l2[i - <span class="number">1</span>] + <span class="number">3</span> * l[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>「杂题选做」八月口胡合集</p><p><a href="https://big-news.cn/2020/08/24/「杂题选做」八月口胡合集/">https://big-news.cn/2020/08/24/「杂题选做」八月口胡合集/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ce-amtic</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-08-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/oi-blog/tags/%E7%9E%8E%E6%90%9E/">瞎搞</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/oi-blog/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「题解」Fancy Fence</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/oi-blog/2020/08/23/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"><span class="level-item">最小斯坦纳树</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "J8OJ7MUCd2S0T59f6kSUn4E7-gzGzoHsz",
            appKey: "GToPzNfPvMfduDLYX58Pi03F",
            placeholder: "说些什么...",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-Hunger-Game"><span class="level-left"><span class="none-display">1</span><span class="level-item">1 Hunger Game</span></span></a></li><li><a class="level is-mobile" href="#2-Minimum-Value-of-Equation"><span class="level-left"><span class="none-display">2</span><span class="level-item">2 Minimum Value of Equation</span></span></a></li><li><a class="level is-mobile" href="#3-DFS-Count"><span class="level-left"><span class="none-display">3</span><span class="level-item">3 DFS Count</span></span></a></li><li><a class="level is-mobile" href="#4-XOR-Product"><span class="level-left"><span class="none-display">4</span><span class="level-item">4 XOR Product</span></span></a></li><li><a class="level is-mobile" href="#5-SUMXOR"><span class="level-left"><span class="none-display">5</span><span class="level-item">5 SUMXOR</span></span></a></li><li><a class="level is-mobile" href="#6-The-Hanged-Man"><span class="level-left"><span class="none-display">6</span><span class="level-item">6 The Hanged Man</span></span></a></li><li><a class="level is-mobile" href="#7-Anton-and-Ira"><span class="level-left"><span class="none-display">7</span><span class="level-item">7 Anton and Ira</span></span></a></li><li><a class="level is-mobile" href="#8-Increasing-Shortest-Path"><span class="level-left"><span class="none-display">8</span><span class="level-item">8 Increasing Shortest Path</span></span></a></li><li><a class="level is-mobile" href="#9-Increasing-Number"><span class="level-left"><span class="none-display">9</span><span class="level-item">9 Increasing Number</span></span></a></li><li><a class="level is-mobile" href="#10-Little-Elephant-and-Colored-Coins"><span class="level-left"><span class="none-display">10</span><span class="level-item">10 Little Elephant and Colored Coins</span></span></a></li><li><a class="level is-mobile" href="#11-Balance"><span class="level-left"><span class="none-display">11</span><span class="level-item">11 Balance</span></span></a></li><li><a class="level is-mobile" href="#12-Arrangement-Count"><span class="level-left"><span class="none-display">12</span><span class="level-item">12 Arrangement Count</span></span></a></li><li><a class="level is-mobile" href="#13-Cut-Tree"><span class="level-left"><span class="none-display">13</span><span class="level-item">13 Cut Tree</span></span></a></li><li><a class="level is-mobile" href="#14-Number-Game"><span class="level-left"><span class="none-display">14</span><span class="level-item">14 Number Game</span></span></a></li><li><a class="level is-mobile" href="#15-Distributs"><span class="level-left"><span class="none-display">15</span><span class="level-item">15 Distributs</span></span></a></li><li><a class="level is-mobile" href="#16-Solutions-of-the-Equation"><span class="level-left"><span class="none-display">16</span><span class="level-item">16 Solutions of the Equation</span></span></a></li><li><a class="level is-mobile" href="#17-Bohater"><span class="level-left"><span class="none-display">17</span><span class="level-item">17 Bohater</span></span></a></li><li><a class="level is-mobile" href="#18-Swap-Space"><span class="level-left"><span class="none-display">18</span><span class="level-item">18 Swap Space</span></span></a></li><li><a class="level is-mobile" href="#19-Maximum-Value-of-Linear-Function"><span class="level-left"><span class="none-display">19</span><span class="level-item">19 Maximum Value of Linear Function</span></span></a></li><li><a class="level is-mobile" href="#20-Kuglarz"><span class="level-left"><span class="none-display">20</span><span class="level-item">20 Kuglarz</span></span></a></li><li><a class="level is-mobile" href="#21-OSU"><span class="level-left"><span class="none-display">21</span><span class="level-item">21 OSU!</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/oi-blog/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/oi-blog/"><img src="/oi-blog/img/logo.png" alt="bn&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 ce-amtic</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7"><a class="link-muted" href="/port/index.html">Port</a>  |  <span id="busuanzi_container_site_uv">共 <span id="busuanzi_value_site_uv">0</span> 个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-nc"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Share Alike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script src="/oi-blog/js/column.js"></script><script src="/oi-blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/oi-blog/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/oi-blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/oi-blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/oi-blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>